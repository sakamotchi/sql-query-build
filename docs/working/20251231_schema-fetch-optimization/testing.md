# テスト手順書 - スキーマ取得最適化（パフォーマンス改善）

**作成日**: 2025-12-31
**最終更新**: 2025-12-31

---

## 1. テスト環境

### 測定環境

| 項目 | 内容 |
|-----|------|
| OS | macOS 14.x (Darwin 25.2.0) |
| CPU | Apple Silicon M1/M2 |
| メモリ | 16GB |
| 測定ツール | Rust `std::time::Instant`, ブラウザ `performance.now()` |

### テストデータ

#### ベンチマークDB（3サイズ）

| サイズ | テーブル数 | カラム数/テーブル | インデックス数/テーブル | 用途 |
|-------|----------|-----------------|---------------------|------|
| 小規模 | 10 | 10 | 2 | 基本動作確認 |
| 中規模 | 100 | 20 | 3 | 通常規模での性能確認 |
| 大規模 | 500 | 30 | 5 | 大規模DBでの性能確認 |

#### DB種別

- **PostgreSQL 15** (Docker)
- **MySQL 8.0** (Docker)
- **SQLite 3** (ローカルファイル)

---

## 2. ベンチマーク測定手順（Phase 7.1.1）

### TC-B-001: Before測定（改善前）- 小規模DB

**目的**: 現在のパフォーマンスを測定する（ベースライン）

**前提条件**: Phase 7.1.1-1でベンチマークDBが準備されていること

**手順**:

1. ベンチマークDB（小規模: 10テーブル）を起動
2. アプリケーションを起動（`npm run tauri:dev`）
3. クエリビルダー画面を開く
4. 接続を選択（初回取得）
5. ターミナルまたはブラウザコンソールで以下の値を記録：
   - Rust側: `[PERF] get_database_structure: XXXms`
   - TypeScript側: `[PERF] fetchDatabaseStructure: XXXms`

**期待値**: N/A（現状測定）

**結果**:

| DB種別 | Rust側（ms） | TypeScript側（ms） | 合計（ms） | 備考 |
|-------|-------------|------------------|-----------|------|
| PostgreSQL | _______ | _______ | _______ | |
| MySQL | _______ | _______ | _______ | |
| SQLite | _______ | _______ | _______ | |

---

### TC-B-002: Before測定（改善前）- 中規模DB

**目的**: 中規模DBでのパフォーマンスを測定する

**手順**: TC-B-001と同様（ベンチマークDB: 中規模）

**結果**:

| DB種別 | Rust側（ms） | TypeScript側（ms） | 合計（ms） | 備考 |
|-------|-------------|------------------|-----------|------|
| PostgreSQL | _______ | _______ | _______ | |
| MySQL | _______ | _______ | _______ | |
| SQLite | _______ | _______ | _______ | |

---

### TC-B-003: Before測定（改善前）- 大規模DB

**目的**: 大規模DBでのパフォーマンスを測定する

**手順**: TC-B-001と同様（ベンチマークDB: 大規模）

**結果**:

| DB種別 | Rust側（ms） | TypeScript側（ms） | 合計（ms） | 備考 |
|-------|-------------|------------------|-----------|------|
| PostgreSQL | _______ | _______ | _______ | |
| MySQL | _______ | _______ | _______ | |
| SQLite | _______ | _______ | _______ | |

---

## 3. キャッシュ機構の検証（Phase 7.1.3）

### TC-C-001: キャッシュヒット時の性能確認

**目的**: 2回目以降の取得が高速化されることを確認する

**前提条件**: Phase 7.1.3が完了していること

**手順**:

1. ベンチマークDB（中規模）を起動
2. アプリケーションを起動
3. クエリビルダー画面を開く
4. 接続を選択（1回目: キャッシュミス）
5. ログで `[PERF] Cache miss` を確認
6. 取得時間を記録
7. 別の接続に切り替えて、再度同じ接続を選択（2回目: キャッシュヒット）
8. ログで `[PERF] Cache hit` を確認
9. 取得時間を記録

**期待値**:
- 1回目（キャッシュミス）: ≤ 2000ms
- 2回目（キャッシュヒット）: ≤ 100ms

**結果**:

| DB種別 | 1回目（ms） | 2回目（ms） | 改善率（%） | 目標達成 |
|-------|-----------|-----------|-----------|---------|
| PostgreSQL | _______ | _______ | _______ | ☐ 達成 / ☐ 未達成 |
| MySQL | _______ | _______ | _______ | ☐ 達成 / ☐ 未達成 |
| SQLite | _______ | _______ | _______ | ☐ 達成 / ☐ 未達成 |

---

### TC-C-002: TTL満了時のキャッシュ無効化確認

**目的**: TTL満了後に自動的にキャッシュが無効化されることを確認する

**前提条件**: TTL設定が5分（またはテスト用に短縮）

**手順**:

1. ベンチマークDB（小規模）を起動
2. アプリケーションを起動
3. 接続を選択（1回目: キャッシュミス）
4. TTL時間（5分）経過を待つ
5. 再度同じ接続を選択（キャッシュ期限切れでミスになるはず）
6. ログで `[PERF] Cache miss` を確認

**期待値**: TTL満了後はキャッシュミスとなり、再取得される

**結果**: ☐ 合格 / ☐ 不合格

**備考**:

---

### TC-C-003: 手動リフレッシュ機能の確認

**目的**: 手動リフレッシュでキャッシュが無効化されることを確認する

**前提条件**: Phase 7.1.5が完了していること

**手順**:

1. ベンチマークDB（小規模）を起動
2. アプリケーションを起動
3. 接続を選択（1回目: キャッシュに保存）
4. DatabaseTreeのリフレッシュボタンをクリック
5. ログで `[PERF] Cache miss` を確認（キャッシュが無効化された）
6. 再取得が完了することを確認

**期待値**: リフレッシュボタンで強制的に再取得される

**結果**: ☐ 合格 / ☐ 不合格

**備考**:

---

## 4. 並列化の検証（Phase 7.1.3）

### TC-P-001: SQL並列化の効果確認

**目的**: スキーマ/テーブル取得の並列化により性能が向上することを確認する

**前提条件**: Phase 7.1.3-5が完了していること

**手順**:

1. ベンチマークDB（中規模）を起動
2. アプリケーションを起動
3. 接続を選択（キャッシュクリア後）
4. 取得時間を記録
5. ログで並列実行のメッセージを確認（実装により異なる）

**期待値**:
- TC-B-002（改善前）の測定値から20%以上の改善

**結果**:

| DB種別 | 並列化前（ms） | 並列化後（ms） | 改善率（%） | 目標達成 |
|-------|--------------|--------------|-----------|---------|
| PostgreSQL | _______ | _______ | _______ | ☐ 達成 / ☐ 未達成 |
| MySQL | _______ | _______ | _______ | ☐ 達成 / ☐ 未達成 |
| SQLite | _______ | _______ | _______ | ☐ 達成 / ☐ 未達成 |

---

## 5. 増分取得の検証（Phase 7.1.4）

### TC-I-001: 変更なし時の増分取得

**目的**: DB構造に変更がない場合、増分取得が高速であることを確認する

**前提条件**: Phase 7.1.4が完了していること

**手順**:

1. ベンチマークDB（小規模）を起動
2. アプリケーションを起動
3. 接続を選択（1回目: フル取得）
4. DB構造を変更せず、増分取得APIを呼び出し
5. ログで「変更なし」を確認
6. 取得時間を記録

**期待値**: ≤ 100ms

**結果**:

| DB種別 | 増分取得時間（ms） | 目標達成 |
|-------|------------------|---------|
| PostgreSQL | _______ | ☐ 達成 / ☐ 未達成 |
| MySQL | _______ | ☐ 達成 / ☐ 未達成 |
| SQLite | _______ | ☐ 達成 / ☐ 未達成 |

---

### TC-I-002: 一部変更時の増分取得

**目的**: DB構造の一部が変更された場合、差分のみ取得されることを確認する

**手順**:

1. ベンチマークDB（中規模）を起動
2. アプリケーションを起動
3. 接続を選択（1回目: フル取得）
4. DBに1テーブルを追加
5. 増分取得APIを呼び出し
6. ログで「変更検知、差分取得」を確認
7. 取得時間を記録

**期待値**: ≤ 500ms（フル取得より大幅に速い）

**結果**:

| DB種別 | 増分取得時間（ms） | フル取得時間（ms） | 改善率（%） | 目標達成 |
|-------|------------------|------------------|-----------|---------|
| PostgreSQL | _______ | _______ | _______ | ☐ 達成 / ☐ 未達成 |
| MySQL | _______ | _______ | _______ | ☐ 達成 / ☐ 未達成 |
| SQLite | _______ | _______ | _______ | ☐ 達成 / ☐ 未達成 |

---

## 6. UIブロック時間の検証（Phase 7.1.5）

### TC-UI-001: バックグラウンド取得の確認

**目的**: 構造取得中もUIが操作可能であることを確認する

**前提条件**: Phase 7.1.5が完了していること

**手順**:

1. ベンチマークDB（大規模）を起動
2. アプリケーションを起動
3. クエリビルダー画面を開く
4. 接続を選択（バックグラウンドで取得開始）
5. 取得中にUIを操作してみる：
   - ☐ 他の画面に遷移できる
   - ☐ ボタンがクリックできる
   - ☐ スクロールが滑らか
   - ☐ ローディングインジケーターが表示される
6. 取得完了時に自動的にDatabaseTreeが更新されることを確認

**期待値**: 取得中もUIがブロックされず、快適に操作できる

**結果**: ☐ 合格 / ☐ 不合格

**備考**:

---

### TC-UI-002: ローディング表示の確認

**目的**: ローディング中の視覚的フィードバックが適切であることを確認する

**手順**:

1. ベンチマークDB（大規模）を起動
2. アプリケーションを起動
3. 接続を選択
4. 以下を確認：
   - ☐ ローディングスピナーまたはスケルトンが表示される
   - ☐ 「読み込み中...」などのメッセージが表示される
   - ☐ キャッシュ表示中は「更新中」インジケーターが表示される（該当する場合）
   - ☐ 取得完了後、ローディング表示が消える

**期待値**: ユーザーが状態を理解しやすい視覚的フィードバック

**結果**: ☐ 合格 / ☐ 不合格

**備考**:

---

## 7. メモリ使用量測定

### TC-M-001: メモリ使用量の増加確認

**目的**: キャッシュによるメモリ使用量増加が目標値以内であることを確認する

**手順**:

1. アプリケーションを起動
2. ブラウザのDevToolsを開く（F12）
3. Memory タブを選択
4. Take snapshot をクリック（Before）
5. 複数の接続（10接続）でDB構造を取得（キャッシュに保存）
6. Take snapshot をクリック（After）
7. Heap size の差分を記録

**期待値**: 大規模DB（500テーブル）で10MB以内の増加

**結果**:

| 測定項目 | Before（MB） | After（MB） | 増加量（MB） | 目標値 | 達成状況 |
|---------|------------|-----------|------------|--------|---------|
| Heap Size | _______ | _______ | _______ | ≤ 10MB | ☐ 達成 / ☐ 未達成 |
| Memory Leak | - | - | - | なし | ☐ なし / ☐ あり |

---

### TC-M-002: LRUによる古いキャッシュの削除確認

**目的**: キャッシュサイズ上限を超えた場合、古いキャッシュが削除されることを確認する

**手順**:

1. キャッシュサイズ上限を小さく設定（例: 3接続）
2. アプリケーションを起動
3. 5つの異なる接続でDB構造を取得
4. ログで「LRU eviction」などのメッセージを確認
5. 最も古いキャッシュが削除されていることを確認

**期待値**: キャッシュサイズが上限を超えず、古いエントリが自動削除される

**結果**: ☐ 合格 / ☐ 不合格

**備考**:

---

## 8. 機能回帰テスト

### TC-R-001: 既存機能の動作確認

**目的**: 最適化により既存機能が壊れていないことを確認する

**手順**:

1. ☐ データベースツリーが正しく表示される
2. ☐ スキーマの展開/折りたたみが正常に動作する
3. ☐ テーブルのドラッグ&ドロップが正常に動作する
4. ☐ カラム選択UIが正常に動作する
5. ☐ クエリビルダーの他の機能（WHERE, GROUP BY等）が正常に動作する
6. ☐ クエリ実行が正常に動作する
7. ☐ 保存済みクエリの読み込みが正常に動作する
8. ☐ クエリ履歴の表示が正常に動作する

**期待値**: すべての機能が正常に動作する

**結果**: ☐ 合格 / ☐ 不合格

**備考**:

---

## 9. クロスDB種別テスト

### TC-DB-001: PostgreSQL

**目的**: PostgreSQLでの動作確認

**手順**: TC-C-001〜TC-UI-002を実施

**結果**:

| テストケース | 結果 | 備考 |
|------------|------|------|
| TC-C-001 | ☐ 合格 / ☐ 不合格 | |
| TC-C-002 | ☐ 合格 / ☐ 不合格 | |
| TC-C-003 | ☐ 合格 / ☐ 不合格 | |
| TC-P-001 | ☐ 合格 / ☐ 不合格 | |
| TC-I-001 | ☐ 合格 / ☐ 不合格 | |
| TC-I-002 | ☐ 合格 / ☐ 不合格 | |
| TC-UI-001 | ☐ 合格 / ☐ 不合格 | |
| TC-UI-002 | ☐ 合格 / ☐ 不合格 | |

---

### TC-DB-002: MySQL

**目的**: MySQLでの動作確認

**手順**: TC-C-001〜TC-UI-002を実施

**結果**: （PostgreSQLと同様）

---

### TC-DB-003: SQLite

**目的**: SQLiteでの動作確認

**手順**: TC-C-001〜TC-UI-002を実施

**結果**: （PostgreSQLと同様）

---

## 10. 自動ベンチマークテスト

### Rustベンチマークテスト

```rust
#[cfg(test)]
mod benchmarks {
    use super::*;
    use std::time::Instant;

    #[tokio::test]
    async fn bench_get_database_structure_small() {
        // 10テーブルのDB
        let start = Instant::now();
        let _ = get_database_structure(/* ... */).await;
        let duration = start.elapsed();

        assert!(
            duration.as_millis() < 1000,
            "Expected < 1000ms for small DB, got {:?}",
            duration
        );
    }

    #[tokio::test]
    async fn bench_get_database_structure_large() {
        // 500テーブルのDB
        let start = Instant::now();
        let _ = get_database_structure(/* ... */).await;
        let duration = start.elapsed();

        assert!(
            duration.as_millis() < 5000,
            "Expected < 5000ms for large DB, got {:?}",
            duration
        );
    }

    #[tokio::test]
    async fn bench_cache_hit() {
        // 2回目取得（キャッシュヒット）
        let _ = get_database_structure(/* ... */).await; // 1回目

        let start = Instant::now();
        let _ = get_database_structure(/* ... */).await; // 2回目
        let duration = start.elapsed();

        assert!(
            duration.as_millis() < 100,
            "Expected < 100ms for cache hit, got {:?}",
            duration
        );
    }
}
```

**実行コマンド**: `cargo test --release benchmarks`

**結果**: ☐ 合格 / ☐ 不合格

---

### TypeScriptベンチマークテスト

```typescript
// app/stores/__tests__/database-structure.bench.ts

import { describe, it, expect, beforeEach } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { useDatabaseStructureStore } from '../database-structure';

describe('Database Structure Store - Performance', () => {
  beforeEach(() => {
    setActivePinia(createPinia());
  });

  it('should fetch structure within 2 seconds (small DB)', async () => {
    const store = useDatabaseStructureStore();
    const connectionId = 'test-connection-small';

    const start = performance.now();
    await store.fetchDatabaseStructure(connectionId);
    const duration = performance.now() - start;

    expect(duration).toBeLessThan(2000);
  });

  it('should use cache on second fetch (< 100ms)', async () => {
    const store = useDatabaseStructureStore();
    const connectionId = 'test-connection-cached';

    // 1回目取得
    await store.fetchDatabaseStructure(connectionId);

    // 2回目取得（キャッシュヒット）
    const start = performance.now();
    await store.fetchDatabaseStructure(connectionId);
    const duration = performance.now() - start;

    expect(duration).toBeLessThan(100);
  });
});
```

**実行コマンド**: `npm run test`

**結果**: ☐ 合格 / ☐ 不合格

---

## 11. 総合評価

### 目標達成状況（Phase 7.1全体）

| 測定項目 | Before | After | 目標値 | 達成状況 |
|---------|--------|-------|--------|---------|
| **T-1: 初回取得（小規模DB）** | _______ ms | _______ ms | ≤ 500ms | ☐ 達成 / ☐ 未達成 |
| **T-1: 初回取得（中規模DB）** | _______ ms | _______ ms | ≤ 2000ms | ☐ 達成 / ☐ 未達成 |
| **T-1: 初回取得（大規模DB）** | _______ ms | _______ ms | ≤ 5000ms | ☐ 達成 / ☐ 未達成 |
| **T-2: 2回目以降（キャッシュヒット）** | _______ ms | _______ ms | ≤ 100ms | ☐ 達成 / ☐ 未達成 |
| **T-3: メモリ使用量増加** | N/A | _______ MB | ≤ 10MB | ☐ 達成 / ☐ 未達成 |
| **T-4: UIブロック時間** | _______ ms | 0ms | 0ms | ☐ 達成 / ☐ 未達成 |

### 総合判定

- ☐ すべての目標を達成（合格）
- ☐ 一部の目標を達成（条件付き合格）
- ☐ 目標未達成（不合格）

### 備考

- Phase 7.1.1でベースライン測定を完了し、「Before」列を埋める
- Phase 7.1.3〜7.1.5の各フェーズ完了後に該当するテストケースを実施
- 最終的にPhase 7.1.5完了後、すべての目標値の達成を確認

---

## 12. 課題・改善点

| 課題ID | 内容 | 対応方針 | 優先度 | 対応状況 |
|-------|------|---------|--------|---------|
| I-001 | | | | ☐ 未対応 / ☐ 対応中 / ☐ 完了 |

---

## 13. 参考資料

- `docs/working/20251231_schema-fetch-optimization/requirements.md`: 要件定義書
- `docs/working/20251231_schema-fetch-optimization/design.md`: 設計書
- `docs/working/20251231_schema-fetch-optimization/tasklist.md`: タスクリスト
- `docs/working/20251231_schema-fetch-optimization/benchmark-results.md`: ベンチマーク結果（Phase 7.1.1で作成）
- WBS v3.7: Phase 7.1（データベース構造取得の最適化）
