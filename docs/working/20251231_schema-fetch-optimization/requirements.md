# 要件定義書 - スキーマ取得最適化（パフォーマンス改善）

## 概要

データベース構造取得処理のパフォーマンスを改善し、クエリビルダーのユーザー体験を向上させます。特に、大規模なデータベース（多数のスキーマ/テーブル/カラムを持つDB）での初回読み込み時間を短縮し、同一接続での再取得を高速化するキャッシュ機構を実装します。

## 現状の問題点

### パフォーマンス課題

現在のデータベース構造取得処理では、以下の問題が発生しています。

- **症状**:
  - 大規模DB（100+テーブル）での初回構造取得に3秒以上かかる
  - 同じ接続で再度構造を取得する際も毎回フルスキャンが実行される
  - クエリビルダー画面の表示がブロックされ、ユーザーが待たされる

- **影響範囲**:
  - クエリビルダー画面の初回表示時
  - 接続切り替え時
  - 手動リフレッシュ時
  - すべてのDB種別（PostgreSQL, MySQL, SQLite）

- **発生頻度**:
  - 毎回の構造取得時（キャッシュ機構がないため）

### 現状の測定値

- **初回構造取得時間**: 未計測（Phase 7.1.1で計測予定）
- **再取得時間**: 未計測（キャッシュがないため初回と同等と推測）
- **メモリ使用量**: 未計測

### 現状の実装

- **バックエンド**:
  - `src-tauri/src/services/database_inspector.rs`: トレイト定義
  - `src-tauri/src/database/postgresql_inspector.rs`: PostgreSQL実装
  - `src-tauri/src/database/mysql_inspector.rs`: MySQL実装
  - `src-tauri/src/database/sqlite_inspector.rs`: SQLite実装
  - `src-tauri/src/commands/database_structure.rs`: Tauriコマンド

- **フロントエンド**:
  - `app/api/database-structure.ts`: APIラッパー
  - `app/stores/database-structure.ts`: Piniaストア（メモリキャッシュのみ）

- **現在のキャッシュ機構**:
  - フロントエンド側のPiniaストアに接続IDごとに構造データを保持
  - アプリ再起動時にはキャッシュがクリアされる
  - バックエンド側にはキャッシュ機構なし

## 目標値

### パフォーマンス目標

#### T-1: DB構造取得時間（初回）

- **現状**: 未計測（推定: 3秒以上）
- **目標**: 2秒以内（大規模DBでも体感的に速い）
- **優先度**: 高
- **達成条件**:
  - [x] 100テーブル以上のDBで2秒以内
  - [x] 500テーブル以上のDBで5秒以内
  - [x] タイムアウト設定（30秒）を超えない

#### T-2: DB構造取得時間（2回目以降）

- **現状**: 初回と同等（キャッシュなし）
- **目標**: 1秒以内（キャッシュヒット時）
- **優先度**: 高
- **達成条件**:
  - [x] キャッシュヒット時は100ms以内
  - [x] 増分更新時は変更部分のみ取得

#### T-3: メモリ使用量

- **現状**: 未計測
- **目標**: キャッシュによる増加を10MB以内に抑える
- **優先度**: 中
- **達成条件**:
  - [x] 大規模DB（500テーブル）で10MB以内の増加
  - [x] 不要なキャッシュは自動削除される

#### T-4: UIブロック時間

- **現状**: 構造取得中はUI全体がブロックされる
- **目標**: UIブロックなし（バックグラウンド取得）
- **優先度**: 高
- **達成条件**:
  - [x] 構造取得中もUI操作可能
  - [x] ローディング状態を視覚的に表示
  - [x] 取得完了時に自動更新

### 非機能要件

- **互換性**: 既存のAPI（`getDatabaseStructure`等）に影響を与えないこと
- **保守性**: キャッシュ機構のコードが理解しやすく、デバッグしやすいこと
- **テスト容易性**: パフォーマンス改善の効果を測定可能にすること（ベンチマークコード）
- **データ整合性**: キャッシュと実DBの構造が乖離しないこと（適切な無効化タイミング）

## 改善対象範囲

### 対象

- **7.1.1 DB構造取得処理の計測**
  - 各DB種別（PostgreSQL, MySQL, SQLite）での計測
  - テーブル数による計測（10, 100, 500テーブル）
  - ボトルネック特定（SQL実行時間、ネットワーク、データシリアライズ等）

- **7.1.2 キャッシュ機構の設計**
  - キャッシュ戦略の策定（LRU, TTL, 手動無効化等）
  - キャッシュ保存場所の決定（メモリ、ディスク、または両方）
  - キャッシュキーの設計（接続ID + 構造ハッシュ等）

- **7.1.3 スキーマキャッシュ実装（Rust）**
  - バックエンド側のキャッシュ機構実装
  - 接続ごとのキャッシュ管理
  - キャッシュ有効期限の管理

- **7.1.4 増分取得API実装**
  - 変更検知機構（構造のハッシュ比較等）
  - 変更部分のみの取得API
  - 差分適用ロジック

- **7.1.5 バックグラウンド更新機能**
  - 非同期での構造取得
  - UI非ブロック化
  - 進捗通知機構

### 対象外

- クエリ実行のパフォーマンス改善（Phase 7.2で対応）
- JOIN提案処理のパフォーマンス改善（Phase 7.3で対応）
- 外部キー情報の取得最適化（Phase 6Cで対応予定、今回は基本構造のみ）

## ボトルネック仮説

現時点で推測されるボトルネック（Phase 7.1.1の計測後に更新）：

1. **SQL実行回数の多さ**: スキーマ、テーブル、カラム、インデックス、外部キーを個別に取得している
2. **ネットワークレイテンシ**: リモートDBへの複数回の往復通信
3. **データシリアライズ**: Rust → JSON → TypeScript の変換オーバーヘッド
4. **同期実行**: すべてのスキーマを順次取得している（並列化できる可能性）

## 最適化対象ファイル（予定）

### バックエンド（Rust）

- `src-tauri/src/services/database_inspector.rs` - トレイト拡張（キャッシュAPI追加）
- `src-tauri/src/database/postgresql_inspector.rs` - PostgreSQL最適化
- `src-tauri/src/database/mysql_inspector.rs` - MySQL最適化
- `src-tauri/src/database/sqlite_inspector.rs` - SQLite最適化
- `src-tauri/src/commands/database_structure.rs` - キャッシュ統合
- `src-tauri/src/services/schema_cache.rs` (新規) - キャッシュサービス
- `src-tauri/src/models/cache_metadata.rs` (新規) - キャッシュメタデータ

### フロントエンド（TypeScript）

- `app/api/database-structure.ts` - 増分取得API追加
- `app/stores/database-structure.ts` - バックグラウンド更新対応
- `app/components/query-builder/DatabaseTree.vue` - ローディングUI改善

## 依存関係

- **Phase 2完了**: クエリ実行機能が実装済み
- **Phase 6C**: 外部キー情報の自動提案機能（将来的にキャッシュ対象に含める）

## 既知の制約

- **SQLiteの制約**: ローカルファイルのため、ネットワークレイテンシは問題にならない
- **接続プール**: 既存の接続プール実装を活用する（Phase 7.2で最適化予定）
- **メモリ制限**: デスクトップアプリのため、数十MB程度のキャッシュは許容範囲

## ベンチマーク方針

### 測定方法

1. **ベンチマークDB準備**:
   - 小規模: 10テーブル、各10カラム
   - 中規模: 100テーブル、各20カラム
   - 大規模: 500テーブル、各30カラム

2. **測定項目**:
   - 初回取得時間（キャッシュなし）
   - 2回目取得時間（キャッシュあり）
   - 増分取得時間（1テーブル追加後）
   - メモリ使用量
   - CPU使用率

3. **計測コード**:
   - Rust側: `std::time::Instant`で計測
   - フロントエンド側: `performance.now()`で計測
   - ログ出力で各処理の所要時間を記録

### 測定環境

- **OS**: macOS 14.x (開発環境)
- **CPU**: Apple Silicon M1/M2
- **メモリ**: 16GB
- **DB環境**:
  - PostgreSQL 15 (Docker)
  - MySQL 8.0 (Docker)
  - SQLite 3 (ローカルファイル)

### 測定タイミング

- Phase 7.1.1: 現状の計測（ベースライン）
- Phase 7.1.3: キャッシュ実装後の計測
- Phase 7.1.4: 増分取得実装後の計測
- Phase 7.1.5: バックグラウンド更新実装後の最終計測

## 参考資料

- WBS v3.7: Phase 7.1（データベース構造取得の最適化）
- `docs/03_architecture_specifications.md`: 技術仕様書
- `docs/features/query-builder.md`: クエリビルダー機能詳細仕様
