# テスト手順書：SQLエディタコードアシスト機能

## 1. 概要

このドキュメントは、SQLエディタコードアシスト機能のテスト手順を記載します。
**可能な限り手動操作でテストを実施**し、操作で確認できない項目のみユニットテストで検証します。

## 2. 事前準備

### 2.1 アプリケーションの起動

```bash
npm run tauri:dev
```

### 2.2 テストデータベースの準備

Docker Composeでテスト用PostgreSQLを起動：

```bash
cd docker
docker-compose up -d postgres-benchmark
```

**接続情報**:
- Host: localhost
- Port: 5433
- User: benchmark
- Password: benchmark
- Database: postgres

### 2.3 データベース接続の登録

1. アプリケーションを起動
2. 接続管理画面で上記のPostgreSQL接続を登録
3. 接続テストを実施し、成功することを確認
4. 接続を選択し、アクティブにする

### 2.4 スキーマ情報の取得確認

1. SQLエディタを開く
2. スキーマ情報が取得されていることを確認
   - ツールバーやサイドパネルでテーブル一覧が表示されることを確認
   - エラーが発生していないことを確認

---

## 3. 機能テスト（手動操作）

### 3.1 SQLキーワード補完

#### Test 3.1.1: SELECT文の補完
**目的**: SQLキーワードが補完されることを確認

**手順**:
1. SQLエディタに "SEL" と入力
2. 補完候補が表示されることを確認
3. 候補に "SELECT" が含まれることを確認
4. 矢印キーで "SELECT" を選択
5. Enter キーで確定
6. エディタに "SELECT" が挿入されることを確認

**期待結果**:
- ✅ 補完候補が自動で表示される
- ✅ "SELECT" が候補に含まれる
- ✅ Enter で確定すると "SELECT" が挿入される

---

#### Test 3.1.2: JOIN句の補完
**目的**: スペース区切りの複数単語キーワードが補完されることを確認

**手順**:
1. SQLエディタに "SELECT * FROM users " と入力（末尾にスペース）
2. "JOIN" と入力開始
3. 補完候補が表示されることを確認
4. 候補に以下が含まれることを確認
   - JOIN
   - INNER JOIN
   - LEFT JOIN
   - RIGHT JOIN
   - FULL JOIN
   - CROSS JOIN
5. "LEFT JOIN" を選択して確定

**期待結果**:
- ✅ 各種JOIN句が候補に表示される
- ✅ "LEFT JOIN" が正しく挿入される

---

#### Test 3.1.3: 大文字小文字の区別なし
**目的**: 大文字小文字を区別せずに補完されることを確認

**手順**:
1. SQLエディタに "select" と小文字で入力
2. 補完候補が表示されることを確認
3. "SELECT" が候補に含まれることを確認
4. 逆に "SEL" と大文字で入力しても同様に候補が表示されることを確認

**期待結果**:
- ✅ 小文字入力でも大文字キーワードが候補に表示される
- ✅ 大文字入力でも候補が表示される

---

### 3.2 SQL関数補完

#### Test 3.2.1: 集約関数の補完
**目的**: SQL関数が補完されることを確認

**手順**:
1. SQLエディタに "SELECT COU" と入力
2. 補完候補が表示されることを確認
3. 候補に "COUNT" が含まれることを確認
4. "COUNT" を選択して確定
5. "COUNT()" が挿入され、カーソルが括弧内に移動することを確認

**期待結果**:
- ✅ "COUNT" が候補に表示される
- ✅ 確定すると "COUNT()" が挿入される
- ✅ カーソルが括弧内（`COUNT(|)`）に移動する

---

#### Test 3.2.2: 文字列関数の補完
**目的**: 文字列関数が補完され、詳細情報が表示されることを確認

**手順**:
1. SQLエディタに "SELECT CONC" と入力
2. 補完候補に "CONCAT" が表示されることを確認
3. "CONCAT" にカーソルを合わせる
4. 詳細情報（カテゴリ: string、説明、構文例）が表示されることを確認

**期待結果**:
- ✅ "CONCAT" が候補に表示される
- ✅ 詳細情報に「string - 文字列を結合」が表示される
- ✅ 構文例「CONCAT(string1, string2, ...)」が表示される

---

#### Test 3.2.3: DBMS固有関数のフィルタ（PostgreSQL）
**目的**: PostgreSQL接続時にPostgreSQL固有関数が表示されることを確認

**前提**: PostgreSQL接続がアクティブ

**手順**:
1. SQLエディタに "SELECT array" と入力
2. 補完候補に "array_agg" が表示されることを確認
3. "array_agg" を選択して詳細を確認
4. 詳細に「PostgreSQL」の記載があることを確認

**期待結果**:
- ✅ "array_agg" が候補に表示される
- ✅ 詳細に「aggregate - 配列に集約（PostgreSQL）」が表示される

---

#### Test 3.2.4: DBMS固有関数のフィルタ（MySQL）
**目的**: MySQL接続時にMySQL固有関数が表示され、PostgreSQL固有関数が表示されないことを確認

**前提**: MySQL接続がアクティブ（別途MySQL接続を準備）

**手順**:
1. MySQL接続に切り替え
2. SQLエディタに "SELECT GROUP" と入力
3. 補完候補に "GROUP_CONCAT" が表示されることを確認
4. "SELECT array" と入力
5. "array_agg" が候補に表示されないことを確認

**期待結果**:
- ✅ MySQL接続時に "GROUP_CONCAT" が表示される
- ✅ MySQL接続時に "array_agg" が表示されない

---

### 3.3 テーブル名補完

#### Test 3.3.1: テーブル名の基本補完
**目的**: データベースのテーブル名が補完されることを確認

**前提**: データベースにテーブルが存在する（例: users, posts, comments）

**手順**:
1. SQLエディタに "SELECT * FROM u" と入力
2. 補完候補が表示されることを確認
3. 候補に "users" が含まれることを確認
4. "users" を選択して確定
5. "users" が挿入されることを確認

**期待結果**:
- ✅ "users" が候補に表示される
- ✅ Enter で確定すると "users" が挿入される

---

#### Test 3.3.2: スキーマ修飾名の補完
**目的**: スキーマ名を含む完全修飾名が補完されることを確認

**手順**:
1. SQLエディタに "SELECT * FROM public.u" と入力
2. 補完候補に "public.users" が表示されることを確認
3. "public.users" を選択して確定

**期待結果**:
- ✅ "public.users" が候補に表示される
- ✅ 確定すると "public.users" が挿入される

---

#### Test 3.3.3: テーブル詳細情報の表示
**目的**: テーブルのコメントや行数が表示されることを確認

**手順**:
1. SQLエディタに "SELECT * FROM " と入力
2. 補完候補のテーブル名にカーソルを合わせる
3. 詳細情報にテーブルコメント（存在する場合）または行数が表示されることを確認

**期待結果**:
- ✅ 詳細情報に「Table (XX rows)」が表示される
- ✅ テーブルコメントがあれば表示される

---

#### Test 3.3.4: システムテーブルの優先度
**目的**: システムテーブルが候補の後方に表示されることを確認

**手順**:
1. SQLエディタに "SELECT * FROM p" と入力
2. 補完候補を確認
3. ユーザーテーブル（例: posts）がシステムテーブル（例: pg_catalog）より上に表示されることを確認

**期待結果**:
- ✅ ユーザーテーブルが優先的に表示される
- ✅ システムテーブルは候補の後方に表示される

---

### 3.4 カラム名補完

#### Test 3.4.1: カラム名の基本補完
**目的**: テーブルのカラム名が補完されることを確認

**手順**:
1. SQLエディタに "SELECT user_" と入力
2. 補完候補が表示されることを確認
3. 候補に "user_id", "user_name" 等のカラムが含まれることを確認
4. "user_id" を選択して確定

**期待結果**:
- ✅ カラム名が候補に表示される
- ✅ 確定すると "user_id" が挿入される

---

#### Test 3.4.2: カラム型情報の表示
**目的**: カラムの型情報が表示されることを確認

**手順**:
1. SQLエディタに "SELECT user_id" と入力
2. "user_id" の補完候補にカーソルを合わせる
3. 詳細情報にカラムの型（例: "integer, PK"）が表示されることを確認

**期待結果**:
- ✅ 詳細情報に「integer, PK」が表示される
- ✅ PRIMARY KEY制約が表示される

---

#### Test 3.4.3: カラム制約情報の表示
**目的**: カラムの制約情報（PK, FK, UNIQUE等）が表示されることを確認

**手順**:
1. SQLエディタに "SELECT " と入力
2. 各種カラムの補完候補を確認
3. PRIMARY KEYカラムに「PK」が表示されることを確認
4. FOREIGN KEYカラムに「FK」が表示されることを確認
5. UNIQUEカラムに「UNIQUE」が表示されることを確認
6. AUTO_INCREMENTカラムに「AUTO」が表示されることを確認

**期待結果**:
- ✅ 各制約情報が正しく表示される
- ✅ 複数制約がある場合、すべて表示される（例: "integer, PK, AUTO"）

---

#### Test 3.4.4: カラムコメントの表示
**目的**: カラムのコメントが表示されることを確認

**前提**: データベースのカラムにコメントが設定されている

**手順**:
1. SQLエディタに "SELECT " と入力
2. コメント付きカラムの補完候補にカーソルを合わせる
3. 詳細情報にカラムコメントが表示されることを確認

**期待結果**:
- ✅ カラムコメントが詳細情報に表示される

---

#### Test 3.4.5: PRIMARY KEYの優先表示
**目的**: PRIMARY KEYカラムが優先的に表示されることを確認

**手順**:
1. SQLエディタに "SELECT " と入力
2. 補完候補を確認
3. PRIMARY KEYカラム（例: id, user_id）が候補の上位に表示されることを確認

**期待結果**:
- ✅ PRIMARY KEYカラムが候補の上位に表示される

---

### 3.5 トリガー動作

#### Test 3.5.1: リアルタイム表示
**目的**: 入力中に自動で補完候補が表示されることを確認

**手順**:
1. SQLエディタに "S" と1文字入力
2. 補完候補が自動で表示されることを確認
3. "E" と続けて入力
4. 候補がリアルタイムでフィルタされることを確認

**期待結果**:
- ✅ 1文字入力後、自動で補完候補が表示される
- ✅ 入力に応じてリアルタイムでフィルタされる

---

#### Test 3.5.2: トリガー文字（ドット）
**目的**: ドット入力時にテーブルのカラムが表示されることを確認

**手順**:
1. SQLエディタに "SELECT users." と入力（末尾にドット）
2. 補完候補が自動で表示されることを確認
3. usersテーブルのカラムが候補に含まれることを確認（将来対応）

**期待結果**（現在のバージョン）:
- ⚠️ 現在はすべてのカラムが表示される（コンテキスト解析は未実装）
- 将来: usersテーブルのカラムのみが表示される

---

#### Test 3.5.3: 手動トリガー（Ctrl+Space）
**目的**: Ctrl+Space（Mac: Cmd+Space）で手動で補完を呼び出せることを確認

**手順**:
1. SQLエディタに "SELECT " と入力（補完候補は表示しない）
2. Escキーで補完候補を閉じる
3. Ctrl+Space（Mac: Cmd+Space）を押下
4. 補完候補が表示されることを確認

**期待結果**:
- ✅ Ctrl+Spaceで補完候補が表示される
- ✅ Escで補完候補が閉じる

---

### 3.6 接続切り替え

#### Test 3.6.1: 接続切り替え時のスキーマ更新
**目的**: 接続を切り替えた際に補完候補が更新されることを確認

**前提**: 2つ以上のデータベース接続が登録されている

**手順**:
1. 接続Aをアクティブにする
2. SQLエディタに "SELECT * FROM " と入力
3. 接続Aのテーブルが候補に表示されることを確認
4. 接続Bに切り替え
5. 再度 "SELECT * FROM " と入力
6. 接続Bのテーブルが候補に表示されることを確認
7. 接続Aのテーブルが候補に表示されないことを確認

**期待結果**:
- ✅ 接続切り替え後、新しい接続のスキーマ情報が表示される
- ✅ 古い接続のテーブルは表示されない

---

### 3.7 パフォーマンス

#### Test 3.7.1: レスポンスタイム
**目的**: 補完候補の表示が100ms以内であることを確認

**手順**:
1. ブラウザの開発者ツールを開く（Tauri内でF12）
2. Consoleタブを開く
3. SQLエディタで補完を実行
4. Performance APIまたは体感で100ms以内に表示されることを確認

**期待結果**:
- ✅ 補完候補が即座に表示される（100ms以内）
- ✅ 入力のもたつきがない

---

#### Test 3.7.2: 大規模スキーマでのパフォーマンス
**目的**: テーブル数が多い場合でも快適に動作することを確認

**前提**: 100テーブル以上のデータベースを準備（オプション）

**手順**:
1. 大規模スキーマのデータベースに接続
2. SQLエディタで補完を実行
3. パフォーマンスが許容範囲内であることを確認
4. 候補数が多すぎて操作が困難でないことを確認

**期待結果**:
- ✅ 大規模スキーマでもレスポンスが遅くない
- ✅ 候補が適切にフィルタされている

---

### 3.8 エラーハンドリング

#### Test 3.8.1: 接続なしでの動作
**目的**: データベース接続がない場合でもキーワード・関数補完が動作することを確認

**手順**:
1. すべての接続を削除または非アクティブにする
2. SQLエディタに "SELECT" と入力
3. キーワード補完が表示されることを確認
4. 関数補完も表示されることを確認
5. テーブル名・カラム名補完は表示されないことを確認

**期待結果**:
- ✅ キーワード・関数補完は正常に動作する
- ✅ テーブル名・カラム名補完は表示されない
- ✅ エラーが発生しない

---

#### Test 3.8.2: スキーマ取得失敗時の動作
**目的**: スキーマ情報の取得に失敗した場合でもエディタが動作することを確認

**手順**:
1. 存在しないデータベースへの接続を試みる
2. スキーマ取得が失敗することを確認
3. SQLエディタで補完を実行
4. キーワード・関数補完のみが表示されることを確認
5. エディタ自体は正常に動作することを確認

**期待結果**:
- ✅ スキーマ取得失敗時もエディタは動作する
- ✅ キーワード・関数補完は正常に動作する
- ✅ エラーが適切にハンドリングされる

---

### 3.9 既存機能への影響確認

#### Test 3.9.1: SQL整形機能
**目的**: 補完機能追加後もSQL整形機能が正常に動作することを確認

**手順**:
1. SQLエディタに整形されていないSQLを入力
2. Ctrl+Shift+F（Mac: Cmd+Shift+F）を押下
3. SQLが整形されることを確認

**期待結果**:
- ✅ SQL整形機能が正常に動作する

---

#### Test 3.9.2: クエリ実行機能
**目的**: 補完機能追加後もクエリ実行機能が正常に動作することを確認

**手順**:
1. SQLエディタに "SELECT 1" と入力
2. Ctrl+Enter（Mac: Cmd+Enter）を押下
3. クエリが実行され、結果が表示されることを確認

**期待結果**:
- ✅ クエリ実行機能が正常に動作する

---

#### Test 3.9.3: クエリ保存機能
**目的**: 補完機能追加後もクエリ保存機能が正常に動作することを確認

**手順**:
1. SQLエディタにクエリを入力
2. Ctrl+S（Mac: Cmd+S）を押下
3. 保存ダイアログが表示されることを確認
4. クエリが保存されることを確認

**期待結果**:
- ✅ クエリ保存機能が正常に動作する

---

## 4. ユニットテスト（自動テスト）

操作で確認できない項目は、ユニットテストで検証します。

### 4.1 実行方法

```bash
npm run test -- useSqlCompletion.test.ts
```

### 4.2 テスト項目

以下のテストケースを実装：

#### Test 4.1: getKeywordCompletions - 前方一致フィルタ
**内容**: 入力文字で始まるキーワードのみが返されることを確認

```typescript
it('入力文字で始まるキーワードを返す', () => {
  // context.currentWord = "SEL"
  // 結果に "SELECT" が含まれることを確認
  // 結果に "INSERT" が含まれないことを確認
})
```

---

#### Test 4.2: getKeywordCompletions - 大文字小文字の区別なし
**内容**: 大文字小文字を区別せずにフィルタされることを確認

```typescript
it('大文字小文字を区別しない', () => {
  // context.currentWord = "sel" (小文字)
  // 結果に "SELECT" が含まれることを確認
})
```

---

#### Test 4.3: getFunctionCompletions - DBMS別フィルタ
**内容**: DBMS種別に応じて関数がフィルタされることを確認

```typescript
it('PostgreSQL固有関数はPostgreSQL接続時のみ表示', () => {
  // context.databaseType = 'postgresql'
  // context.currentWord = "array"
  // 結果に "array_agg" が含まれることを確認
})

it('MySQL固有関数はMySQL接続時のみ表示', () => {
  // context.databaseType = 'mysql'
  // context.currentWord = "GROUP"
  // 結果に "GROUP_CONCAT" が含まれることを確認
  // 結果に "array_agg" が含まれないことを確認
})
```

---

#### Test 4.4: getFunctionCompletions - スニペット挿入
**内容**: 関数名に括弧が付加されることを確認

```typescript
it('関数名に括弧が付加される', () => {
  // 結果の insertText が "COUNT($0)" であることを確認
  // insertTextRules が InsertAsSnippet であることを確認
})
```

---

#### Test 4.5: getTableCompletions - 接続なし
**内容**: 接続IDがない場合は空配列を返すことを確認

```typescript
it('接続IDがない場合は空配列を返す', () => {
  // context.connectionId = null
  // 結果が空配列であることを確認
})
```

---

#### Test 4.6: getTableCompletions - スキーマ修飾名
**内容**: スキーマ名を含む完全修飾名でフィルタされることを確認

```typescript
it('スキーマ名を含む完全修飾名で補完', () => {
  // モックデータ: public.users, public.posts
  // context.currentWord = "public.u"
  // 結果に "public.users" が含まれることを確認
})
```

---

#### Test 4.7: getColumnCompletions - PRIMARY KEYの優先度
**内容**: PRIMARY KEYカラムのソート順が優先されることを確認

```typescript
it('PRIMARY KEYカラムのsortTextが優先される', () => {
  // PKカラムの sortText が "3_" で始まることを確認
  // 通常カラムの sortText が "4_" で始まることを確認
})
```

---

#### Test 4.8: getColumnCompletions - 制約情報の表示
**内容**: カラムの詳細情報に制約情報が含まれることを確認

```typescript
it('制約情報が詳細に含まれる', () => {
  // PKカラムの detail に "PK" が含まれることを確認
  // FKカラムの detail に "FK" が含まれることを確認
  // UNIQUEカラムの detail に "UNIQUE" が含まれることを確認
})
```

---

## 5. テスト結果記録

### 5.1 手動テストチェックリスト

実施日: YYYY-MM-DD

| テストID | テスト名 | 結果 | 備考 |
|---------|---------|------|------|
| 3.1.1 | SELECT文の補完 | ⬜ 合格 / ⬜ 不合格 | |
| 3.1.2 | JOIN句の補完 | ⬜ 合格 / ⬜ 不合格 | |
| 3.1.3 | 大文字小文字の区別なし | ⬜ 合格 / ⬜ 不合格 | |
| 3.2.1 | 集約関数の補完 | ⬜ 合格 / ⬜ 不合格 | |
| 3.2.2 | 文字列関数の補完 | ⬜ 合格 / ⬜ 不合格 | |
| 3.2.3 | DBMS固有関数（PostgreSQL） | ⬜ 合格 / ⬜ 不合格 | |
| 3.2.4 | DBMS固有関数（MySQL） | ⬜ 合格 / ⬜ 不合格 | |
| 3.3.1 | テーブル名の基本補完 | ⬜ 合格 / ⬜ 不合格 | |
| 3.3.2 | スキーマ修飾名の補完 | ⬜ 合格 / ⬜ 不合格 | |
| 3.3.3 | テーブル詳細情報の表示 | ⬜ 合格 / ⬜ 不合格 | |
| 3.3.4 | システムテーブルの優先度 | ⬜ 合格 / ⬜ 不合格 | |
| 3.4.1 | カラム名の基本補完 | ⬜ 合格 / ⬜ 不合格 | |
| 3.4.2 | カラム型情報の表示 | ⬜ 合格 / ⬜ 不合格 | |
| 3.4.3 | カラム制約情報の表示 | ⬜ 合格 / ⬜ 不合格 | |
| 3.4.4 | カラムコメントの表示 | ⬜ 合格 / ⬜ 不合格 | |
| 3.4.5 | PRIMARY KEYの優先表示 | ⬜ 合格 / ⬜ 不合格 | |
| 3.5.1 | リアルタイム表示 | ⬜ 合格 / ⬜ 不合格 | |
| 3.5.2 | トリガー文字（ドット） | ⬜ 合格 / ⬜ 不合格 | |
| 3.5.3 | 手動トリガー（Ctrl+Space） | ⬜ 合格 / ⬜ 不合格 | |
| 3.6.1 | 接続切り替え時のスキーマ更新 | ⬜ 合格 / ⬜ 不合格 | |
| 3.7.1 | レスポンスタイム | ⬜ 合格 / ⬜ 不合格 | |
| 3.7.2 | 大規模スキーマでのパフォーマンス | ⬜ 合格 / ⬜ 不合格 | |
| 3.8.1 | 接続なしでの動作 | ⬜ 合格 / ⬜ 不合格 | |
| 3.8.2 | スキーマ取得失敗時の動作 | ⬜ 合格 / ⬜ 不合格 | |
| 3.9.1 | SQL整形機能 | ⬜ 合格 / ⬜ 不合格 | |
| 3.9.2 | クエリ実行機能 | ⬜ 合格 / ⬜ 不合格 | |
| 3.9.3 | クエリ保存機能 | ⬜ 合格 / ⬜ 不合格 | |

### 5.2 ユニットテスト結果

```bash
npm run test -- useSqlCompletion.test.ts
```

実施日: YYYY-MM-DD

```
Test Suites: X passed, X total
Tests:       X passed, X total
Time:        X.XXXs
```

---

## 6. 不具合報告テンプレート

不具合が見つかった場合は、以下のフォーマットで報告してください：

```markdown
## 不具合報告

**発生日**: YYYY-MM-DD
**テストID**: X.X.X
**環境**: macOS / Windows / Linux

### 再現手順
1. ...
2. ...
3. ...

### 期待結果
- ...

### 実際の結果
- ...

### スクリーンショット
（あれば添付）

### 追加情報
- エラーメッセージ: ...
- ブラウザコンソールログ: ...
```

---

## 7. 関連ドキュメント

- [要件定義書](./requirements.md)
- [設計書](./design.md)
- [タスクリスト](./tasklist.md)
