# テスト手順書：保存クエリフォルダ管理 - Phase1 データモデル設計

**作成日**: 2026-01-24
**バージョン**: 1.0
**ステータス**: 📝 計画中

---

## 1. テスト概要

### 1.1 目的

Phase1のデータモデル設計の実装が正しく動作することを検証します。具体的には：

1. **TypeScript型定義の正確性**: フロントエンドの型定義が正しく動作すること
2. **Rust構造体の正確性**: バックエンドの構造体が正しくシリアライズ/デシリアライズされること
3. **バリデーション関数の正確性**: フォルダパスのバリデーションが期待通りに動作すること
4. **後方互換性の確保**: 既存のクエリJSONファイルが正常に読み込まれること

### 1.2 テストレベル

| テストレベル | 内容 | 実施方法 |
|------------|------|---------|
| 単体テスト | バリデーション関数のテスト | 自動テスト（Vitest, Cargo test） |
| 統合テスト | 型定義とシリアライズ/デシリアライズのテスト | 自動テスト + 手動確認 |
| 互換性テスト | 既存データの読み込み確認 | 手動テスト |
| ビルドテスト | TypeCheck とビルドが通ることを確認 | 自動テスト |

---

## 2. 自動テスト

### 2.1 TypeScriptバリデーション関数のテスト

**テストファイル**: [tests/utils/folder-validation.spec.ts](../../tests/utils/folder-validation.spec.ts)

**実行方法**:
```bash
npm run test tests/utils/folder-validation.spec.ts
```

**テストケース一覧**:

#### 2.1.1 `validateFolderPath()` のテスト

| テストケース | 入力 | 期待結果 |
|------------|------|---------|
| null を許容する | `null` | `{ valid: true }` |
| 正しいパス形式を許容する | `"/親/子/孫"` | `{ valid: true }` |
| 先頭スラッシュがない場合はエラー | `"親/子"` | `{ valid: false, error: "..." }` |
| 末尾スラッシュがある場合はエラー | `"/親/子/"` | `{ valid: false, error: "..." }` |
| 禁止文字を含む場合はエラー | `"/親:子"` | `{ valid: false, error: "..." }` |
| 10階層を超える場合はエラー | `"/a/b/c/d/e/f/g/h/i/j/k"` | `{ valid: false, error: "..." }` |
| パストラバーサルを含む場合はエラー | `"/親/../子"` | `{ valid: false, error: "..." }` |
| 空文字列の場合はエラー | `""` | `{ valid: false, error: "..." }` |

#### 2.1.2 `validateFolderName()` のテスト

| テストケース | 入力 | 期待結果 |
|------------|------|---------|
| 正しいフォルダ名を許容する | `"開発環境"` | `{ valid: true }` |
| 空文字列の場合はエラー | `""` | `{ valid: false, error: "..." }` |
| 100文字を超える場合はエラー | `"a".repeat(101)` | `{ valid: false, error: "..." }` |
| スラッシュを含む場合はエラー | `"親/子"` | `{ valid: false, error: "..." }` |
| 禁止文字を含む場合はエラー | `"親:子"` | `{ valid: false, error: "..." }` |
| パストラバーサルを含む場合はエラー | `".."` | `{ valid: false, error: "..." }` |

#### 2.1.3 `parseFolderPath()` のテスト

| テストケース | 入力 | 期待結果 |
|------------|------|---------|
| パスを分割する | `"/親/子/孫"` | `["親", "子", "孫"]` |
| 1階層のパスを分割する | `"/開発環境"` | `["開発環境"]` |
| null の場合は空配列 | `null` | `[]` |
| 空文字列の場合は空配列 | `""` | `[]` |

#### 2.1.4 `buildFolderPath()` のテスト

| テストケース | 入力 | 期待結果 |
|------------|------|---------|
| 配列からパスを構築する | `["親", "子", "孫"]` | `"/親/子/孫"` |
| 1要素の配列からパスを構築する | `["開発環境"]` | `"/開発環境"` |
| 空配列の場合は null | `[]` | `null` |

**合格基準**:
- [ ] 全てのテストケースが成功すること
- [ ] テストカバレッジが80%以上であること

---

### 2.2 Rustバリデーション関数のテスト

**テストファイル**: [src-tauri/src/utils/folder_validation.rs](../../src-tauri/src/utils/folder_validation.rs)（`#[cfg(test)] mod tests`）

**実行方法**:
```bash
cargo test --manifest-path=src-tauri/Cargo.toml folder_validation
```

**テストケース一覧**:

#### 2.2.1 `validate_folder_path()` のテスト

| テストケース | 入力 | 期待結果 |
|------------|------|---------|
| None を許容する | `None` | `Ok(())` |
| 正しいパス形式を許容する | `Some("/親/子/孫".to_string())` | `Ok(())` |
| 先頭スラッシュがない場合はエラー | `Some("親/子".to_string())` | `Err("...")` |
| 末尾スラッシュがある場合はエラー | `Some("/親/子/".to_string())` | `Err("...")` |
| 禁止文字を含む場合はエラー | `Some("/親:子".to_string())` | `Err("...")` |
| 10階層を超える場合はエラー | `Some("/a/b/c/d/e/f/g/h/i/j/k".to_string())` | `Err("...")` |
| パストラバーサルを含む場合はエラー | `Some("/親/../子".to_string())` | `Err("...")` |

#### 2.2.2 `parse_folder_path()` のテスト

| テストケース | 入力 | 期待結果 |
|------------|------|---------|
| パスを分割する | `Some("/親/子/孫".to_string())` | `vec!["親", "子", "孫"]` |
| None の場合は空ベクタ | `None` | `vec![]` |

#### 2.2.3 `build_folder_path()` のテスト

| テストケース | 入力 | 期待結果 |
|------------|------|---------|
| ベクタからパスを構築する | `&vec!["親".to_string(), "子".to_string()]` | `Some("/親/子".to_string())` |
| 空ベクタの場合は None | `&vec![]` | `None` |

#### 2.2.4 `validate_folder_name()` のテスト

| テストケース | 入力 | 期待結果 |
|------------|------|---------|
| 正しいフォルダ名を許容する | `"開発環境"` | `Ok(())` |
| 空文字列の場合はエラー | `""` | `Err("...")` |
| 禁止文字を含む場合はエラー | `"親/子"` | `Err("...")` |
| パストラバーサルを含む場合はエラー | `".."` | `Err("...")` |

**合格基準**:
- [ ] 全てのテストケースが成功すること

---

### 2.3 TypeCheck とビルドテスト

#### 2.3.1 TypeScript型チェック

**実行方法**:
```bash
npm run typecheck
```

**合格基準**:
- [ ] 型エラーが0件であること

#### 2.3.2 Nuxtビルド

**実行方法**:
```bash
npm run build
```

**合格基準**:
- [ ] ビルドが成功すること
- [ ] ビルド警告が0件であること

#### 2.3.3 Rustビルド

**実行方法**:
```bash
cargo build --manifest-path=src-tauri/Cargo.toml
```

**合格基準**:
- [ ] ビルドが成功すること
- [ ] コンパイル警告が0件であること

#### 2.3.4 Tauriアプリビルド

**実行方法**:
```bash
npm run tauri:build
```

**合格基準**:
- [ ] ビルドが成功すること
- [ ] 実行可能ファイルが生成されること

---

## 3. 手動テスト

### 3.1 既存データの読み込み確認

**目的**: 既存のクエリJSONファイル（`folder_path`フィールドなし）が正常に読み込まれることを確認

**前提条件**:
- 既存の保存クエリが存在すること
- 既存のクエリJSONファイルに `folder_path` フィールドが存在しないこと

**手順**:

#### 3.1.1 既存クエリの確認

1. **アプリケーションデータディレクトリを開く**:
   - macOS: `~/Library/Application Support/com.example.sql-query-builder/saved_queries/`
   - Windows: `%APPDATA%\com.example.sql-query-builder\saved_queries\`
   - Linux: `~/.local/share/com.example.sql-query-builder/saved_queries/`

2. **既存のクエリJSONファイルを1つ開く**:
   ```json
   {
     "id": "query-001",
     "name": "ユーザー検索",
     "description": "全ユーザーを取得",
     "tags": ["admin", "users"],
     "connectionId": "conn-001",
     "query": { ... },
     "createdAt": "2026-01-01T00:00:00Z",
     "updatedAt": "2026-01-01T00:00:00Z"
   }
   ```

3. **`folder_path`フィールドが存在しないことを確認**

**期待結果**:
- [ ] `folder_path` フィールドが存在しないJSONファイルが確認できる

#### 3.1.2 アプリケーション起動と読み込み確認

1. **アプリケーションを起動**:
   ```bash
   npm run tauri:dev
   ```

2. **ランチャー画面で接続を選択し、クエリビルダーを起動**

3. **保存クエリSlideoverを開く**:
   - 左サイドバーの「保存クエリ」アイコンをクリック

4. **既存クエリが一覧に表示されることを確認**

5. **既存クエリをクリックして読み込む**

6. **クエリが正常に読み込まれることを確認**:
   - テーブルが表示される
   - カラムが表示される
   - WHERE条件が表示される（存在する場合）

**期待結果**:
- [ ] 既存クエリが一覧に表示される
- [ ] 既存クエリをクリックして読み込むことができる
- [ ] クエリが正常に復元される
- [ ] エラーが発生しない

---

### 3.2 新規クエリの保存確認

**目的**: 新規クエリを保存した際に `folderPath: null` が設定されることを確認

**手順**:

#### 3.2.1 新規クエリの作成と保存

1. **クエリビルダーで新規クエリを作成**:
   - テーブルを選択
   - カラムを選択
   - 必要に応じてWHERE条件を追加

2. **ツールバーの「保存」ボタンをクリック**

3. **保存ダイアログで情報を入力**:
   - クエリ名: `テスト用クエリ`
   - 説明: `Phase1のテスト用`
   - タグ: `test`

4. **「保存」ボタンをクリック**

5. **保存成功のトースト通知が表示されることを確認**

**期待結果**:
- [ ] 保存成功のトースト通知が表示される
- [ ] エラーが発生しない

#### 3.2.2 保存したクエリのJSON確認

1. **アプリケーションデータディレクトリを開く**

2. **保存したクエリのJSONファイルを開く**:
   - ファイル名: `{クエリID}.json`

3. **JSONファイルの内容を確認**:
   ```json
   {
     "id": "query-xxx",
     "name": "テスト用クエリ",
     "description": "Phase1のテスト用",
     "tags": ["test"],
     "folderPath": null,
     "connectionId": "conn-xxx",
     "query": { ... },
     "createdAt": "2026-01-24T...",
     "updatedAt": "2026-01-24T..."
   }
   ```

4. **`folderPath` フィールドが `null` として保存されていることを確認**

5. **`connectionId` フィールドが保存されていることを確認**

**期待結果**:
- [ ] `folderPath` フィールドが存在する
- [ ] `folderPath` の値が `null` である
- [ ] `connectionId` フィールドが存在する
- [ ] その他のフィールドが正しく保存されている

---

### 3.3 保存したクエリの再読み込み確認

**目的**: 新規保存したクエリが正常に読み込まれることを確認

**手順**:

1. **保存クエリSlideoverを開く**

2. **先ほど保存した「テスト用クエリ」が一覧に表示されることを確認**

3. **「テスト用クエリ」をクリックして読み込む**

4. **クエリが正常に復元されることを確認**:
   - テーブルが表示される
   - カラムが表示される
   - WHERE条件が表示される（設定した場合）

5. **クエリを実行して結果が表示されることを確認**

**期待結果**:
- [ ] 保存したクエリが一覧に表示される
- [ ] クエリをクリックして読み込むことができる
- [ ] クエリが正常に復元される
- [ ] クエリを実行して結果が表示される
- [ ] エラーが発生しない

---

### 3.4 既存クエリの上書き保存確認

**目的**: 既存クエリを編集して上書き保存した際に `folderPath` が保持されることを確認

**手順**:

1. **既存クエリを読み込む**

2. **クエリを編集する**:
   - カラムを追加または削除
   - WHERE条件を変更

3. **ツールバーの「保存」ボタンをクリック**

4. **上書き保存の確認ダイアログが表示される場合は「上書き」を選択**

5. **保存成功のトースト通知が表示されることを確認**

6. **アプリケーションデータディレクトリでJSONファイルを確認**

7. **`folderPath` が `null` として保持されていることを確認**

**期待結果**:
- [ ] 上書き保存が成功する
- [ ] `folderPath` が `null` として保持される
- [ ] その他のフィールドが正しく更新される
- [ ] エラーが発生しない

---

### 3.5 検索機能の確認

**目的**: 既存の検索機能が引き続き動作することを確認

**手順**:

1. **保存クエリSlideoverを開く**

2. **検索バーにキーワードを入力**:
   - 例: `テスト`

3. **検索結果が表示されることを確認**

4. **タグフィルタを選択**:
   - 例: `test`

5. **フィルタリングされた結果が表示されることを確認**

6. **検索をクリアして全クエリが再表示されることを確認**

**期待結果**:
- [ ] キーワード検索が正常に動作する
- [ ] タグフィルタが正常に動作する
- [ ] 検索クリアが正常に動作する
- [ ] エラーが発生しない

---

## 4. 統合テスト

### 4.1 型定義とシリアライズ/デシリアライズのテスト

**目的**: TypeScript型定義とRust構造体が正しく連携していることを確認

**手順**:

#### 4.1.1 Tauri IPCの動作確認

1. **ブラウザの開発者ツールを開く**

2. **コンソールでTauri APIを直接呼び出す**:
   ```javascript
   // クエリ一覧を取得
   const queries = await window.__TAURI__.invoke('list_saved_queries')
   console.log(queries)

   // 結果を確認
   // - folderPath フィールドが存在するか
   // - connectionId フィールドが存在するか
   ```

3. **コンソールに表示された結果を確認**

**期待結果**:
- [ ] クエリ一覧が取得できる
- [ ] 各クエリに `folderPath` フィールドが存在する
- [ ] 各クエリに `connectionId` フィールドが存在する
- [ ] 既存クエリの `folderPath` が `null` である

#### 4.1.2 エラーハンドリングの確認

1. **存在しないクエリIDを指定して読み込みを試みる**:
   ```javascript
   await window.__TAURI__.invoke('load_saved_query', { queryId: 'non-existent-id' })
   ```

2. **適切なエラーメッセージが表示されることを確認**

**期待結果**:
- [ ] エラーが適切に処理される
- [ ] エラーメッセージが表示される

---

## 5. 後方互換性テスト

### 5.1 既存データの完全性確認

**目的**: Phase1実装前のデータが全て正常に読み込まれることを確認

**手順**:

1. **Phase1実装前にバックアップしたデータを用意**:
   - 既存の保存クエリディレクトリをバックアップ

2. **Phase1実装後のアプリケーションで既存データを読み込む**:
   - バックアップディレクトリを復元
   - アプリケーションを起動

3. **全ての既存クエリが一覧に表示されることを確認**

4. **各クエリを読み込んで正常に動作することを確認**

5. **各クエリを実行して結果が表示されることを確認**

**期待結果**:
- [ ] 全ての既存クエリが一覧に表示される
- [ ] 全ての既存クエリが正常に読み込まれる
- [ ] 全ての既存クエリが正常に実行される
- [ ] データ損失がない
- [ ] エラーが発生しない

---

## 6. 非機能要件テスト

### 6.1 パフォーマンステスト

**目的**: 型定義の変更によるパフォーマンス劣化がないことを確認

**手順**:

1. **大量のクエリ（100件以上）を用意**

2. **保存クエリSlideoverを開く**

3. **一覧表示の速度を計測**:
   - Chrome DevToolsのパフォーマンスプロファイラーを使用
   - 表示にかかる時間を測定

4. **Phase1実装前後で比較**

**期待結果**:
- [ ] 一覧表示の速度が Phase1実装前と同等である（±10%以内）
- [ ] メモリ使用量が Phase1実装前と同等である（±10%以内）

---

## 7. テスト完了チェックリスト

### 7.1 自動テスト

- [ ] TypeScriptバリデーション関数のテストが全て成功
- [ ] Rustバリデーション関数のテストが全て成功
- [ ] TypeScript型チェックが成功
- [ ] Nuxtビルドが成功
- [ ] Rustビルドが成功
- [ ] Tauriアプリビルドが成功

### 7.2 手動テスト

- [ ] 既存クエリの読み込み確認が成功
- [ ] 新規クエリの保存確認が成功
- [ ] 保存したクエリの再読み込み確認が成功
- [ ] 既存クエリの上書き保存確認が成功
- [ ] 検索機能の確認が成功

### 7.3 統合テスト

- [ ] 型定義とシリアライズ/デシリアライズのテストが成功
- [ ] エラーハンドリングの確認が成功

### 7.4 後方互換性テスト

- [ ] 既存データの完全性確認が成功

### 7.5 非機能要件テスト

- [ ] パフォーマンステストが成功

---

## 8. テスト結果レポート

**テスト実施日**: YYYY-MM-DD

### 8.1 自動テスト結果

| テスト項目 | 結果 | 備考 |
|----------|------|------|
| TypeScriptバリデーション関数 | ✅ / ❌ | |
| Rustバリデーション関数 | ✅ / ❌ | |
| TypeScript型チェック | ✅ / ❌ | |
| Nuxtビルド | ✅ / ❌ | |
| Rustビルド | ✅ / ❌ | |
| Tauriアプリビルド | ✅ / ❌ | |

### 8.2 手動テスト結果

| テスト項目 | 結果 | 備考 |
|----------|------|------|
| 既存クエリの読み込み | ✅ / ❌ | |
| 新規クエリの保存 | ✅ / ❌ | |
| 保存クエリの再読み込み | ✅ / ❌ | |
| 既存クエリの上書き保存 | ✅ / ❌ | |
| 検索機能 | ✅ / ❌ | |

### 8.3 統合テスト結果

| テスト項目 | 結果 | 備考 |
|----------|------|------|
| Tauri IPC動作確認 | ✅ / ❌ | |
| エラーハンドリング | ✅ / ❌ | |

### 8.4 後方互換性テスト結果

| テスト項目 | 結果 | 備考 |
|----------|------|------|
| 既存データの完全性 | ✅ / ❌ | |

### 8.5 非機能要件テスト結果

| テスト項目 | 結果 | 備考 |
|----------|------|------|
| パフォーマンス | ✅ / ❌ | |

### 8.6 総合評価

- **合格** / **不合格**

**不合格の場合の対応**:
- 問題の特定と修正
- 再テストの実施

---

## 9. 既知の問題

Phase1テスト時に発見された問題をここに記載します。

| 問題ID | 問題内容 | 影響度 | 対応状況 |
|--------|---------|--------|---------|
| - | - | - | - |

---

## 変更履歴

| 日付 | バージョン | 変更内容 | 作成者 |
|------|----------|---------|--------|
| 2026-01-24 | 1.0 | 初版作成 | - |
