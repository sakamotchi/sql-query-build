# 要件定義書: 6C - JOIN設定インテリジェント機能

**作成日**: 2025-12-31
**対象フェーズ**: Phase 6C
**依存**: Phase 6A（基本的なJOIN機能）完了
**優先度**: 低

---

## 1. 概要

データベースの外部キー情報を活用して、適切なJOIN条件を自動提案する機能を実装する。
ユーザーがテーブル間のJOIN設定を手動で行う手間を大幅に削減し、正確なJOIN条件を簡単に設定できるようにする。

---

## 2. 背景・目的

### 現状の課題
- Phase 6A完了後は、ユーザーが手動でJOIN条件（ON句）を設定する必要がある
- テーブル間の関連を理解していない場合、適切なJOINキーを選択するのが困難
- 複数テーブル間の最適なJOINパスを見つけるのに時間がかかる
- 外部キー制約の情報がGUIに活用されていない

### 目的
- データベースの外部キー制約から自動的にJOIN候補を提案
- ワンクリックで提案されたJOIN条件を適用可能に
- 複数テーブル間の最適なJOINパスを自動計算
- JOIN設定の学習コストを削減し、初心者でも正確なクエリを構築可能に

---

## 3. 機能要件

### 3.1 外部キー情報取得（バックエンド）

**FR-6C-001**: データベーススキーマから外部キー制約を取得できること
- PostgreSQL: `information_schema.table_constraints` / `information_schema.key_column_usage`
- MySQL: `information_schema.key_column_usage` / `information_schema.referential_constraints`
- SQLite: `PRAGMA foreign_key_list(table_name)`

**FR-6C-002**: 外部キー情報を以下の形式で返却すること
```rust
pub struct ForeignKeyConstraint {
    pub constraint_name: String,
    pub from_schema: String,
    pub from_table: String,
    pub from_column: String,
    pub to_schema: String,
    pub to_table: String,
    pub to_column: String,
}
```

**FR-6C-003**: 既存の`get_database_structure`コマンドまたは新規コマンドで外部キー情報を取得可能にすること

### 3.2 JOIN提案エンジン（バックエンド）

**FR-6C-004**: 選択されたテーブル間のJOIN候補を計算する提案エンジンを実装すること

**FR-6C-005**: 提案エンジンは以下の情報を基に候補を生成すること
- 外部キー制約（最優先）
- カラム名の一致（例: `user_id` ↔ `id`）
- データ型の一致

**FR-6C-006**: 提案結果は以下の形式で返却すること
```rust
pub struct JoinSuggestion {
    pub from_table: String,
    pub to_table: String,
    pub join_type: String, // "INNER JOIN", "LEFT JOIN"など
    pub conditions: Vec<JoinCondition>,
    pub confidence: f32, // 0.0〜1.0（外部キー=1.0、名前一致=0.7など）
    pub reason: String, // "外部キー制約に基づく", "カラム名の類似性"など
}

pub struct JoinCondition {
    pub left_column: String,
    pub operator: String, // "="
    pub right_column: String,
}
```

**FR-6C-007**: 複数テーブル間のJOINパスを計算できること
- 例: テーブルA, B, Cが選択された場合、A→B→Cの経路を提案

### 3.3 提案UI（フロントエンド）

**FR-6C-008**: JoinConfigDialogに「おすすめのJOIN条件」セクションを追加すること

**FR-6C-009**: 提案は信頼度（confidence）順にリスト表示すること

**FR-6C-010**: 各提案には以下を表示すること
- JOIN種別（INNER/LEFT/RIGHT/FULL OUTER）
- ON条件（`table1.column1 = table2.column2`）
- 信頼度インジケーター（★★★☆☆など）
- 理由（「外部キー制約に基づく」など）

**FR-6C-011**: 提案をクリックするとJOIN条件が自動設定されること

**FR-6C-012**: ユーザーが提案を採用後、手動で編集可能であること

### 3.4 スマートJOIN追加機能

**FR-6C-013**: JoinPanel（JOIN一覧）に「スマートJOIN追加」ボタンを設置すること

**FR-6C-014**: ボタンクリック時、現在選択されているテーブル間の最適なJOINを自動提案すること

**FR-6C-015**: 提案が複数ある場合、選択ダイアログを表示すること

---

## 4. 非機能要件

### 4.1 パフォーマンス

**NFR-6C-001**: 外部キー情報の取得は5秒以内に完了すること

**NFR-6C-002**: JOIN提案の計算は1秒以内に完了すること（10テーブル以下の場合）

**NFR-6C-003**: 大量テーブル（100以上）でもメモリ使用量が適切な範囲に収まること

### 4.2 ユーザビリティ

**NFR-6C-004**: 提案UIは直感的で、初心者でも理解できる説明を表示すること

**NFR-6C-005**: 提案の理由を明示し、ユーザーが判断材料にできること

**NFR-6C-006**: 提案がない場合でもユーザーフレンドリーなメッセージを表示すること

### 4.3 拡張性

**NFR-6C-007**: 将来的に機械学習ベースの提案に拡張可能な設計とすること

**NFR-6C-008**: カスタム提案ルールを設定ファイルで追加可能にすること（将来拡張）

### 4.4 エラーハンドリング

**NFR-6C-009**: データベース接続エラー時にもアプリがクラッシュしないこと

**NFR-6C-010**: 権限エラー時は適切なフォールバック（カラム名ベースの提案）を提供すること

**NFR-6C-011**: タイムアウト時は部分的な結果でも提供すること

**NFR-6C-012**: エラーメッセージは技術者でなくても理解できる内容であること

---

## 5. 制約事項

**CON-6C-001**: SQLiteでは外部キー情報が不完全な場合があるため、カラム名ベースの提案も実装すること

**CON-6C-002**: 外部キー制約が設定されていないレガシーDBにも対応すること

**CON-6C-003**: Phase 6A完了が前提（JoinConfigDialogが実装済み）

**CON-6C-004**: `information_schema`へのアクセス権限がない場合はカラム名ベースの提案のみ提供

**CON-6C-005**: 複雑な外部キー関係（循環参照など）は提案の精度が低下する可能性がある

---

## 6. 成功基準

**SC-6C-001**: 外部キー制約からJOIN条件が自動提案される

**SC-6C-002**: 提案をワンクリックで適用できる

**SC-6C-003**: 複数テーブル間の最適なJOINパスを提案できる

**SC-6C-004**: SQLite、PostgreSQL、MySQLすべてで提案機能が動作する

**SC-6C-005**: ユーザーテストで「JOIN設定が簡単になった」という評価を得る

---

## 7. ユースケース

### UC-6C-001: 外部キー制約に基づく自動提案

**アクター**: SQLエンジニア

**前提条件**:
- データベースに外部キー制約が設定されている
- usersテーブルとordersテーブルが選択されている

**基本フロー**:
1. ユーザーが「JOIN追加」ボタンをクリック
2. JoinConfigDialogが開く
3. 「おすすめのJOIN条件」セクションに以下が表示される
   - 「LEFT JOIN orders ON users.id = orders.user_id」（★★★★★）
   - 理由: 「外部キー制約 'fk_orders_user_id' に基づく」
4. ユーザーが提案をクリック
5. JOIN条件が自動設定される
6. ユーザーが「保存」をクリック
7. JOINが追加される

### UC-6C-002: 複数テーブルのJOINパス提案

**アクター**: データアナリスト

**前提条件**:
- users、orders、order_itemsテーブルが選択されている

**基本フロー**:
1. ユーザーが「スマートJOIN追加」ボタンをクリック
2. システムがJOINパスを計算
3. 提案ダイアログが表示
   - 「users → orders → order_items」（推奨）
   - 「users → orders」、「orders → order_items」（個別）
4. ユーザーが「推奨パスを適用」をクリック
5. 2つのJOINが自動追加される

### UC-6C-003: カラム名ベースの提案（外部キーなし）

**アクター**: SQLエンジニア

**前提条件**:
- レガシーDBで外部キー制約が未設定
- customer_idというカラムが両テーブルに存在

**基本フロー**:
1. ユーザーが「JOIN追加」ボタンをクリック
2. JoinConfigDialogが開く
3. 「おすすめのJOIN条件」セクションに以下が表示される
   - 「INNER JOIN table2 ON table1.customer_id = table2.customer_id」（★★★☆☆）
   - 理由: 「カラム名の一致」
4. ユーザーが提案を確認し、採用を判断

### UC-6C-004: エラー時のフォールバック

**アクター**: SQLエンジニア

**前提条件**:
- データベース接続が不安定、または権限が不足

**基本フロー**:
1. ユーザーが「JOIN追加」ボタンをクリック
2. JoinConfigDialogが開く
3. バックグラウンドで外部キー情報の取得を試みる
4. エラーが発生（権限エラー、タイムアウトなど）

**代替フロー**:
5a. 外部キー取得に失敗した場合
   - エラーメッセージが表示される（「提案の取得に一部失敗しました」）
   - カラム名ベースの提案のみ表示される
   - ユーザーは手動でJOIN条件を設定できる

5b. 完全にエラーの場合
   - 「提案が利用できません。手動で条件を設定してください。」と表示される
   - 手動設定UIは正常に動作する

**完了状態**: ユーザーはエラーがあってもJOIN設定を完了できる

---

## 8. 画面イメージ

### 8.1 JoinConfigDialog - おすすめのJOIN条件セクション

```
┌─ JOIN設定 ──────────────────────────────────────┐
│ JOINタイプ: [INNER JOIN ▼]                     │
│ テーブル:   [orders            ▼]              │
│                                                  │
│ ┌─ おすすめのJOIN条件 ────────────────────┐   │
│ │ ★★★★★ 外部キー制約に基づく              │   │
│ │ users.id = orders.user_id                │   │
│ │ [この条件を適用]                          │   │
│ │                                           │   │
│ │ ★★★☆☆ カラム名の一致                    │   │
│ │ users.email = orders.customer_email      │   │
│ │ [この条件を適用]                          │   │
│ └───────────────────────────────────────────┘   │
│                                                  │
│ ON条件:                                         │
│ ┌─────────────────────────────────────────┐   │
│ │ users.id = orders.user_id                │   │
│ └─────────────────────────────────────────┘   │
│                                                  │
│              [キャンセル]  [保存]               │
└──────────────────────────────────────────────────┘
```

### 8.2 JoinPanel - スマートJOIN追加ボタン

```
┌─ JOIN ──────────────────────────────────────────┐
│ [+ JOIN追加] [🔮 スマートJOIN追加]              │
│                                                  │
│ ┌─────────────────────────────────────────┐   │
│ │ INNER JOIN orders                        │   │
│ │   ON users.id = orders.user_id           │   │
│ │                               [編集][削除]│   │
│ └─────────────────────────────────────────┘   │
└──────────────────────────────────────────────────┘
```

---

## 9. 将来的な拡張（スコープ外）

- 機械学習ベースのJOIN提案（過去のクエリパターンから学習）
- ユーザーフィードバックによる提案精度の向上
- 外部データソース（ドキュメント、ER図）からの情報取得
- JOIN性能の予測（インデックスの有無、テーブルサイズ考慮）

---

## 10. 参考資料

- PostgreSQL外部キー情報取得: https://www.postgresql.org/docs/current/infoschema-table-constraints.html
- MySQL外部キー情報取得: https://dev.mysql.com/doc/refman/8.0/en/information-schema-key-column-usage-table.html
- SQLite外部キー情報取得: https://www.sqlite.org/pragma.html#pragma_foreign_key_list
