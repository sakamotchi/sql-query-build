# テスト手順書 - 保存クエリの接続非依存化

**作成日**: 2026-02-01
**要件名**: saved-query-connection-independence
**親ドキュメント**: [requirements.md](./requirements.md) | [design.md](./design.md) | [tasklist.md](./tasklist.md)

---

## 概要

このドキュメントでは、保存クエリの接続非依存化機能のテスト手順を記載します。
可能な限り手動操作で確認し、操作で確認できない項目のみ自動テストを記載します。

---

## 前提条件

### テスト環境

- `npm run tauri:dev` でアプリが起動していること
- PostgreSQL/MySQL/SQLite のいずれかのデータベース接続が2つ以上登録されていること
  - 推奨: 開発環境と本番環境（または異なる2つの接続）

### テストデータ準備

**既存の保存クエリ（下位互換性確認用）**:
- 接続IDが設定されている保存クエリが1件以上存在すること
- または、テスト前に手動で作成すること

**データベース**:
- 少なくとも1つのテーブル（例: `users` テーブル）が存在すること

---

## 手動テスト

### ケース 1: 新規クエリ保存（SQLエディタ）

**目的**: SQLエディタで新規クエリを保存すると、`connectionId: null` で保存されることを確認

**手順**:

1. アプリを起動する
2. ランチャーから任意の接続（例: 開発環境）を開く
3. SQLエディタ画面で簡単なクエリを入力（例: `SELECT * FROM users LIMIT 10`）
4. ツールバーの「保存」ボタンをクリック
5. 保存ダイアログが表示される
6. **重要**: 接続選択フィールドが表示されないことを確認
7. 以下を入力:
   - クエリ名: `Test Query - Connection Independent`
   - 説明: `接続非依存テスト用クエリ`
   - タグ: `test`
   - フォルダ: `/テスト` (新規作成)
8. 「保存」ボタンをクリック

**期待結果**:

- 保存ダイアログに接続選択フィールドが表示されない
- クエリが正常に保存される
- 保存後、保存クエリパネルに新しいクエリが表示される
- 保存されたクエリの `connectionId` が `null` であること（JSONファイルで確認）

**確認結果**:

- [ ] OK / NG

**備考**:
- JSONファイルの確認方法: `~/.sql-query-build/sql-editor-queries/{クエリID}.json` を開き、`"connectionId": null` となっているか確認

---

### ケース 2: 保存クエリ一覧表示（SQLエディタ）

**目的**: すべての接続で同じ保存クエリ一覧が表示されることを確認

**手順**:

1. アプリを起動する
2. ランチャーから接続A（例: 開発環境）を開く
3. SQLエディタ画面の左側にある「保存済み」パネルを開く
4. 表示されている保存クエリの一覧をメモする（件数とクエリ名）
5. SQLエディタを閉じる
6. ランチャーから接続B（例: 本番環境）を開く
7. SQLエディタ画面の「保存済み」パネルを開く
8. 表示されている保存クエリの一覧を確認する

**期待結果**:

- 接続Aと接続Bで表示される保存クエリ一覧が同じであること
- フォルダで整理されている場合、フォルダ構造も同じであること
- ケース1で保存したクエリも両方の接続で表示されること

**確認結果**:

- [ ] OK / NG

---

### ケース 3: 異なる接続でのクエリ実行（SQLエディタ）

**目的**: 環境間でクエリを再利用できることを確認

**手順**:

1. アプリを起動する
2. ランチャーから接続A（例: 開発環境）を開く
3. SQLエディタ画面で以下のクエリを入力:
   ```sql
   SELECT COUNT(*) FROM users
   ```
4. ツールバーの「保存」ボタンをクリックし、以下を入力:
   - クエリ名: `ユーザー数カウント`
   - フォルダ: `/共通クエリ`
5. 保存する
6. 実行ボタンをクリックして結果を確認（例: 10件）
7. SQLエディタを閉じる
8. ランチャーから接続B（例: 本番環境）を開く
9. SQLエディタ画面の「保存済み」パネルを開く
10. `/共通クエリ/ユーザー数カウント` を選択
11. クエリがエディタに読み込まれることを確認
12. 実行ボタンをクリック

**期待結果**:

- 接続Bでも同じクエリが読み込まれること
- 接続B（本番環境）のデータベースに対してクエリが実行されること
- 結果が表示されること（接続Bのデータベースの件数が表示される）
- エラーが発生しないこと

**確認結果**:

- [ ] OK / NG

**備考**:
- 接続Aと接続Bで同じスキーマ（`users` テーブル）が存在することを前提としています

---

### ケース 4: 下位互換性（既存クエリの表示）

**目的**: 既存の保存クエリ（`connectionId` が設定されているもの）が引き続き表示されることを確認

**手順**:

1. テスト前に、`connectionId` が設定されている保存クエリが存在することを確認
   - 存在しない場合は、手動でJSONファイルを作成するか、旧バージョンで保存する
2. アプリを起動する
3. ランチャーから任意の接続を開く
4. SQLエディタ画面の「保存済み」パネルを開く
5. 既存の保存クエリが一覧に表示されることを確認

**期待結果**:

- `connectionId` が設定されている既存クエリも一覧に表示されること
- 既存クエリを選択して読み込めること
- 既存クエリを実行できること

**確認結果**:

- [ ] OK / NG

---

### ケース 5: クエリ編集・再保存

**目的**: 既存クエリを編集して再保存すると、`connectionId: null` で上書き保存されることを確認

**手順**:

1. アプリを起動する
2. ランチャーから任意の接続を開く
3. SQLエディタ画面で既存の保存クエリを読み込む
4. クエリを少し編集する（例: `LIMIT 10` を `LIMIT 20` に変更）
5. ツールバーの「保存」ボタンをクリック
6. 保存ダイアログで「上書き保存」を選択（または同じクエリ名で保存）
7. 保存する

**期待結果**:

- クエリが正常に保存される
- 保存後、JSONファイルを確認すると `"connectionId": null` になっていること

**確認結果**:

- [ ] OK / NG

---

### ケース 6: 新規クエリ保存（クエリビルダー）

**目的**: クエリビルダーで新規クエリを保存すると、`connectionId: null` で保存されることを確認

**手順**:

1. アプリを起動する
2. ランチャーから任意の接続を開く
3. クエリビルダー画面を開く
4. 簡単なクエリを構築（例: `users` テーブルを選択し、いくつかのカラムを選択）
5. ツールバーの「保存」ボタンをクリック
6. 保存ダイアログが表示される
7. **重要**: 接続選択フィールドが表示されないことを確認（既に対応済みか確認）
8. 以下を入力:
   - クエリ名: `Test Query Builder - Connection Independent`
   - 説明: `クエリビルダーテスト用`
   - タグ: `test`
9. 「保存」ボタンをクリック

**期待結果**:

- 保存ダイアログに接続選択フィールドが表示されない
- クエリが正常に保存される
- 保存されたクエリの `connectionId` が `null` であること（JSONファイルで確認）

**確認結果**:

- [ ] OK / NG

**備考**:
- JSONファイルの確認方法: `~/.sql-query-build/saved-queries/{クエリID}.json` を開き、`"connectionId": null` となっているか確認

---

### ケース 7: 保存クエリ一覧表示（クエリビルダー）

**目的**: クエリビルダーでもすべての接続で同じ保存クエリ一覧が表示されることを確認

**手順**:

1. アプリを起動する
2. ランチャーから接続Aを開く
3. クエリビルダー画面を開く
4. 保存済みクエリスライドオーバーを開く
5. 表示されている保存クエリの一覧をメモする
6. クエリビルダーを閉じる
7. ランチャーから接続Bを開く
8. クエリビルダー画面を開く
9. 保存済みクエリスライドオーバーを開く
10. 表示されている保存クエリの一覧を確認する

**期待結果**:

- 接続Aと接続Bで表示される保存クエリ一覧が同じであること
- ケース6で保存したクエリも両方の接続で表示されること

**確認結果**:

- [ ] OK / NG

---

### ケース 8: フォルダ管理との統合

**目的**: フォルダ管理機能と保存クエリの接続非依存化が正しく統合されていることを確認

**手順**:

1. アプリを起動する
2. ランチャーから接続Aを開く
3. SQLエディタ画面の「保存済み」パネルを開く
4. 新しいフォルダを作成（例: `/環境共通/分析用`）
5. 新しいクエリを作成し、上記フォルダに保存
6. SQLエディタを閉じる
7. ランチャーから接続Bを開く
8. SQLエディタ画面の「保存済み」パネルを開く
9. フォルダツリーを確認

**期待結果**:

- 接続Bでも同じフォルダ構造が表示されること
- 接続Aで作成したフォルダ（`/環境共通/分析用`）が表示されること
- そのフォルダ内に保存したクエリが表示されること

**確認結果**:

- [ ] OK / NG

---

## 自動テスト

### ユニットテスト（フロントエンド）

**実行コマンド**:
```bash
npm run test:run
```

**対象ファイル**:
- `tests/stores/sql-editor.spec.ts`
- `tests/stores/saved-query.spec.ts`

**確認項目**:
- [ ] `useSqlEditorStore.loadSavedQueries()` が接続IDを渡さずに呼び出される
- [ ] `useSqlEditorStore.saveQuery()` が `connectionId: null` で保存する
- [ ] `useSavedQueryStore.fetchQueries()` が接続IDでフィルタしない
- [ ] 既存のテストがすべてパスする

---

### ユニットテスト（バックエンド）

**実行コマンド**:
```bash
cd src-tauri && cargo test
```

**対象ファイル**:
- `src-tauri/src/commands/sql_editor.rs`
- `src-tauri/src/commands/query_storage_commands.rs`

**確認項目**:
- [ ] `validate_save_request()` が `connectionId` なしでバリデーションをパスする
- [ ] `list_sql_queries()` が接続IDでフィルタしない
- [ ] 既存のテストがすべてパスする

---

### 型チェック

**実行コマンド**:
```bash
npm run typecheck
```

**確認項目**:
- [ ] TypeScriptの型エラーがない
- [ ] `connectionId: string | null` の型定義が正しく使用されている

---

## エッジケース

| ケース | 期待動作 | 確認結果 |
|--------|---------|---------|
| 保存クエリが0件の場合 | 「保存されたクエリがありません」と表示される | [ ] OK / NG |
| フォルダが空の場合 | 空のフォルダも表示される | [ ] OK / NG |
| 大量の保存クエリ（100件以上） | パフォーマンスに問題がない | [ ] OK / NG |
| 接続が1つしかない場合 | 正常に動作する | [ ] OK / NG |
| クエリ名に特殊文字が含まれる | 正常に保存・表示される | [ ] OK / NG |
| フォルダパスに日本語が含まれる | 正常に動作する | [ ] OK / NG |

---

## 回帰テスト

既存機能への影響がないことを確認します。

### SQLエディタ関連

- [ ] クエリ履歴機能が正常に動作する（接続ごとに管理される）
- [ ] クエリ実行機能が正常に動作する
- [ ] クエリフォーマット機能が正常に動作する
- [ ] エクスポート機能が正常に動作する

### クエリビルダー関連

- [ ] クエリ構築機能が正常に動作する
- [ ] JOIN提案機能が正常に動作する
- [ ] SQL生成機能が正常に動作する
- [ ] 危険クエリ検出機能が正常に動作する

### 接続管理関連

- [ ] 接続の追加・編集・削除が正常に動作する
- [ ] 接続テストが正常に動作する
- [ ] マルチウィンドウ機能が正常に動作する

### フォルダ管理関連

- [ ] フォルダの作成・名前変更・削除が正常に動作する
- [ ] ドラッグ&ドロップでのクエリ移動が正常に動作する
- [ ] フォルダの展開/折りたたみ状態が保存される

---

## パフォーマンステスト

### 大量データでの動作確認

**手順**:

1. 保存クエリを100件以上作成（スクリプトで自動生成推奨）
2. アプリを起動する
3. SQLエディタを開く
4. 保存クエリパネルを開く
5. 一覧の読み込み速度を確認
6. フォルダの展開/折りたたみの動作を確認
7. 検索機能の動作を確認

**期待結果**:

- 一覧の読み込みが1秒以内に完了すること
- フォルダの展開/折りたたみが瞬時に完了すること
- 検索結果が0.5秒以内に表示されること

**確認結果**:

- [ ] OK / NG

**備考**:
- パフォーマンスに問題がある場合は、仮想スクロールやページネーションの導入を検討

---

## テスト完了条件

- [ ] すべての手動テストケース（ケース1〜8）がパス
- [ ] すべてのエッジケースがパス
- [ ] すべての回帰テストがパス
- [ ] すべての自動テスト（ユニットテスト、型チェック）がパス
- [ ] パフォーマンステストがパス（または問題が特定され、対応方針が決定している）

---

## テスト実施記録

| 実施日 | 実施者 | 結果 | 備考 |
|--------|--------|------|------|
| | | | |

---

## 不具合・改善点

テスト中に発見された不具合や改善点を記録します。

| 発見日 | 内容 | 重要度 | 対応状況 | 備考 |
|--------|------|--------|---------|------|
| | | | | |

---

## 参考資料

- [requirements.md](./requirements.md) - 要件定義書
- [design.md](./design.md) - 設計書
- [tasklist.md](./tasklist.md) - タスクリスト
- [docs/steering/02_functional_design.md](../../steering/02_functional_design.md) - 機能設計書
