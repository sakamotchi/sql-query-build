# テスト手順書 - データベース構造の段階的取得（パフォーマンス改善）

**作成日**: 2026-02-07
**最終更新**: 2026-02-07

---

## 1. テスト環境

### 測定環境

| 項目 | 内容 |
|-----|------|
| OS | macOS（開発環境） |
| 測定ツール | Chrome DevTools Performance / Console（`performance.now()`）/ Rust ログ |

### テストデータ

- **PostgreSQL**: 100テーブル以上のスキーマを持つデータベース
- **MySQL**: 100テーブル以上のスキーマを持つデータベース
- **SQLite**: 100テーブル以上のテーブルを持つファイル

---

## 2. ベンチマーク測定手順

### TC-B-001: Before測定（改善前）

**目的**: 現在のデータベース構造取得パフォーマンスを測定する

**手順**:

1. `npm run tauri:dev` でアプリケーションを起動
2. Chrome DevTools を開く（Cmd + Option + I）
3. Console タブを選択
4. テスト対象のデータベースに接続する
5. SQLエディタ画面を開く
6. Console に表示されるログを確認:
   - `[SqlEditor] Database structure loaded for connection: xxx`
7. 以下の値を記録:
   - 接続確立からログ表示までの経過時間: `______` ms

**各DB種別で測定**:

| DB種別 | テーブル数 | 全構造取得時間 | 補完利用可能時間 | 備考 |
|--------|----------|-------------|----------------|------|
| PostgreSQL | _______ | _______ ms | _______ ms | |
| MySQL | _______ | _______ ms | _______ ms | |
| SQLite | _______ | _______ ms | _______ ms | |

---

## 3. 最適化実装後の検証

### TC-P-001: テーブル名補完の高速化測定（After）

**目的**: Phase 1（テーブル名一覧の軽量取得）後にテーブル名補完が利用可能になるまでの時間を測定する

**前提条件**: Phase 1（バックエンド実装）およびPhase 2（フロントエンド実装）が完了していること

**手順**:

1. `npm run tauri:dev` でアプリケーションを起動
2. テスト対象のデータベースに接続する
3. SQLエディタ画面を開く
4. Console に表示されるログを確認:
   - `[SqlEditor] Database structure summary loaded` （Phase 1完了）
5. SQLエディタに `SELECT * FROM ` と入力
6. テーブル名の補完候補が表示されることを確認
7. 接続確立からテーブル名補完が利用可能になるまでの経過時間を記録

**期待値**:
- テーブル名補完利用可能時間: 2秒以内（100テーブル規模）

**結果**:

| DB種別 | テーブル数 | サマリー取得時間 | 補完利用可能時間 | Before | 改善率 | 達成状況 |
|--------|----------|---------------|----------------|--------|--------|---------|
| PostgreSQL | _______ | _______ ms | _______ ms | _______ ms | _______ % | ☐ 達成 / ☐ 未達成 |
| MySQL | _______ | _______ ms | _______ ms | _______ ms | _______ % | ☐ 達成 / ☐ 未達成 |
| SQLite | _______ | _______ ms | _______ ms | _______ ms | _______ % | ☐ 達成 / ☐ 未達成 |

---

### TC-P-002: MySQL全構造取得の高速化測定

**目的**: MySQLバッチクエリ化による全構造取得時間の改善を測定する

**前提条件**: MySQLバッチクエリ化（T-8〜T-12）が完了していること

**手順**:

1. `npm run tauri:dev` でアプリケーションを起動
2. MySQL データベースに接続する
3. クエリビルダー画面を開く（全構造取得が実行される）
4. Console ログから `get_database_structure` の所要時間を記録

**期待値**:
- 100テーブル規模で5秒以内（現状20-60秒から80%以上の改善）

**結果**:

| テーブル数 | Before | After | 改善率 | 達成状況 |
|----------|--------|-------|--------|---------|
| _______ | _______ ms | _______ ms | _______ % | ☐ 達成 / ☐ 未達成 |

---

### TC-P-003: オンデマンドカラム取得の測定

**目的**: `.` 入力時のカラム補完のオンデマンド取得速度を測定する

**前提条件**: オンデマンドカラム取得（T-17）が完了していること

**手順**:

1. `npm run tauri:dev` でアプリケーションを起動
2. テスト対象のデータベースに接続する
3. SQLエディタ画面を開く
4. テーブル名補完が利用可能になるまで待つ（Phase 1完了）
5. バックグラウンド取得が完了していないテーブルを特定
6. SQLエディタに `SELECT テーブル名.` と入力
7. カラム補完候補が表示されるまでの時間を記録

**期待値**:
- 1テーブルあたり500ms以内

**結果**:

| DB種別 | テーブル名 | カラム数 | 取得時間 | 達成状況 |
|--------|----------|---------|---------|---------|
| PostgreSQL | _______ | _______ | _______ ms | ☐ 達成 / ☐ 未達成 |
| MySQL | _______ | _______ | _______ ms | ☐ 達成 / ☐ 未達成 |
| SQLite | _______ | _______ | _______ ms | ☐ 達成 / ☐ 未達成 |

---

## 4. バックグラウンド取得の検証

### TC-BG-001: バックグラウンド取得の動作確認

**目的**: Phase 1完了後にバックグラウンドでカラム情報が順次取得されることを確認する

**手順**:

1. `npm run tauri:dev` でアプリケーションを起動
2. テスト対象のデータベースに接続する
3. SQLエディタ画面を開く
4. UI上のバックグラウンド取得進捗表示を確認
5. 進捗が "0/N tables loaded" から始まり、徐々に増加することを確認
6. 全テーブルの取得が完了するまでUIがフリーズしないことを確認
7. 取得完了後にすべてのテーブルのカラム補完が利用可能であることを確認

**期待値**:
- バックグラウンド取得中もUIは操作可能
- 進捗表示が正しく更新される
- 取得完了後にすべてのカラム補完が利用可能

**結果**: ☐ 合格 / ☐ 不合格

---

### TC-BG-002: オンデマンド取得の優先処理

**目的**: ユーザーが `.` を入力した場合、該当テーブルが優先的に取得されることを確認する

**手順**:

1. SQLエディタ画面を開く（バックグラウンド取得がまだ進行中の状態）
2. まだバックグラウンド取得されていないテーブルを選択
3. `SELECT テーブル名.` と入力
4. カラム補完候補が表示されることを確認（バックグラウンド取得の順番に関係なく）
5. ローディング状態が表示されてからカラム候補に切り替わることを確認

**期待値**:
- オンデマンド要求されたテーブルがバックグラウンドキューの待ちに関係なく取得される
- ローディング → カラム候補の遷移がスムーズ

**結果**: ☐ 合格 / ☐ 不合格

---

## 5. 機能回帰テスト

### TC-R-001: SQLエディタの補完機能

**目的**: 既存の補完機能が壊れていないことを確認する

**手順**:

1. ☐ テーブル名補完が正常に動作する（`SELECT * FROM ` の後に候補が表示）
2. ☐ カラム名補完が正常に動作する（`テーブル名.` の後にカラム候補が表示）
3. ☐ エイリアス補完が正常に動作する（`SELECT t.` でエイリアスのカラム候補が表示）
4. ☐ SQLキーワード補完が正常に動作する
5. ☐ スキーマ修飾名での補完が正常に動作する（`schema.table` 形式）
6. ☐ テーブルコメント・推定行数が補完候補のdetailに表示される

**期待値**: すべての補完機能が正常に動作する

**結果**: ☐ 合格 / ☐ 不合格

---

### TC-R-002: クエリビルダーの動作確認

**目的**: クエリビルダー画面が正常に動作することを確認する

**手順**:

1. ☐ クエリビルダー画面のDatabaseTreeにテーブル一覧が表示される
2. ☐ テーブルをドラッグ&ドロップでテーブル関係エリアに追加できる
3. ☐ テーブルのカラム一覧が表示される
4. ☐ SELECT句でカラムを選択できる
5. ☐ WHERE句で条件を設定できる
6. ☐ SQLプレビューが正しく生成される

**期待値**: すべての機能が正常に動作する

**結果**: ☐ 合格 / ☐ 不合格

---

### TC-R-003: ミューテーションビルダーの動作確認

**目的**: ミューテーションビルダー画面が正常に動作することを確認する

**手順**:

1. ☐ TableSelectorにテーブル一覧が表示される
2. ☐ テーブルを選択するとカラム情報が表示される
3. ☐ INSERT/UPDATE/DELETEの各操作が正常に動作する

**期待値**: すべての機能が正常に動作する

**結果**: ☐ 合格 / ☐ 不合格

---

## 6. エラー耐性テスト

### TC-E-001: Phase 1取得失敗時の動作

**目的**: テーブル名一覧の取得が失敗してもエディタが利用可能であることを確認する

**手順**:

1. 接続情報を不正な状態にする（例: パスワードを間違える）
2. SQLエディタ画面を開く
3. エラーが表示されることを確認
4. SQLエディタ自体は操作可能であることを確認（補完は無効だがテキスト入力は可能）

**期待値**: エディタの基本機能は利用可能

**結果**: ☐ 合格 / ☐ 不合格

---

### TC-E-002: バックグラウンド取得の一部失敗時の動作

**目的**: バックグラウンド取得の一部が失敗しても取得済みデータが利用可能であることを確認する

**手順**:

1. テスト対象のデータベースに接続する
2. SQLエディタ画面を開く
3. バックグラウンド取得中にネットワーク断が発生したことを想定
4. 取得済みテーブルのカラム補完が利用可能であることを確認
5. エラーメッセージが表示されることを確認

**期待値**: 取得済みデータは利用可能、エラーが適切に表示される

**結果**: ☐ 合格 / ☐ 不合格

---

## 7. ローディングUI検証

### TC-UI-001: ローディング状態の表示

**目的**: データベース構造の取得状況がUI上に正しく表示されることを確認する

**手順**:

1. ☐ Phase 1取得中にローディングインジケーターが表示される
2. ☐ Phase 1完了後にテーブル名補完が利用可能になる
3. ☐ バックグラウンド取得の進捗（例: "30/100 tables loaded"）が表示される
4. ☐ すべての取得が完了すると進捗表示が消える
5. ☐ エラー時にエラー状態が表示される

**期待値**: すべてのローディング状態が正しく表示される

**結果**: ☐ 合格 / ☐ 不合格

---

## 8. 自動ベンチマークテスト

### ユニットテスト: パフォーマンス基準

```typescript
import { describe, it, expect } from 'vitest'

describe('Database Structure Store - Progressive Loading', () => {
  it('should set summary data after fetchDatabaseStructureSummary', async () => {
    const store = useDatabaseStructureStore()
    await store.fetchDatabaseStructureSummary('test-connection')
    expect(store.summaries['test-connection']).toBeDefined()
    expect(store.summaries['test-connection'].schemas.length).toBeGreaterThan(0)
  })

  it('should cache columns after fetchColumnsForTable', async () => {
    const store = useDatabaseStructureStore()
    await store.fetchColumnsForTable('test-connection', 'public', 'users')
    expect(store.columnCache['test-connection']['public.users']).toBeDefined()
    expect(store.columnCache['test-connection']['public.users'].length).toBeGreaterThan(0)
  })

  it('should not re-fetch already cached columns', async () => {
    const store = useDatabaseStructureStore()
    // 1回目
    await store.fetchColumnsForTable('test-connection', 'public', 'users')
    // 2回目（キャッシュから返されること）
    await store.fetchColumnsForTable('test-connection', 'public', 'users')
    // API呼び出しが1回のみであることを検証
  })
})
```

**実行コマンド**: `npm run test:run`

**結果**: ☐ 合格 / ☐ 不合格

---

## 9. 総合評価

### 目標達成状況

| 測定項目 | Before | After | 目標値 | 達成状況 |
|---------|--------|-------|--------|---------|
| テーブル名補完利用可能時間（PostgreSQL 100テーブル） | _______ ms | _______ ms | ≤ 2000ms | ☐ 達成 / ☐ 未達成 |
| テーブル名補完利用可能時間（MySQL 100テーブル） | _______ ms | _______ ms | ≤ 2000ms | ☐ 達成 / ☐ 未達成 |
| テーブル名補完利用可能時間（SQLite 100テーブル） | _______ ms | _______ ms | ≤ 2000ms | ☐ 達成 / ☐ 未達成 |
| MySQL全構造取得時間（100テーブル） | _______ ms | _______ ms | ≤ 5000ms | ☐ 達成 / ☐ 未達成 |
| オンデマンドカラム取得時間（1テーブル） | N/A | _______ ms | ≤ 500ms | ☐ 達成 / ☐ 未達成 |

### 総合判定

- ☐ すべての目標を達成（合格）
- ☐ 一部の目標を達成（条件付き合格）
- ☐ 目標未達成（不合格）

### 備考

-

---

## 10. 課題・改善点

| 課題ID | 内容 | 対応方針 | 優先度 |
|-------|------|---------|--------|
| I-001 | | | |

---

## 11. 参考資料

- 技術仕様書: `docs/steering/03_architecture_specifications.md`
- 補完機能: `app/composables/useSqlCompletion.ts`
- Vitest ドキュメント: https://vitest.dev/
