# 初期化ロジック 詳細設計書

**優先度**: 🟢 低（オプション）
**工数**: 0.5-1時間
**依存関係**: WindowContext型定義とストア拡張

---

## 目的

アプリ起動時にウィンドウラベルから自動的にウィンドウタイプを判定し、コンテキストを初期化する。これにより:

- 各画面で手動でウィンドウタイプを設定する必要がなくなる
- ウィンドウラベルの命名規則に従って自動判定
- デバッグ時の利便性向上

**注意**: この機能は必須ではありません。なくても各画面で手動設定すれば動作します。

---

## 設計方針

### ウィンドウラベルの命名規則

Tauri側で以下の命名規則でウィンドウを作成（タスク1.5.2で実装済み）:

| ウィンドウタイプ | ラベル形式 | 例 |
|-----------------|-----------|-----|
| ランチャー | `launcher` または `main` | `launcher` |
| クエリビルダー | `query-builder-{connectionId}` | `query-builder-conn-123` |
| 設定 | `settings` | `settings` |

### 初期化タイミング

```
アプリ起動
  ↓
app.vue の onMounted
  ↓
windowStore.initialize() 呼び出し
  ↓
ウィンドウラベルを取得
  ↓
ラベルからコンテキストを解析
  ↓
currentContext に設定
```

---

## 実装

### ストアに追加するアクション

**ファイル**: `app/stores/window.ts`

```typescript
actions: {
  // ... 既存のactions ...

  /**
   * ウィンドウストアを初期化
   *
   * アプリ起動時に呼び出し、現在のウィンドウのコンテキストを設定する。
   * Tauri環境でのみ動作し、ブラウザモードでは安全にスキップする。
   */
  async initialize() {
    // クライアントサイドでない場合はスキップ（SSRガード）
    if (!import.meta.client) {
      console.log('[WindowStore] Skipping initialization (not client-side)')
      return
    }

    try {
      // Tauri APIを動的インポート（ブラウザモード対応）
      const { getCurrentWindow } = await import('@tauri-apps/api/window')
      const window = getCurrentWindow()
      const label = window.label

      console.log('[WindowStore] Initializing with label:', label)

      // ラベルからコンテキストを解析
      const context = this.parseWindowLabel(label)
      this.currentContext = context

      console.log('[WindowStore] Context initialized:', context)
    } catch (error) {
      // ブラウザモードではエラーになるが、無視して続行
      console.warn('[WindowStore] Failed to initialize (running in browser mode?):', error)

      // ブラウザモード用のデフォルトコンテキスト
      this.currentContext = {
        windowLabel: 'browser',
        windowType: 'launcher',
      }
    }
  },

  /**
   * ウィンドウラベルからコンテキストを解析
   *
   * @param label - Tauriのウィンドウラベル
   * @returns 解析されたウィンドウコンテキスト
   *
   * @example
   * parseWindowLabel('launcher') // => { windowLabel: 'launcher', windowType: 'launcher' }
   * parseWindowLabel('query-builder-conn-123') // => { windowLabel: '...', windowType: 'query_builder', connectionId: 'conn-123' }
   */
  parseWindowLabel(label: string): WindowContext {
    // ランチャー
    if (label === 'launcher' || label === 'main') {
      return {
        windowLabel: label,
        windowType: 'launcher',
      }
    }

    // 設定
    if (label === 'settings') {
      return {
        windowLabel: label,
        windowType: 'settings',
      }
    }

    // クエリビルダー
    if (label.startsWith('query-builder-')) {
      const connectionId = label.replace('query-builder-', '')
      return {
        windowLabel: label,
        windowType: 'query_builder',
        connectionId,
      }
    }

    // 未知のラベル（デフォルトはクエリビルダー）
    console.warn('[WindowStore] Unknown window label:', label)
    return {
      windowLabel: label,
      windowType: 'query_builder',
    }
  },
}
```

---

## app.vueでの初期化

### 実装方法

**ファイル**: `app/app.vue`

```vue
<script setup lang="ts">
import { onMounted } from 'vue'
import { useWindowStore } from '~/stores/window'

const windowStore = useWindowStore()

onMounted(async () => {
  // ウィンドウストアを初期化
  await windowStore.initialize()
})
</script>

<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```

**ポイント**:
- `onMounted` で初期化（クライアントサイドのみ）
- `async/await` で初期化完了を待つ（必須ではないが推奨）

---

## 動作確認

### ランチャーウィンドウ

```
起動時のログ:
[WindowStore] Initializing with label: launcher
[WindowStore] Context initialized: { windowLabel: 'launcher', windowType: 'launcher' }
```

### クエリビルダーウィンドウ

```
起動時のログ:
[WindowStore] Initializing with label: query-builder-conn-abc123
[WindowStore] Context initialized: {
  windowLabel: 'query-builder-conn-abc123',
  windowType: 'query_builder',
  connectionId: 'conn-abc123'
}
```

### ブラウザモード（npm run dev）

```
起動時のログ:
[WindowStore] Failed to initialize (running in browser mode?): Error: ...
[WindowStore] Context initialized: { windowLabel: 'browser', windowType: 'launcher' }
```

---

## 初期化後の追加設定

初期化で `connectionId` は設定されますが、`environment` は設定されません。
各画面で接続情報を取得後、環境を設定する必要があります。

### クエリビルダー画面での追加設定

```vue
<!-- app/pages/query-builder.vue -->
<script setup lang="ts">
import { onMounted } from 'vue'
import { useWindowStore } from '~/stores/window'
import { useConnectionStore } from '~/stores/connection'

const windowStore = useWindowStore()
const connectionStore = useConnectionStore()

onMounted(async () => {
  // 初期化で connectionId は既に設定されている
  const connId = windowStore.currentConnectionId

  if (connId) {
    await connectionStore.loadConnections()
    const connection = connectionStore.getConnectionById(connId)

    if (connection) {
      // 環境だけ追加設定
      windowStore.setConnectionContext(connection.id, connection.environment)
    }
  }
})
</script>
```

**または、URLパラメータから取得する方法も可能**:

```vue
<script setup lang="ts">
import { onMounted } from 'vue'
import { useRoute } from 'vue-router'
import { useWindowStore } from '~/stores/window'
import { useConnectionStore } from '~/stores/connection'

const route = useRoute()
const windowStore = useWindowStore()
const connectionStore = useConnectionStore()

onMounted(async () => {
  // URLパラメータから取得（Tauri側がクエリパラメータを渡している前提）
  const connId = route.query.connectionId as string || windowStore.currentConnectionId

  if (connId) {
    await connectionStore.loadConnections()
    const connection = connectionStore.getConnectionById(connId)

    if (connection) {
      windowStore.setConnectionContext(connection.id, connection.environment)
    }
  }
})
</script>
```

---

## テスト設計

### ユニットテスト

**ファイル**: `tests/stores/window.spec.ts` に追加

```typescript
describe('WindowStore - Initialization', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  describe('parseWindowLabel', () => {
    it('ランチャーラベルを正しく解析', () => {
      const store = useWindowStore()

      const launcher = store.parseWindowLabel('launcher')
      expect(launcher.windowType).toBe('launcher')
      expect(launcher.windowLabel).toBe('launcher')

      const main = store.parseWindowLabel('main')
      expect(main.windowType).toBe('launcher')
    })

    it('クエリビルダーラベルを正しく解析', () => {
      const store = useWindowStore()

      const qb = store.parseWindowLabel('query-builder-conn-123')
      expect(qb.windowType).toBe('query_builder')
      expect(qb.connectionId).toBe('conn-123')
      expect(qb.windowLabel).toBe('query-builder-conn-123')
    })

    it('設定ラベルを正しく解析', () => {
      const store = useWindowStore()

      const settings = store.parseWindowLabel('settings')
      expect(settings.windowType).toBe('settings')
      expect(settings.windowLabel).toBe('settings')
    })

    it('未知のラベルはクエリビルダーとして扱う', () => {
      const store = useWindowStore()

      const unknown = store.parseWindowLabel('unknown-label')
      expect(unknown.windowType).toBe('query_builder')
      expect(unknown.windowLabel).toBe('unknown-label')
    })
  })

  describe('initialize', () => {
    it('ブラウザモードでエラーにならない', async () => {
      const store = useWindowStore()

      // エラーを投げずに完了することを確認
      await expect(store.initialize()).resolves.toBeUndefined()

      // デフォルトコンテキストが設定されることを確認
      expect(store.currentContext).toBeTruthy()
    })
  })
})
```

---

## メリット・デメリット

### メリット ✅

1. **各画面での設定が不要**
   - ウィンドウタイプが自動判定される
   - コードが簡潔になる

2. **デバッグが容易**
   - コンソールログで現在のウィンドウ情報を確認しやすい
   - 起動時にコンテキストが設定されるため、画面遷移前から状態が分かる

3. **命名規則の強制**
   - ラベルから自動判定するため、命名規則が守られていないと動作しない
   - 実装のミスを早期発見できる

### デメリット ❌

1. **Tauri APIへの依存**
   - ブラウザモードでは完全には動作しない（フォールバック処理が必要）

2. **命名規則への依存**
   - ラベルの命名規則が変わると動作しなくなる
   - ドキュメント化が重要

3. **追加の複雑性**
   - シンプルに各画面で設定する方が理解しやすい場合もある

---

## 実装するかどうかの判断基準

### 実装を推奨する場合

- ✅ ウィンドウ数が多い（3種類以上）
- ✅ 各画面で同じような初期化コードを書きたくない
- ✅ 命名規則を厳密に守りたい

### 実装しなくて良い場合

- ❌ ウィンドウが2種類程度（ランチャー、クエリビルダー）
- ❌ シンプルさを最優先したい
- ❌ 各画面で手動設定しても問題ない

**推奨**: 現時点では実装せず、必要になったら追加するのが良いでしょう。

---

## チェックリスト

実装する場合の確認項目:

- [ ] `app/stores/window.ts` に `initialize()` メソッドを追加
- [ ] `app/stores/window.ts` に `parseWindowLabel()` メソッドを追加
- [ ] `app/app.vue` で `initialize()` を呼び出し
- [ ] `tests/stores/window.spec.ts` にテストを追加
- [ ] 各ウィンドウタイプで動作確認
- [ ] ブラウザモードでエラーが出ないことを確認
- [ ] コンソールログで初期化状態を確認

---

## 代替案: 手動設定

初期化ロジックを実装しない場合、各画面で以下のように手動設定:

```vue
<!-- app/pages/index.vue (ランチャー) -->
<script setup>
const windowStore = useWindowStore()

onMounted(() => {
  windowStore.currentContext = {
    windowLabel: 'launcher',
    windowType: 'launcher',
  }
})
</script>
```

```vue
<!-- app/pages/query-builder.vue -->
<script setup>
const windowStore = useWindowStore()

onMounted(() => {
  windowStore.currentContext = {
    windowLabel: 'query-builder',
    windowType: 'query_builder',
  }

  // 接続情報は別途設定
  // ...
})
</script>
```

**メリット**: シンプルで理解しやすい
**デメリット**: 各画面で同じようなコードを書く必要がある

---

## まとめ

初期化ロジックは**あると便利だが必須ではない**機能です。

- **まず**: 01, 02を実装して基本機能を完成させる
- **次に**: 実際に使ってみて不便を感じたら初期化ロジックを追加
- **最後に**: 必要なければ実装しない（YAGNI原則）

実装の判断は実際の使用感を見てから決定することを推奨します。
