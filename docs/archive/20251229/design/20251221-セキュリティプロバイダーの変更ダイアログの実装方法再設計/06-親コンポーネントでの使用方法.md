# 親コンポーネントでの使用方法

## 概要
設定ページ(セキュリティタブ)から新しいダイアログコンポーネントを使用する方法を説明する。

**初期実装スコープ:** Simple ⇄ Master Password の2つの移行パターンのみ
**将来実装予定:** Keychainサポート

## 親コンポーネント
`app/pages/settings.vue` (または設定ページのセキュリティタブコンポーネント)

## 現在の実装の問題点

### 変更前のコード例
```vue
<script setup lang="ts">
import ProviderChangeDialog from '~/components/security/ProviderChangeDialog.vue'

const isDialogOpen = ref(false)
const changeParams = ref<{ from: SecurityProvider; to: SecurityProvider } | null>(null)

function openChangeDialog(from: SecurityProvider, to: SecurityProvider) {
  changeParams.value = { from, to }
  isDialogOpen.value = true
}
</script>

<template>
  <ProviderChangeDialog
    v-model:open="isDialogOpen"
    :params="changeParams!"
  />

  <!-- プロバイダー選択UI -->
  <button @click="openChangeDialog('simple', 'master-password')">
    Master Passwordに変更
  </button>
</template>
```

**問題点:**
- 1つのダイアログコンポーネントで全フローを処理
- `params` プロップでfrom/toを渡す必要がある

## 新しい実装方法

### 方法1: 現在のプロバイダーに応じて条件付きレンダリング

```vue
<script setup lang="ts">
import { storeToRefs } from 'pinia'
import { useSecurityStore } from '~/stores/security'
import FromSimpleDialog from '~/components/security/provider-change/FromSimpleDialog.vue'
import FromMasterPasswordDialog from '~/components/security/provider-change/FromMasterPasswordDialog.vue'
import type { SecurityProvider } from '~/types'

const securityStore = useSecurityStore()
const { currentProvider } = storeToRefs(securityStore)

// ダイアログの開閉状態
const isChangeDialogOpen = ref(false)

// 移行先プロバイダー
const targetProvider = ref<SecurityProvider | null>(null)

/**
 * プロバイダー変更ダイアログを開く
 */
function openChangeDialog(to: SecurityProvider) {
  if (!currentProvider.value) {
    console.error('現在のプロバイダーが取得できません')
    return
  }

  // 同じプロバイダーには変更できない
  if (currentProvider.value === to) {
    console.warn('既に同じプロバイダーです')
    return
  }

  targetProvider.value = to
  isChangeDialogOpen.value = true
}

/**
 * ダイアログを閉じる
 */
function closeChangeDialog() {
  isChangeDialogOpen.value = false
  targetProvider.value = null
}
</script>

<template>
  <div>
    <!-- Simpleから他プロバイダーへの移行ダイアログ -->
    <FromSimpleDialog
      v-if="currentProvider === 'simple' && targetProvider"
      v-model:open="isChangeDialogOpen"
      :target-provider="targetProvider as 'master-password' | 'keychain'"
      @update:open="!$event && closeChangeDialog()"
    />

    <!-- Master Passwordから他プロバイダーへの移行ダイアログ -->
    <FromMasterPasswordDialog
      v-if="currentProvider === 'master-password' && targetProvider"
      v-model:open="isChangeDialogOpen"
      :target-provider="targetProvider as 'simple' | 'keychain'"
      @update:open="!$event && closeChangeDialog()"
    />

    <!-- プロバイダー選択UI -->
    <div class="space-y-4">
      <h3>プロバイダーを選択</h3>

      <div class="grid grid-cols-3 gap-4">
        <!-- Simple -->
        <button
          :disabled="currentProvider === 'simple'"
          @click="openChangeDialog('simple')"
        >
          Simple
        </button>

        <!-- Master Password -->
        <button
          :disabled="currentProvider === 'master-password'"
          @click="openChangeDialog('master-password')"
        >
          マスターパスワード
        </button>

        <!-- Keychain -->
        <button
          :disabled="currentProvider === 'keychain'"
          @click="openChangeDialog('keychain')"
        >
          OSキーチェーン
        </button>
      </div>
    </div>
  </div>
</template>
```

**利点:**
- 現在のプロバイダーに応じて自動的に適切なダイアログを選択
- 型安全性が高い(TypeScriptの型アサーションで保証)

**欠点:**
- テンプレートに条件分岐が入る
- 型アサーション(`as`)が必要

---

### 方法2: Computed Componentパターン (推奨)

```vue
<script setup lang="ts">
import { storeToRefs } from 'pinia'
import { useSecurityStore } from '~/stores/security'
import FromSimpleDialog from '~/components/security/provider-change/FromSimpleDialog.vue'
import FromMasterPasswordDialog from '~/components/security/provider-change/FromMasterPasswordDialog.vue'
import type { SecurityProvider } from '~/types'
import type { Component } from 'vue'

const securityStore = useSecurityStore()
const { currentProvider } = storeToRefs(securityStore)

const isChangeDialogOpen = ref(false)
const targetProvider = ref<SecurityProvider | null>(null)

/**
 * 現在のプロバイダーに応じた適切なダイアログコンポーネントを返す
 */
const ChangeDialogComponent = computed<Component | null>(() => {
  if (!currentProvider.value) return null

  switch (currentProvider.value) {
    case 'simple':
      return FromSimpleDialog
    case 'master-password':
      return FromMasterPasswordDialog
    case 'keychain':
      // Keychainからの移行は将来実装予定
      return null
    default:
      return null
  }
})

/**
 * 移行先プロバイダーの型を適切にキャストして返す
 */
const targetProviderTyped = computed(() => {
  if (!targetProvider.value || !currentProvider.value) return null

  // Simpleからの移行の場合
  if (currentProvider.value === 'simple') {
    if (targetProvider.value === 'master-password' || targetProvider.value === 'keychain') {
      return targetProvider.value
    }
  }

  // Master Passwordからの移行の場合
  if (currentProvider.value === 'master-password') {
    if (targetProvider.value === 'simple' || targetProvider.value === 'keychain') {
      return targetProvider.value
    }
  }

  return null
})

function openChangeDialog(to: SecurityProvider) {
  if (!currentProvider.value) {
    console.error('現在のプロバイダーが取得できません')
    return
  }

  if (currentProvider.value === to) {
    console.warn('既に同じプロバイダーです')
    return
  }

  targetProvider.value = to
  isChangeDialogOpen.value = true
}

function closeChangeDialog() {
  isChangeDialogOpen.value = false
  targetProvider.value = null
}
</script>

<template>
  <div>
    <!-- 動的コンポーネント -->
    <component
      :is="ChangeDialogComponent"
      v-if="ChangeDialogComponent && targetProviderTyped"
      v-model:open="isChangeDialogOpen"
      :target-provider="targetProviderTyped"
      @update:open="!$event && closeChangeDialog()"
    />

    <!-- プロバイダー選択UI -->
    <div class="space-y-4">
      <h3>プロバイダーを選択</h3>

      <div class="grid grid-cols-3 gap-4">
        <button
          :disabled="currentProvider === 'simple'"
          @click="openChangeDialog('simple')"
        >
          Simple
        </button>

        <button
          :disabled="currentProvider === 'master-password'"
          @click="openChangeDialog('master-password')"
        >
          マスターパスワード
        </button>

        <button
          :disabled="currentProvider === 'keychain'"
          @click="openChangeDialog('keychain')"
        >
          OSキーチェーン
        </button>
      </div>
    </div>
  </div>
</template>
```

**利点:**
- テンプレートがシンプル(1つの`<component>`のみ)
- 現在のプロバイダーに応じた適切なコンポーネントを自動選択
- 型安全性が高い(computedで適切な型を返す)

**欠点:**
- `targetProviderTyped` の型キャストロジックがやや複雑

---

### 方法3: Composableでロジックを抽象化 (最も推奨)

#### Composable: `useProviderChangeDialog.ts` (初期実装)

```typescript
// app/composables/useProviderChangeDialog.ts
import { computed, ref } from 'vue'
import { storeToRefs } from 'pinia'
import { useSecurityStore } from '~/stores/security'
import FromSimpleDialog from '~/components/security/provider-change/FromSimpleDialog.vue'
import FromMasterPasswordDialog from '~/components/security/provider-change/FromMasterPasswordDialog.vue'
import type { SecurityProvider } from '~/types'
import type { Component } from 'vue'

export function useProviderChangeDialog() {
  const securityStore = useSecurityStore()
  const { currentProvider } = storeToRefs(securityStore)

  const isOpen = ref(false)
  const targetProvider = ref<SecurityProvider | null>(null)

  /**
   * 現在のプロバイダーに応じた適切なダイアログコンポーネント
   */
  const dialogComponent = computed<Component | null>(() => {
    switch (currentProvider.value) {
      case 'simple':
        return FromSimpleDialog
      case 'master-password':
        return FromMasterPasswordDialog
      case 'keychain':
        // 将来実装予定
        return null
      default:
        return null
    }
  })

  /**
   * 型安全な移行先プロバイダー (初期実装)
   */
  const targetProviderTyped = computed<'master-password' | 'simple' | null>(() => {
    if (!targetProvider.value || !currentProvider.value) return null

    // Simpleからの移行 → Master Passwordのみ
    if (currentProvider.value === 'simple') {
      return targetProvider.value === 'master-password' ? 'master-password' : null
    }

    // Master Passwordからの移行 → Simpleのみ
    if (currentProvider.value === 'master-password') {
      return targetProvider.value === 'simple' ? 'simple' : null
    }

    return null
  })

  /**
   * ダイアログを開く
   */
  function open(to: SecurityProvider) {
    if (!currentProvider.value) {
      console.error('現在のプロバイダーが取得できません')
      return
    }

    if (currentProvider.value === to) {
      console.warn('既に同じプロバイダーです')
      return
    }

    // 初期実装: Simple ⇄ Master Password のみサポート
    const supportedTransitions = [
      { from: 'simple', to: 'master-password' },
      { from: 'master-password', to: 'simple' }
    ]

    const isSupported = supportedTransitions.some(
      transition => transition.from === currentProvider.value && transition.to === to
    )

    if (!isSupported) {
      console.warn(`${currentProvider.value} → ${to} への移行は未実装です`)
      return
    }

    targetProvider.value = to
    isOpen.value = true
  }

  /**
   * ダイアログを閉じる
   */
  function close() {
    isOpen.value = false
    targetProvider.value = null
  }

  return {
    isOpen,
    dialogComponent,
    targetProviderTyped,
    open,
    close
  }
}
```

#### 親コンポーネントでの使用

```vue
<script setup lang="ts">
import { useProviderChangeDialog } from '~/composables/useProviderChangeDialog'
import { storeToRefs } from 'pinia'
import { useSecurityStore } from '~/stores/security'

const securityStore = useSecurityStore()
const { currentProvider } = storeToRefs(securityStore)

const {
  isOpen,
  dialogComponent,
  targetProviderTyped,
  open: openChangeDialog,
  close: closeChangeDialog
} = useProviderChangeDialog()
</script>

<template>
  <div>
    <!-- 動的ダイアログ -->
    <component
      :is="dialogComponent"
      v-if="dialogComponent && targetProviderTyped"
      v-model:open="isOpen"
      :target-provider="targetProviderTyped"
      @update:open="!$event && closeChangeDialog()"
    />

    <!-- プロバイダー選択UI (初期実装) -->
    <div class="space-y-4">
      <h3>プロバイダーを選択</h3>

      <div class="grid grid-cols-2 gap-4">
        <!-- Simple -->
        <button
          :disabled="currentProvider === 'simple'"
          @click="openChangeDialog('simple')"
        >
          Simple
        </button>

        <!-- Master Password -->
        <button
          :disabled="currentProvider === 'master-password'"
          @click="openChangeDialog('master-password')"
        >
          マスターパスワード
        </button>

        <!-- 将来実装予定: Keychain
        <button
          :disabled="true"
          title="準備中"
        >
          OSキーチェーン (準備中)
        </button>
        -->
      </div>
    </div>
  </div>
</template>
```

**利点:**
- 親コンポーネントが最もシンプル
- ロジックがComposableに集約され、再利用可能
- テストが容易
- 型安全性が高い

**欠点:**
- 追加のComposableファイルが必要

---

## 推奨アプローチ

**方法3: Composableでロジックを抽象化**を推奨する。

### 理由
1. **関心の分離:** ダイアログ管理ロジックとUIを分離
2. **再利用性:** 他のページでも同じComposableを使用可能
3. **テスタビリティ:** Composableの単体テストが容易
4. **保守性:** ロジック変更時、Composableのみ修正すればよい
5. **可読性:** 親コンポーネントがシンプルで理解しやすい

## 実装の優先順位

1. **Phase 1:** `useProviderChangeDialog.ts` Composable作成
2. **Phase 2:** 設定ページでComposableを使用
3. **Phase 3:** 旧`ProviderChangeDialog.vue`の使用箇所を置き換え
4. **Phase 4:** 旧コンポーネント削除

## 移行チェックリスト

- [ ] `useProviderChangeDialog.ts` 作成
- [ ] 設定ページで新しいComposableを使用
- [ ] 動作確認(各フローをテスト)
- [ ] 旧`ProviderChangeDialog.vue`の使用箇所を検索
- [ ] 全ての使用箇所を新しい実装に置き換え
- [ ] 旧コンポーネント削除
- [ ] ドキュメント更新
