# タスク1.6.6: WHERE条件設定UI実装 設計書

## 概要

**タスクID**: 1.6.6
**タスク名**: WHERE条件設定UI実装
**工数**: 2日
**依存関係**: 1.6.5 (カラム選択UI実装)
**完了条件**: 条件追加・編集が可能
**UIフレームワーク**: Nuxt UI v4（Tailwind CSS 4ベース）

---

## 目的

SELECT文のWHERE句を視覚的に構築するUIを実装する。複数の条件をAND/ORで組み合わせ、グループ化にも対応する。Nuxt UI v4のフォームコンポーネント（`<USelect>`, `<UInput>`など）を使用して、ユーザーが直感的に条件を追加・編集・削除できるインターフェースを提供します。

---

## UI設計

### WHERE条件タブ

```
┌─────────────────────────────────────────────────────────────┐
│ [SELECT] [WHERE] [GROUP BY] [ORDER BY] [LIMIT]              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  WHERE条件                                    [+ 条件追加]   │
│  ─────────────────────────────────────────────────────────  │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐    │
│  │      u.status    =     'active'              [×]    │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                              │
│  [AND ▼]                                                    │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐    │
│  │      u.age       >=    18                    [×]    │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                              │
│  [AND ▼]                                                    │
│                                                              │
│  ┌─ OR グループ ───────────────────────────────────────┐    │
│  │  ┌───────────────────────────────────────────────┐  │    │
│  │  │    u.role     =     'admin'           [×]     │  │    │
│  │  └───────────────────────────────────────────────┘  │    │
│  │  [OR]                                               │    │
│  │  ┌───────────────────────────────────────────────┐  │    │
│  │  │    u.role     =     'manager'         [×]     │  │    │
│  │  └───────────────────────────────────────────────┘  │    │
│  │                                      [+ 条件追加]   │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                              │
│  [+ グループ追加]                                            │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 条件行

```
┌──────────────────────────────────────────────────────────────┐
│  [カラム選択 ▼]  [演算子 ▼]  [値入力...]           [×]     │
│   u.status         =          'active'                       │
└──────────────────────────────────────────────────────────────┘
```

---

## サポートする演算子

| 演算子 | 表示名 | 説明 | 値タイプ |
|--------|--------|------|----------|
| `=` | 等しい | 完全一致 | 単一値 |
| `!=` / `<>` | 等しくない | 不一致 | 単一値 |
| `>` | より大きい | 大なり | 単一値 |
| `>=` | 以上 | 大なりイコール | 単一値 |
| `<` | より小さい | 小なり | 単一値 |
| `<=` | 以下 | 小なりイコール | 単一値 |
| `LIKE` | 含む | パターンマッチ | 単一値 |
| `NOT LIKE` | 含まない | 否定パターン | 単一値 |
| `IN` | いずれか | 複数値のいずれか | 複数値 |
| `NOT IN` | いずれでもない | 複数値の否定 | 複数値 |
| `BETWEEN` | 範囲内 | 開始〜終了 | 範囲 |
| `IS NULL` | NULLである | NULL判定 | なし |
| `IS NOT NULL` | NULLでない | 非NULL判定 | なし |

---

## コンポーネント設計

### ファイル構成

```
src/components/query-builder/
├── where/
│   ├── WhereTab.vue              # WHEREタブ
│   ├── ConditionGroup.vue        # 条件グループ（AND/OR）
│   ├── ConditionRow.vue          # 条件行
│   ├── ColumnSelect.vue          # カラム選択ドロップダウン
│   ├── OperatorSelect.vue        # 演算子選択
│   ├── ValueInput.vue            # 値入力
│   ├── MultiValueInput.vue       # 複数値入力（IN用）
│   └── RangeInput.vue            # 範囲入力（BETWEEN用）
└── ConditionTabs.vue             # タブコンテナ（更新）
```

---

### where/WhereTab.vue

```vue
<script setup lang="ts">
import { computed } from 'vue';
import { useQueryBuilderStore } from '@/stores/query-builder';
import ConditionGroup from './ConditionGroup.vue';
import type { WhereCondition, ConditionGroup as ConditionGroupType } from '@/types/query';

const queryBuilderStore = useQueryBuilderStore();

// 選択されたテーブル
const selectedTables = computed(() => queryBuilderStore.selectedTables);

// WHERE条件
const whereConditions = computed(() => queryBuilderStore.whereConditions);

// テーブルがない場合
const isEmpty = computed(() => selectedTables.value.length === 0);

// 利用可能なカラム
const availableColumns = computed(() => {
  const columns: Array<{
    tableId: string;
    tableAlias: string;
    tableName: string;
    columnName: string;
    displayName: string;
    dataType: string;
  }> = [];

  for (const table of selectedTables.value) {
    for (const column of table.columns) {
      columns.push({
        tableId: table.id,
        tableAlias: table.alias,
        tableName: table.name,
        columnName: column.name,
        displayName: `${table.alias}.${column.name}`,
        dataType: column.dataType,
      });
    }
  }

  return columns;
});

/**
 * 条件を追加
 */
const addCondition = () => {
  queryBuilderStore.addWhereCondition({
    id: crypto.randomUUID(),
    type: 'condition',
    column: null,
    operator: '=',
    value: '',
    isValid: false,
  });
};

/**
 * グループを追加
 */
const addGroup = () => {
  queryBuilderStore.addWhereConditionGroup({
    id: crypto.randomUUID(),
    type: 'group',
    logic: 'OR',
    conditions: [],
  });
};
</script>

<template>
  <div class="where-tab">
    <!-- 空状態 -->
    <div v-if="isEmpty" class="empty-state">
      <v-icon size="48" color="grey-lighten-1">mdi-table-off</v-icon>
      <p class="text-grey mt-2">テーブルを選択してください</p>
      <p class="text-caption text-grey">
        WHERE条件を設定するにはテーブルが必要です
      </p>
    </div>

    <template v-else>
      <div class="where-tab-content">
        <!-- ヘッダー -->
        <div class="section-header">
          <span class="section-title">WHERE条件</span>
          <v-btn
            variant="tonal"
            size="small"
            color="primary"
            prepend-icon="mdi-plus"
            @click="addCondition"
          >
            条件追加
          </v-btn>
        </div>

        <!-- 条件なし -->
        <div v-if="whereConditions.length === 0" class="no-conditions">
          <v-icon color="grey-lighten-1">mdi-filter-off</v-icon>
          <p class="text-caption text-grey mt-2">
            条件がありません。「条件追加」で追加してください。
          </p>
        </div>

        <!-- 条件グループ -->
        <ConditionGroup
          v-else
          :conditions="whereConditions"
          :available-columns="availableColumns"
          :is-root="true"
          logic="AND"
        />

        <!-- グループ追加ボタン -->
        <v-btn
          v-if="whereConditions.length > 0"
          variant="text"
          size="small"
          prepend-icon="mdi-folder-plus"
          class="mt-4"
          @click="addGroup"
        >
          グループ追加
        </v-btn>
      </div>
    </template>
  </div>
</template>

<style scoped>
.where-tab {
  height: 100%;
  overflow: auto;
}

.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  padding: 24px;
  text-align: center;
}

.where-tab-content {
  padding: 16px;
}

.section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 16px;
}

.section-title {
  font-size: 0.875rem;
  font-weight: 500;
}

.no-conditions {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 32px;
  text-align: center;
  border: 2px dashed rgba(var(--v-border-color), var(--v-border-opacity));
  border-radius: 8px;
}
</style>
```

---

### where/ConditionGroup.vue

```vue
<script setup lang="ts">
import { computed } from 'vue';
import { useQueryBuilderStore } from '@/stores/query-builder';
import ConditionRow from './ConditionRow.vue';
import type { WhereCondition, ConditionGroup } from '@/types/query';

interface AvailableColumn {
  tableId: string;
  tableAlias: string;
  tableName: string;
  columnName: string;
  displayName: string;
  dataType: string;
}

const props = defineProps<{
  conditions: Array<WhereCondition | ConditionGroup>;
  availableColumns: AvailableColumn[];
  isRoot: boolean;
  logic: 'AND' | 'OR';
  groupId?: string;
}>();

const queryBuilderStore = useQueryBuilderStore();

/**
 * ロジック変更
 */
const handleLogicChange = (index: number, newLogic: 'AND' | 'OR') => {
  // グループ内のロジック変更は親に委譲
  if (props.groupId) {
    queryBuilderStore.updateGroupLogic(props.groupId, newLogic);
  }
};

/**
 * 条件を削除
 */
const handleRemove = (id: string) => {
  if (props.groupId) {
    queryBuilderStore.removeConditionFromGroup(props.groupId, id);
  } else {
    queryBuilderStore.removeWhereCondition(id);
  }
};

/**
 * 条件を更新
 */
const handleUpdate = (id: string, updates: Partial<WhereCondition>) => {
  queryBuilderStore.updateWhereCondition(id, updates);
};

/**
 * グループ内に条件追加
 */
const addConditionToGroup = () => {
  if (props.groupId) {
    queryBuilderStore.addConditionToGroup(props.groupId, {
      id: crypto.randomUUID(),
      type: 'condition',
      column: null,
      operator: '=',
      value: '',
      isValid: false,
    });
  }
};

/**
 * グループを削除
 */
const removeGroup = () => {
  if (props.groupId) {
    queryBuilderStore.removeWhereCondition(props.groupId);
  }
};

/**
 * 条件かグループかを判定
 */
const isCondition = (item: WhereCondition | ConditionGroup): item is WhereCondition => {
  return item.type === 'condition';
};
</script>

<template>
  <div class="condition-group" :class="{ 'is-nested': !isRoot }">
    <!-- グループヘッダー（ネストされている場合） -->
    <div v-if="!isRoot" class="group-header">
      <span class="group-label">{{ logic }} グループ</span>
      <v-spacer />
      <v-btn
        icon
        variant="text"
        size="x-small"
        color="error"
        @click="removeGroup"
      >
        <v-icon size="small">mdi-close</v-icon>
      </v-btn>
    </div>

    <!-- 条件リスト -->
    <div class="conditions-list">
      <template v-for="(item, index) in conditions" :key="item.id">
        <!-- ロジック選択（2番目以降） -->
        <div v-if="index > 0" class="logic-connector">
          <v-btn-toggle
            :model-value="logic"
            mandatory
            density="compact"
            color="primary"
            @update:model-value="handleLogicChange(index, $event)"
          >
            <v-btn value="AND" size="small">AND</v-btn>
            <v-btn value="OR" size="small">OR</v-btn>
          </v-btn-toggle>
        </div>

        <!-- 条件行 -->
        <ConditionRow
          v-if="isCondition(item)"
          :condition="item"
          :available-columns="availableColumns"
          @update="(updates) => handleUpdate(item.id, updates)"
          @remove="handleRemove(item.id)"
        />

        <!-- ネストされたグループ -->
        <ConditionGroup
          v-else
          :conditions="item.conditions"
          :available-columns="availableColumns"
          :is-root="false"
          :logic="item.logic"
          :group-id="item.id"
        />
      </template>
    </div>

    <!-- グループ内追加ボタン（ネストされている場合） -->
    <v-btn
      v-if="!isRoot"
      variant="text"
      size="small"
      prepend-icon="mdi-plus"
      class="mt-2"
      @click="addConditionToGroup"
    >
      条件追加
    </v-btn>
  </div>
</template>

<style scoped>
.condition-group {
  display: flex;
  flex-direction: column;
}

.condition-group.is-nested {
  margin: 8px 0;
  padding: 12px;
  border: 1px solid rgba(var(--v-border-color), var(--v-border-opacity));
  border-left: 3px solid rgb(var(--v-theme-secondary));
  border-radius: 8px;
  background: rgba(var(--v-theme-surface-variant), 0.3);
}

.group-header {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.group-label {
  font-size: 0.75rem;
  font-weight: 500;
  color: rgb(var(--v-theme-secondary));
  text-transform: uppercase;
}

.conditions-list {
  display: flex;
  flex-direction: column;
}

.logic-connector {
  display: flex;
  justify-content: flex-start;
  padding: 8px 0;
}
</style>
```

---

### where/ConditionRow.vue

```vue
<script setup lang="ts">
import { computed, watch } from 'vue';
import ColumnSelect from './ColumnSelect.vue';
import OperatorSelect from './OperatorSelect.vue';
import ValueInput from './ValueInput.vue';
import MultiValueInput from './MultiValueInput.vue';
import RangeInput from './RangeInput.vue';
import type { WhereCondition, WhereOperator } from '@/types/query';

interface AvailableColumn {
  tableId: string;
  tableAlias: string;
  tableName: string;
  columnName: string;
  displayName: string;
  dataType: string;
}

const props = defineProps<{
  condition: WhereCondition;
  availableColumns: AvailableColumn[];
}>();

const emit = defineEmits<{
  (e: 'update', updates: Partial<WhereCondition>): void;
  (e: 'remove'): void;
}>();

// 選択されたカラムの情報
const selectedColumn = computed(() => {
  if (!props.condition.column) return null;
  return props.availableColumns.find(
    (c) =>
      c.tableAlias === props.condition.column?.tableAlias &&
      c.columnName === props.condition.column?.columnName
  );
});

// 値入力タイプ
const valueInputType = computed(() => {
  const op = props.condition.operator;
  if (op === 'IS NULL' || op === 'IS NOT NULL') return 'none';
  if (op === 'IN' || op === 'NOT IN') return 'multi';
  if (op === 'BETWEEN') return 'range';
  return 'single';
});

// カラム変更
const handleColumnChange = (column: { tableAlias: string; columnName: string } | null) => {
  emit('update', {
    column,
    value: '',
    isValid: false,
  });
};

// 演算子変更
const handleOperatorChange = (operator: WhereOperator) => {
  emit('update', {
    operator,
    value: operator === 'IS NULL' || operator === 'IS NOT NULL' ? '' : props.condition.value,
  });
};

// 値変更
const handleValueChange = (value: string | string[] | { from: string; to: string }) => {
  emit('update', { value });
  validateCondition(value);
};

// バリデーション
const validateCondition = (value: any) => {
  let isValid = false;

  if (!props.condition.column) {
    isValid = false;
  } else if (props.condition.operator === 'IS NULL' || props.condition.operator === 'IS NOT NULL') {
    isValid = true;
  } else if (valueInputType.value === 'multi') {
    isValid = Array.isArray(value) && value.length > 0;
  } else if (valueInputType.value === 'range') {
    isValid = typeof value === 'object' && value.from !== '' && value.to !== '';
  } else {
    isValid = value !== '';
  }

  emit('update', { isValid });
};
</script>

<template>
  <div class="condition-row" :class="{ 'is-invalid': !condition.isValid }">
    <!-- カラム選択 -->
    <ColumnSelect
      :model-value="condition.column"
      :columns="availableColumns"
      class="column-select"
      @update:model-value="handleColumnChange"
    />

    <!-- 演算子選択 -->
    <OperatorSelect
      :model-value="condition.operator"
      :data-type="selectedColumn?.dataType"
      class="operator-select"
      @update:model-value="handleOperatorChange"
    />

    <!-- 値入力 -->
    <template v-if="valueInputType === 'single'">
      <ValueInput
        :model-value="condition.value as string"
        :data-type="selectedColumn?.dataType"
        class="value-input"
        @update:model-value="handleValueChange"
      />
    </template>

    <template v-else-if="valueInputType === 'multi'">
      <MultiValueInput
        :model-value="condition.value as string[]"
        :data-type="selectedColumn?.dataType"
        class="value-input"
        @update:model-value="handleValueChange"
      />
    </template>

    <template v-else-if="valueInputType === 'range'">
      <RangeInput
        :model-value="condition.value as { from: string; to: string }"
        :data-type="selectedColumn?.dataType"
        class="value-input"
        @update:model-value="handleValueChange"
      />
    </template>

    <template v-else>
      <div class="value-placeholder">（値不要）</div>
    </template>

    <!-- 削除ボタン -->
    <v-btn
      icon
      variant="text"
      size="small"
      color="error"
      @click="emit('remove')"
    >
      <v-icon>mdi-close</v-icon>
    </v-btn>
  </div>
</template>

<style scoped>
.condition-row {
  display: flex;
  align-items: center;
  padding: 8px;
  gap: 8px;
  border: 1px solid rgba(var(--v-border-color), var(--v-border-opacity));
  border-radius: 8px;
  background: rgb(var(--v-theme-surface));
}

.condition-row.is-invalid {
  border-color: rgb(var(--v-theme-error));
  background: rgba(var(--v-theme-error), 0.05);
}

.column-select {
  flex: 2;
  min-width: 150px;
}

.operator-select {
  flex: 1;
  min-width: 120px;
}

.value-input {
  flex: 2;
  min-width: 150px;
}

.value-placeholder {
  flex: 2;
  min-width: 150px;
  color: rgb(var(--v-theme-on-surface-variant));
  font-style: italic;
  font-size: 0.875rem;
}
</style>
```

---

### where/ColumnSelect.vue

```vue
<script setup lang="ts">
import { computed } from 'vue';

interface ColumnOption {
  tableId: string;
  tableAlias: string;
  tableName: string;
  columnName: string;
  displayName: string;
  dataType: string;
}

const props = defineProps<{
  modelValue: { tableAlias: string; columnName: string } | null;
  columns: ColumnOption[];
}>();

const emit = defineEmits<{
  (e: 'update:modelValue', value: { tableAlias: string; columnName: string } | null): void;
}>();

// 選択値
const selected = computed({
  get: () => {
    if (!props.modelValue) return null;
    return `${props.modelValue.tableAlias}.${props.modelValue.columnName}`;
  },
  set: (value) => {
    if (!value) {
      emit('update:modelValue', null);
      return;
    }
    const column = props.columns.find((c) => c.displayName === value);
    if (column) {
      emit('update:modelValue', {
        tableAlias: column.tableAlias,
        columnName: column.columnName,
      });
    }
  },
});

// テーブルごとにグループ化
const groupedColumns = computed(() => {
  const groups: Record<string, ColumnOption[]> = {};
  for (const column of props.columns) {
    const key = `${column.tableName} (${column.tableAlias})`;
    if (!groups[key]) {
      groups[key] = [];
    }
    groups[key].push(column);
  }
  return groups;
});
</script>

<template>
  <v-select
    v-model="selected"
    :items="columns.map((c) => c.displayName)"
    density="compact"
    variant="outlined"
    placeholder="カラムを選択"
    hide-details
    clearable
  >
    <template #item="{ item, props: itemProps }">
      <v-list-item v-bind="itemProps">
        <template #prepend>
          <v-icon size="small" color="grey">mdi-format-text</v-icon>
        </template>
        <v-list-item-title>{{ item.title }}</v-list-item-title>
      </v-list-item>
    </template>
  </v-select>
</template>
```

---

### where/OperatorSelect.vue

```vue
<script setup lang="ts">
import { computed } from 'vue';
import type { WhereOperator } from '@/types/query';

const props = defineProps<{
  modelValue: WhereOperator;
  dataType?: string;
}>();

const emit = defineEmits<{
  (e: 'update:modelValue', value: WhereOperator): void;
}>();

// 全演算子
const allOperators: Array<{ value: WhereOperator; label: string }> = [
  { value: '=', label: '=' },
  { value: '!=', label: '!=' },
  { value: '>', label: '>' },
  { value: '>=', label: '>=' },
  { value: '<', label: '<' },
  { value: '<=', label: '<=' },
  { value: 'LIKE', label: 'LIKE' },
  { value: 'NOT LIKE', label: 'NOT LIKE' },
  { value: 'IN', label: 'IN' },
  { value: 'NOT IN', label: 'NOT IN' },
  { value: 'BETWEEN', label: 'BETWEEN' },
  { value: 'IS NULL', label: 'IS NULL' },
  { value: 'IS NOT NULL', label: 'IS NOT NULL' },
];

// データ型に応じてフィルタリング
const availableOperators = computed(() => {
  // 全て表示（将来的にはデータ型でフィルタ）
  return allOperators;
});

const selected = computed({
  get: () => props.modelValue,
  set: (value) => emit('update:modelValue', value),
});
</script>

<template>
  <v-select
    v-model="selected"
    :items="availableOperators"
    item-value="value"
    item-title="label"
    density="compact"
    variant="outlined"
    hide-details
  />
</template>
```

---

### where/ValueInput.vue

```vue
<script setup lang="ts">
import { computed } from 'vue';

const props = defineProps<{
  modelValue: string;
  dataType?: string;
}>();

const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void;
}>();

const value = computed({
  get: () => props.modelValue,
  set: (v) => emit('update:modelValue', v),
});

// 入力タイプ（データ型に応じて変更）
const inputType = computed(() => {
  if (!props.dataType) return 'text';

  const type = props.dataType.toLowerCase();
  if (type.includes('int') || type.includes('numeric') || type.includes('decimal')) {
    return 'number';
  }
  if (type.includes('date') && !type.includes('time')) {
    return 'date';
  }
  if (type.includes('time') && !type.includes('date')) {
    return 'time';
  }
  if (type.includes('timestamp') || type.includes('datetime')) {
    return 'datetime-local';
  }
  return 'text';
});

// プレースホルダー
const placeholder = computed(() => {
  if (inputType.value === 'number') return '数値を入力';
  if (inputType.value === 'date') return '日付を選択';
  return '値を入力';
});
</script>

<template>
  <v-text-field
    v-model="value"
    :type="inputType"
    :placeholder="placeholder"
    density="compact"
    variant="outlined"
    hide-details
  />
</template>
```

---

### where/MultiValueInput.vue

```vue
<script setup lang="ts">
import { computed, ref } from 'vue';

const props = defineProps<{
  modelValue: string[];
  dataType?: string;
}>();

const emit = defineEmits<{
  (e: 'update:modelValue', value: string[]): void;
}>();

const inputValue = ref('');

const values = computed({
  get: () => props.modelValue || [],
  set: (v) => emit('update:modelValue', v),
});

/**
 * 値を追加
 */
const addValue = () => {
  const trimmed = inputValue.value.trim();
  if (trimmed && !values.value.includes(trimmed)) {
    emit('update:modelValue', [...values.value, trimmed]);
    inputValue.value = '';
  }
};

/**
 * 値を削除
 */
const removeValue = (index: number) => {
  const newValues = [...values.value];
  newValues.splice(index, 1);
  emit('update:modelValue', newValues);
};

/**
 * Enterで追加
 */
const handleKeyDown = (e: KeyboardEvent) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    addValue();
  }
};
</script>

<template>
  <div class="multi-value-input">
    <div class="values-chips">
      <v-chip
        v-for="(val, index) in values"
        :key="index"
        size="small"
        closable
        @click:close="removeValue(index)"
      >
        {{ val }}
      </v-chip>
    </div>

    <v-text-field
      v-model="inputValue"
      placeholder="値を入力してEnter"
      density="compact"
      variant="outlined"
      hide-details
      @keydown="handleKeyDown"
    >
      <template #append-inner>
        <v-btn
          icon
          variant="text"
          size="x-small"
          :disabled="!inputValue.trim()"
          @click="addValue"
        >
          <v-icon size="small">mdi-plus</v-icon>
        </v-btn>
      </template>
    </v-text-field>
  </div>
</template>

<style scoped>
.multi-value-input {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.values-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  min-height: 24px;
}
</style>
```

---

### where/RangeInput.vue

```vue
<script setup lang="ts">
import { computed } from 'vue';

const props = defineProps<{
  modelValue: { from: string; to: string };
  dataType?: string;
}>();

const emit = defineEmits<{
  (e: 'update:modelValue', value: { from: string; to: string }): void;
}>();

const fromValue = computed({
  get: () => props.modelValue?.from || '',
  set: (v) => emit('update:modelValue', { ...props.modelValue, from: v }),
});

const toValue = computed({
  get: () => props.modelValue?.to || '',
  set: (v) => emit('update:modelValue', { ...props.modelValue, to: v }),
});
</script>

<template>
  <div class="range-input">
    <v-text-field
      v-model="fromValue"
      placeholder="開始値"
      density="compact"
      variant="outlined"
      hide-details
    />
    <span class="range-separator">〜</span>
    <v-text-field
      v-model="toValue"
      placeholder="終了値"
      density="compact"
      variant="outlined"
      hide-details
    />
  </div>
</template>

<style scoped>
.range-input {
  display: flex;
  align-items: center;
  gap: 8px;
}

.range-separator {
  color: rgb(var(--v-theme-on-surface-variant));
}
</style>
```

---

## 状態管理

### query-builder.ts（WHERE条件関連の追加）

```typescript
import { defineStore } from 'pinia';
import type { WhereCondition, ConditionGroup } from '@/types/query';

interface QueryBuilderState {
  whereConditions: Array<WhereCondition | ConditionGroup>;
  whereLogic: 'AND' | 'OR';
  // ...
}

export const useQueryBuilderStore = defineStore('query-builder', {
  state: (): QueryBuilderState => ({
    whereConditions: [],
    whereLogic: 'AND',
    // ...
  }),

  actions: {
    /**
     * WHERE条件を追加
     */
    addWhereCondition(condition: WhereCondition) {
      this.whereConditions.push(condition);
      this.regenerateSql();
    },

    /**
     * 条件グループを追加
     */
    addWhereConditionGroup(group: ConditionGroup) {
      this.whereConditions.push(group);
      this.regenerateSql();
    },

    /**
     * WHERE条件を削除
     */
    removeWhereCondition(id: string) {
      const index = this.whereConditions.findIndex((c) => c.id === id);
      if (index !== -1) {
        this.whereConditions.splice(index, 1);
        this.regenerateSql();
      }
    },

    /**
     * WHERE条件を更新
     */
    updateWhereCondition(id: string, updates: Partial<WhereCondition>) {
      const condition = this.findCondition(id);
      if (condition && condition.type === 'condition') {
        Object.assign(condition, updates);
        this.regenerateSql();
      }
    },

    /**
     * グループ内に条件追加
     */
    addConditionToGroup(groupId: string, condition: WhereCondition) {
      const group = this.findCondition(groupId);
      if (group && group.type === 'group') {
        group.conditions.push(condition);
        this.regenerateSql();
      }
    },

    /**
     * グループから条件削除
     */
    removeConditionFromGroup(groupId: string, conditionId: string) {
      const group = this.findCondition(groupId);
      if (group && group.type === 'group') {
        const index = group.conditions.findIndex((c) => c.id === conditionId);
        if (index !== -1) {
          group.conditions.splice(index, 1);
          this.regenerateSql();
        }
      }
    },

    /**
     * グループのロジック変更
     */
    updateGroupLogic(groupId: string, logic: 'AND' | 'OR') {
      const group = this.findCondition(groupId);
      if (group && group.type === 'group') {
        group.logic = logic;
        this.regenerateSql();
      }
    },

    /**
     * 条件を検索（再帰）
     */
    findCondition(id: string): WhereCondition | ConditionGroup | null {
      const search = (items: Array<WhereCondition | ConditionGroup>): WhereCondition | ConditionGroup | null => {
        for (const item of items) {
          if (item.id === id) return item;
          if (item.type === 'group') {
            const found = search(item.conditions);
            if (found) return found;
          }
        }
        return null;
      };
      return search(this.whereConditions);
    },

    /**
     * 全条件をクリア
     */
    clearWhereConditions() {
      this.whereConditions = [];
      this.regenerateSql();
    },
  },
});
```

---

## 型定義

### src/types/query.ts（追加）

```typescript
/**
 * WHERE演算子
 */
export type WhereOperator =
  | '='
  | '!='
  | '>'
  | '>='
  | '<'
  | '<='
  | 'LIKE'
  | 'NOT LIKE'
  | 'IN'
  | 'NOT IN'
  | 'BETWEEN'
  | 'IS NULL'
  | 'IS NOT NULL';

/**
 * WHERE条件
 */
export interface WhereCondition {
  id: string;
  type: 'condition';
  column: {
    tableAlias: string;
    columnName: string;
  } | null;
  operator: WhereOperator;
  value: string | string[] | { from: string; to: string };
  isValid: boolean;
}

/**
 * 条件グループ
 */
export interface ConditionGroup {
  id: string;
  type: 'group';
  logic: 'AND' | 'OR';
  conditions: Array<WhereCondition | ConditionGroup>;
}
```

---

## テスト設計

### ユニットテスト

```typescript
describe('WhereTab', () => {
  it('should show empty state when no tables', () => {
    // テーブルがない場合は空状態を表示
  });

  it('should add condition on button click', () => {
    // 条件追加ボタンで条件が追加される
  });
});

describe('ConditionRow', () => {
  it('should update column selection', () => {
    // カラム選択が更新される
  });

  it('should show appropriate value input for operator', () => {
    // 演算子に応じた値入力が表示される
  });

  it('should validate condition', () => {
    // 条件のバリデーションが動作する
  });
});

describe('ConditionGroup', () => {
  it('should toggle AND/OR logic', () => {
    // AND/ORの切り替えが動作する
  });

  it('should support nested groups', () => {
    // ネストされたグループが動作する
  });
});
```

### E2Eテストシナリオ

```
シナリオ1: 条件追加
1. WHEREタブを選択
2. 「条件追加」をクリック
3. カラムを選択
4. 演算子を選択
5. 値を入力
6. SQLプレビューに反映されることを確認

シナリオ2: 複数条件
1. 2つの条件を追加
2. AND/ORを切り替え
3. SQLが正しく生成されることを確認

シナリオ3: グループ化
1. グループを追加
2. グループ内に条件を追加
3. ネストされたWHERE句が生成されることを確認
```

---

## 実装チェックリスト

- [ ] `src/components/query-builder/where/WhereTab.vue` の作成
- [ ] `src/components/query-builder/where/ConditionGroup.vue` の作成
- [ ] `src/components/query-builder/where/ConditionRow.vue` の作成
- [ ] `src/components/query-builder/where/ColumnSelect.vue` の作成
- [ ] `src/components/query-builder/where/OperatorSelect.vue` の作成
- [ ] `src/components/query-builder/where/ValueInput.vue` の作成
- [ ] `src/components/query-builder/where/MultiValueInput.vue` の作成
- [ ] `src/components/query-builder/where/RangeInput.vue` の作成
- [ ] `src/types/query.ts` の更新（WHERE型定義）
- [ ] `src/stores/query-builder.ts` の更新（WHERE機能）
- [ ] 条件グループ化機能の実装
- [ ] バリデーション機能の実装
- [ ] ユニットテストの作成
- [ ] E2Eテストの作成

---

## 参考資料

- [Nuxt UI v4 Documentation](https://ui.nuxt.com/)
- [Nuxt UI Select Component](https://ui.nuxt.com/components/select)
- [Nuxt UI Input Component](https://ui.nuxt.com/components/input)
- [Nuxt UI Button Group](https://ui.nuxt.com/components/button-group)
- [Tailwind CSS v4](https://tailwindcss.com/)
- [SQL WHERE Clause](https://www.w3schools.com/sql/sql_where.asp)
