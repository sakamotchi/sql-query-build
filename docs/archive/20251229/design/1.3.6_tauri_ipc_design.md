# タスク1.3.6: Tauri IPC通信実装 設計書

## 概要

**タスクID**: 1.3.6
**タスク名**: Tauri IPC通信実装
**工数**: 2日
**依存関係**: 1.3.4 (接続CRUD機能実装(Rust)), 1.3.5 (フロントエンド接続管理Store実装)
**完了条件**: FE-BE間通信が動作

---

## 目的

フロントエンド(Vue/TypeScript)とバックエンド(Rust)間のIPC(Inter-Process Communication)を実装し、型安全な通信を確立する。

---

## アーキテクチャ

```
┌─────────────────────────────────┐
│     Frontend (Vue/TypeScript)   │
│  ┌─────────────────────────┐   │
│  │  Pinia Store            │   │
│  └──────────┬──────────────┘   │
│             │                   │
│  ┌──────────▼──────────────┐   │
│  │  IPC Client Layer       │   │
│  │  (TypeScript)           │   │
│  └──────────┬──────────────┘   │
└─────────────┼───────────────────┘
              │ Tauri IPC
              │ (JSON-RPC 2.0)
┌─────────────▼───────────────────┐
│  ┌─────────────────────────┐   │
│  │  Tauri Commands         │   │
│  │  (Rust)                 │   │
│  └──────────┬──────────────┘   │
│             │                   │
│  ┌──────────▼──────────────┐   │
│  │  Service Layer          │   │
│  │  (Rust)                 │   │
│  └─────────────────────────┘   │
│     Backend (Rust)              │
└─────────────────────────────────┘
```

---

## フロントエンドIPC層

### TypeScript API ラッパー

**ファイル**: `src/api/connection.ts`

```typescript
import { invoke } from '@tauri-apps/api/core';
import type { Connection } from '@/stores/types';

/**
 * 接続API クライアント
 */
export class ConnectionAPI {
  /**
   * すべての接続を取得
   */
  static async getAll(): Promise<Connection[]> {
    try {
      return await invoke<Connection[]>('get_connections');
    } catch (error) {
      throw new Error(`接続情報の取得に失敗しました: ${error}`);
    }
  }

  /**
   * IDで接続を取得
   */
  static async getById(id: string, includePassword = false): Promise<Connection | null> {
    try {
      return await invoke<Connection | null>('get_connection', {
        id,
        includePassword,
      });
    } catch (error) {
      throw new Error(`接続情報の取得に失敗しました: ${error}`);
    }
  }

  /**
   * 接続を作成
   */
  static async create(connection: Connection): Promise<Connection> {
    try {
      return await invoke<Connection>('create_connection', {
        connection,
      });
    } catch (error) {
      throw new Error(`接続の作成に失敗しました: ${error}`);
    }
  }

  /**
   * 接続を更新
   */
  static async update(connection: Connection): Promise<Connection> {
    try {
      return await invoke<Connection>('update_connection', {
        connection,
      });
    } catch (error) {
      throw new Error(`接続の更新に失敗しました: ${error}`);
    }
  }

  /**
   * 接続を削除
   */
  static async delete(id: string): Promise<void> {
    try {
      await invoke<void>('delete_connection', { id });
    } catch (error) {
      throw new Error(`接続の削除に失敗しました: ${error}`);
    }
  }

  /**
   * 最終使用日時を更新
   */
  static async markAsUsed(id: string): Promise<void> {
    try {
      await invoke<void>('mark_connection_used', { id });
    } catch (error) {
      // エラーは無視(致命的ではない)
      console.warn('Failed to mark connection as used:', error);
    }
  }

  /**
   * 接続をテスト
   */
  static async testConnection(connection: Partial<Connection>): Promise<TestConnectionResult> {
    try {
      return await invoke<TestConnectionResult>('test_connection', {
        connection,
      });
    } catch (error) {
      throw new Error(`接続テストに失敗しました: ${error}`);
    }
  }
}

export interface TestConnectionResult {
  success: boolean;
  message: string;
  duration?: number; // ミリ秒
  serverVersion?: string;
}
```

---

## バックエンドIPC層

### Tauriコマンドハンドラー

**ファイル**: `src-tauri/src/commands/connection.rs`

```rust
use tauri::State;
use serde::{Deserialize, Serialize};
use crate::models::connection::Connection;
use crate::services::connection_service::ConnectionService;

type ConnectionServiceState = State<'_, ConnectionService>;

/// すべての接続を取得
#[tauri::command]
pub async fn get_connections(
    service: ConnectionServiceState<'_>,
) -> Result<Vec<Connection>, String> {
    service
        .get_all()
        .map_err(|e| format!("Failed to get connections: {}", e))
}

/// IDで接続を取得
#[tauri::command]
pub async fn get_connection(
    id: String,
    include_password: bool,
    service: ConnectionServiceState<'_>,
) -> Result<Option<Connection>, String> {
    service
        .get_by_id(&id, include_password)
        .map_err(|e| format!("Failed to get connection: {}", e))
}

/// 接続を作成
#[tauri::command]
pub async fn create_connection(
    connection: Connection,
    service: ConnectionServiceState<'_>,
) -> Result<Connection, String> {
    // バリデーション
    service
        .validate(&connection)
        .map_err(|e| format!("Validation error: {}", e))?;

    service
        .create(connection)
        .map_err(|e| format!("Failed to create connection: {}", e))
}

/// 接続を更新
#[tauri::command]
pub async fn update_connection(
    connection: Connection,
    service: ConnectionServiceState<'_>,
) -> Result<Connection, String> {
    // バリデーション
    service
        .validate(&connection)
        .map_err(|e| format!("Validation error: {}", e))?;

    service
        .update(connection)
        .map_err(|e| format!("Failed to update connection: {}", e))
}

/// 接続を削除
#[tauri::command]
pub async fn delete_connection(
    id: String,
    service: ConnectionServiceState<'_>,
) -> Result<(), String> {
    service
        .delete(&id)
        .map_err(|e| format!("Failed to delete connection: {}", e))
}

/// 最終使用日時を更新
#[tauri::command]
pub async fn mark_connection_used(
    id: String,
    service: ConnectionServiceState<'_>,
) -> Result<(), String> {
    service
        .mark_as_used(&id)
        .map_err(|e| format!("Failed to update last used: {}", e))
}

/// 接続テスト結果
#[derive(Debug, Serialize, Deserialize)]
pub struct TestConnectionResult {
    pub success: bool,
    pub message: String,
    pub duration: Option<u64>, // ミリ秒
    pub server_version: Option<String>,
}

/// 接続をテスト
#[tauri::command]
pub async fn test_connection(
    connection: Connection,
    service: ConnectionServiceState<'_>,
) -> Result<TestConnectionResult, String> {
    service
        .test_connection(&connection)
        .await
        .map_err(|e| format!("Connection test failed: {}", e))
}
```

---

## エラーハンドリング

### カスタムエラー型

**ファイル**: `src-tauri/src/error.rs`

```rust
use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("Connection not found: {0}")]
    ConnectionNotFound(String),

    #[error("Connection already exists: {0}")]
    ConnectionAlreadyExists(String),

    #[error("Validation error: {0}")]
    ValidationError(String),

    #[error("Encryption error: {0}")]
    EncryptionError(String),

    #[error("Storage error: {0}")]
    StorageError(#[from] std::io::Error),

    #[error("JSON error: {0}")]
    JsonError(#[from] serde_json::Error),

    #[error("Database error: {0}")]
    DatabaseError(String),
}

/// フロントエンドに返すエラーレスポンス
#[derive(Debug, Serialize, Deserialize)]
pub struct ErrorResponse {
    pub code: String,
    pub message: String,
    pub details: Option<String>,
}

impl From<AppError> for ErrorResponse {
    fn from(error: AppError) -> Self {
        match error {
            AppError::ConnectionNotFound(id) => ErrorResponse {
                code: "CONNECTION_NOT_FOUND".to_string(),
                message: format!("接続が見つかりません: {}", id),
                details: None,
            },
            AppError::ValidationError(msg) => ErrorResponse {
                code: "VALIDATION_ERROR".to_string(),
                message: msg,
                details: None,
            },
            _ => ErrorResponse {
                code: "INTERNAL_ERROR".to_string(),
                message: error.to_string(),
                details: None,
            },
        }
    }
}

/// Result型のエイリアス
pub type AppResult<T> = Result<T, AppError>;
```

---

## フロントエンドエラーハンドリング

### エラーハンドラー

**ファイル**: `src/utils/errorHandler.ts`

```typescript
export interface ErrorResponse {
  code: string;
  message: string;
  details?: string;
}

export class APIError extends Error {
  code: string;
  details?: string;

  constructor(response: ErrorResponse) {
    super(response.message);
    this.name = 'APIError';
    this.code = response.code;
    this.details = response.details;
  }
}

/**
 * Tauriエラーをパース
 */
export function parseAPIError(error: unknown): APIError {
  if (typeof error === 'string') {
    try {
      const parsed = JSON.parse(error) as ErrorResponse;
      return new APIError(parsed);
    } catch {
      return new APIError({
        code: 'UNKNOWN_ERROR',
        message: error,
      });
    }
  }

  return new APIError({
    code: 'UNKNOWN_ERROR',
    message: '予期しないエラーが発生しました',
  });
}

/**
 * ユーザーフレンドリーなエラーメッセージを取得
 */
export function getUserFriendlyErrorMessage(error: unknown): string {
  if (error instanceof APIError) {
    switch (error.code) {
      case 'CONNECTION_NOT_FOUND':
        return '指定された接続が見つかりませんでした';
      case 'VALIDATION_ERROR':
        return error.message;
      case 'CONNECTION_ALREADY_EXISTS':
        return 'この接続は既に存在します';
      default:
        return error.message;
    }
  }

  return '予期しないエラーが発生しました';
}
```

---

## 型安全性の確保

### TypeScript型定義の自動生成

**ファイル**: `scripts/generate-types.ts`

```typescript
/**
 * RustのserdeデータモデルからTypeScript型定義を生成するスクリプト
 *
 * 使用方法:
 * npm run generate-types
 */

import { spawn } from 'child_process';
import { writeFileSync } from 'fs';

// ts-rsを使用してRustの型をTypeScriptに変換
const generateTypes = async () => {
  console.log('Generating TypeScript types from Rust...');

  // cargo build でRust側の型定義を出力
  const cargoProcess = spawn('cargo', ['build', '--features', 'typescript'], {
    cwd: './src-tauri',
  });

  cargoProcess.stdout.on('data', (data) => {
    console.log(data.toString());
  });

  cargoProcess.stderr.on('data', (data) => {
    console.error(data.toString());
  });

  cargoProcess.on('close', (code) => {
    if (code === 0) {
      console.log('✅ Type generation complete');
    } else {
      console.error('❌ Type generation failed');
      process.exit(1);
    }
  });
};

generateTypes();
```

### Rust型定義にTypeScript出力を追加

```rust
use serde::{Deserialize, Serialize};
use ts_rs::TS;

#[derive(Debug, Clone, Serialize, Deserialize, TS)]
#[ts(export, export_to = "../src/types/generated/")]
pub struct Connection {
    pub id: String,
    pub name: String,
    // ... 他のフィールド
}
```

---

## ログ出力

### フロントエンド

**ファイル**: `src/utils/logger.ts`

```typescript
import { info, error, warn, debug } from '@tauri-apps/plugin-log';

export class Logger {
  static info(message: string, data?: unknown) {
    console.info(message, data);
    info(`[Frontend] ${message} ${data ? JSON.stringify(data) : ''}`);
  }

  static error(message: string, error?: unknown) {
    console.error(message, error);
    error(`[Frontend] ${message} ${error ? JSON.stringify(error) : ''}`);
  }

  static warn(message: string, data?: unknown) {
    console.warn(message, data);
    warn(`[Frontend] ${message} ${data ? JSON.stringify(data) : ''}`);
  }

  static debug(message: string, data?: unknown) {
    console.debug(message, data);
    debug(`[Frontend] ${message} ${data ? JSON.stringify(data) : ''}`);
  }
}
```

### バックエンド

```rust
use log::{info, error, warn, debug};

pub fn log_command_execution(command_name: &str, success: bool) {
    if success {
        info!("Command executed successfully: {}", command_name);
    } else {
        error!("Command execution failed: {}", command_name);
    }
}
```

---

## テスト

### IPCモック (フロントエンド)

**ファイル**: `src/mocks/tauri.ts`

```typescript
import { vi } from 'vitest';
import type { Connection } from '@/stores/types';

export const mockConnections: Connection[] = [
  {
    id: '1',
    name: 'Test DB',
    environment: 'development',
    themeColor: '#4CAF50',
    host: 'localhost',
    port: 5432,
    database: 'testdb',
    username: 'testuser',
    dbType: 'postgresql',
    ssl: false,
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z',
  },
];

export const mockInvoke = vi.fn((command: string, args?: any) => {
  switch (command) {
    case 'get_connections':
      return Promise.resolve(mockConnections);

    case 'get_connection':
      const found = mockConnections.find((c) => c.id === args.id);
      return Promise.resolve(found || null);

    case 'create_connection':
      return Promise.resolve(args.connection);

    case 'update_connection':
      return Promise.resolve(args.connection);

    case 'delete_connection':
      return Promise.resolve();

    default:
      return Promise.reject(new Error(`Unknown command: ${command}`));
  }
});

// Tauri APIのモック
vi.mock('@tauri-apps/api/core', () => ({
  invoke: mockInvoke,
}));
```

---

## セキュリティ考慮事項

### コマンド認証
- すべてのコマンドは認証済みのウィンドウからのみ実行可能
- Tauri設定で許可リストを定義

### データバリデーション
- フロントエンド、バックエンド両方でバリデーション
- SQL インジェクション対策

### エラーメッセージ
- 機密情報を含まないエラーメッセージ
- スタックトレースは開発環境のみ

---

## パフォーマンス最適化

### バッチ処理
```typescript
/**
 * 複数の接続を一括取得
 */
static async getMany(ids: string[]): Promise<Connection[]> {
  return await invoke<Connection[]>('get_connections_batch', { ids });
}
```

### キャッシュ
- Pinia Store でフロントエンドキャッシュ
- 不要な通信を削減

---

## 実装チェックリスト

- [ ] `src/api/connection.ts` の作成
- [ ] `src-tauri/src/commands/connection.rs` の完成
- [ ] エラーハンドリングの実装
- [ ] ログ出力の実装
- [ ] モックの作成
- [ ] ユニットテストの作成
- [ ] 統合テストの作成
- [ ] ドキュメントの作成

---

## トラブルシューティング

### デバッグ方法
1. **フロントエンド**: ブラウザDevToolsでコンソール確認
2. **バックエンド**: ログファイル確認 (`~/.local/share/sql-editor/logs/`)
3. **IPC通信**: Tauri devtools で通信ログ確認

### よくある問題
- **型不一致**: TypeScript型とRust型の同期を確認
- **タイムアウト**: 重い処理は非同期で実装
- **メモリリーク**: イベントリスナーの適切なクリーンアップ
