# 1.2.3 マスターキー管理設計書

## 概要

データベースパスワードの暗号化に使用するマスターキーを安全に管理するシステムを実装します。OSのキーチェーン機能を活用し、セキュアなキー保存を実現します。

## 目的

- マスターキーの安全な生成・保存・取得
- OSネイティブのキーチェーン（Keychain/Credential Manager/Secret Service）との連携
- 初回起動時のマスターキー生成
- アプリケーション実行中のキーキャッシング

## セキュリティ要件

1. **キー保存**
   - OSのセキュアストレージに保存（平文ファイルには保存しない）
   - Windows: Windows Credential Manager
   - macOS: Keychain
   - Linux: Secret Service API (libsecret)

2. **キーアクセス**
   - アプリケーションプロセスからのみアクセス可能
   - 他のアプリケーションからの分離
   - ユーザー認証との連携（OS設定に依存）

3. **キー生成**
   - 暗号学的に安全な乱数生成器（CSPRNG）を使用
   - 256ビット（32バイト）のランダムキー

## アーキテクチャ

### モジュール構成

```
src-tauri/src/
├── crypto/
│   ├── master_key/
│   │   ├── mod.rs              # マスターキーモジュールのエントリポイント
│   │   ├── manager.rs          # マスターキー管理
│   │   ├── keychain.rs         # OSキーチェーン連携
│   │   ├── cache.rs            # キーキャッシング
│   │   └── error.rs            # エラー型定義
```

### 責務

1. **マスターキーマネージャー (`manager.rs`)**
   - マスターキーのライフサイクル管理
   - 初期化・取得・削除
   - キャッシュとの連携

2. **キーチェーン連携 (`keychain.rs`)**
   - OSネイティブのキーチェーンへのアクセス
   - プラットフォーム固有の実装

3. **キャッシュ (`cache.rs`)**
   - メモリ内キーキャッシュ
   - タイムアウト管理
   - セキュアなメモリクリア

## データモデル

### キーチェーンエントリ

```rust
/// キーチェーンに保存するエントリの識別情報
pub struct KeychainEntry {
    /// サービス名（アプリケーション識別子）
    service: String,

    /// ユーザー名（キーの種類を識別）
    username: String,
}

impl KeychainEntry {
    /// マスターキー用のエントリを作成
    pub fn master_key() -> Self {
        Self {
            service: "sql-query-builder".to_string(),
            username: "master-encryption-key".to_string(),
        }
    }
}
```

### マスターキー型

```rust
use zeroize::Zeroize;

/// マスターキーを安全に保持する構造体
#[derive(Zeroize)]
#[zeroize(drop)]
pub struct MasterKey {
    /// 32バイトのキーデータ
    key: [u8; 32],
}

impl MasterKey {
    /// 新しいランダムなマスターキーを生成
    pub fn generate() -> Self {
        use rand::RngCore;
        let mut key = [0u8; 32];
        rand::thread_rng().fill_bytes(&mut key);
        Self { key }
    }

    /// バイト配列からマスターキーを作成
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, MasterKeyError> {
        if bytes.len() != 32 {
            return Err(MasterKeyError::InvalidKeyLength);
        }
        let mut key = [0u8; 32];
        key.copy_from_slice(bytes);
        Ok(Self { key })
    }

    /// キーのバイト表現を取得
    pub fn as_bytes(&self) -> &[u8] {
        &self.key
    }

    /// Base64エンコードされた文字列として取得
    pub fn to_base64(&self) -> String {
        base64::encode(&self.key)
    }

    /// Base64文字列からマスターキーを作成
    pub fn from_base64(encoded: &str) -> Result<Self, MasterKeyError> {
        let bytes = base64::decode(encoded)?;
        Self::from_bytes(&bytes)
    }
}
```

## キーチェーン実装

### Keychainトレイト

```rust
/// OSのキーチェーンとのインターフェース
pub trait Keychain: Send + Sync {
    /// キーを保存
    fn store_key(&self, entry: &KeychainEntry, key: &MasterKey) -> Result<(), MasterKeyError>;

    /// キーを取得
    fn retrieve_key(&self, entry: &KeychainEntry) -> Result<MasterKey, MasterKeyError>;

    /// キーを削除
    fn delete_key(&self, entry: &KeychainEntry) -> Result<(), MasterKeyError>;

    /// キーが存在するかチェック
    fn exists(&self, entry: &KeychainEntry) -> bool;
}
```

### OSキーチェーン実装

```rust
use keyring::Entry;

/// keyring crateを使用したクロスプラットフォーム実装
pub struct OsKeychain;

impl Keychain for OsKeychain {
    fn store_key(&self, entry: &KeychainEntry, key: &MasterKey) -> Result<(), MasterKeyError> {
        let keyring_entry = Entry::new(&entry.service, &entry.username)?;

        // Base64エンコードして文字列として保存
        keyring_entry.set_password(&key.to_base64())?;

        Ok(())
    }

    fn retrieve_key(&self, entry: &KeychainEntry) -> Result<MasterKey, MasterKeyError> {
        let keyring_entry = Entry::new(&entry.service, &entry.username)?;

        let password = keyring_entry.get_password()?;

        MasterKey::from_base64(&password)
    }

    fn delete_key(&self, entry: &KeychainEntry) -> Result<(), MasterKeyError> {
        let keyring_entry = Entry::new(&entry.service, &entry.username)?;

        keyring_entry.delete_password()?;

        Ok(())
    }

    fn exists(&self, entry: &KeychainEntry) -> bool {
        let keyring_entry = match Entry::new(&entry.service, &entry.username) {
            Ok(entry) => entry,
            Err(_) => return false,
        };

        keyring_entry.get_password().is_ok()
    }
}
```

## マスターキーマネージャー実装

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

/// マスターキーを管理する構造体
pub struct MasterKeyManager {
    /// キーチェーン実装
    keychain: Arc<dyn Keychain>,

    /// メモリキャッシュ
    cache: Arc<RwLock<Option<MasterKey>>>,

    /// キーチェーンエントリ
    entry: KeychainEntry,
}

impl MasterKeyManager {
    /// 新しいマネージャーインスタンスを作成
    pub fn new() -> Self {
        Self {
            keychain: Arc::new(OsKeychain),
            cache: Arc::new(RwLock::new(None)),
            entry: KeychainEntry::master_key(),
        }
    }

    /// カスタムキーチェーン実装を使用してマネージャーを作成（テスト用）
    pub fn with_keychain(keychain: Arc<dyn Keychain>) -> Self {
        Self {
            keychain,
            cache: Arc::new(RwLock::new(None)),
            entry: KeychainEntry::master_key(),
        }
    }

    /// マスターキーを初期化（初回起動時）
    pub async fn initialize(&self) -> Result<(), MasterKeyError> {
        // 既にキーが存在する場合はエラー
        if self.keychain.exists(&self.entry) {
            return Err(MasterKeyError::AlreadyInitialized);
        }

        // 新しいマスターキーを生成
        let master_key = MasterKey::generate();

        // キーチェーンに保存
        self.keychain.store_key(&self.entry, &master_key)?;

        // キャッシュに保存
        let mut cache = self.cache.write().await;
        *cache = Some(master_key);

        Ok(())
    }

    /// マスターキーが初期化済みかチェック
    pub fn is_initialized(&self) -> bool {
        self.keychain.exists(&self.entry)
    }

    /// マスターキーを取得
    pub async fn get_master_key(&self) -> Result<Vec<u8>, MasterKeyError> {
        // キャッシュをチェック
        {
            let cache = self.cache.read().await;
            if let Some(ref key) = *cache {
                return Ok(key.as_bytes().to_vec());
            }
        }

        // キャッシュにない場合はキーチェーンから取得
        let key = self.keychain.retrieve_key(&self.entry)?;

        // キャッシュに保存
        let key_bytes = key.as_bytes().to_vec();
        {
            let mut cache = self.cache.write().await;
            *cache = Some(key);
        }

        Ok(key_bytes)
    }

    /// キャッシュをクリア
    pub async fn clear_cache(&self) {
        let mut cache = self.cache.write().await;
        *cache = None;
    }

    /// マスターキーを削除（リセット機能）
    pub async fn delete_master_key(&self) -> Result<(), MasterKeyError> {
        // キーチェーンから削除
        self.keychain.delete_key(&self.entry)?;

        // キャッシュもクリア
        self.clear_cache().await;

        Ok(())
    }

    /// マスターキーを再生成（パスワードリセット時など）
    pub async fn regenerate(&self) -> Result<(), MasterKeyError> {
        // 既存のキーを削除
        self.delete_master_key().await?;

        // 新しいキーで初期化
        self.initialize().await?;

        Ok(())
    }
}
```

## エラー型定義

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MasterKeyError {
    #[error("マスターキーが既に初期化されています")]
    AlreadyInitialized,

    #[error("マスターキーが見つかりません（初期化が必要です）")]
    NotInitialized,

    #[error("キーの長さが不正です")]
    InvalidKeyLength,

    #[error("キーチェーンエラー: {0}")]
    KeychainError(#[from] keyring::Error),

    #[error("Base64デコードエラー: {0}")]
    Base64Error(#[from] base64::DecodeError),

    #[error("キーチェーンへのアクセスが拒否されました")]
    AccessDenied,
}

pub type MasterKeyResult<T> = Result<T, MasterKeyError>;
```

## 必要な依存関係

```toml
[dependencies]
# キーチェーン連携
keyring = "2.0"           # クロスプラットフォームキーチェーンアクセス

# 暗号化・セキュリティ
rand = "0.8"              # 暗号学的に安全な乱数生成
zeroize = "1.6"           # メモリゼロクリア
base64 = "0.21"           # Base64エンコード/デコード

# 非同期処理
tokio = { version = "1.0", features = ["sync"] }

# エラーハンドリング
thiserror = "1.0"
```

## API設計

### Tauriコマンド

```rust
use tauri::State;

/// マスターキーマネージャーの初期化チェック
#[tauri::command]
pub async fn is_master_key_initialized(
    manager: State<'_, MasterKeyManager>,
) -> Result<bool, String> {
    Ok(manager.is_initialized())
}

/// マスターキーを初期化
#[tauri::command]
pub async fn initialize_master_key(
    manager: State<'_, MasterKeyManager>,
) -> Result<(), String> {
    manager
        .initialize()
        .await
        .map_err(|e| e.to_string())
}

/// マスターキーを削除（リセット）
#[tauri::command]
pub async fn delete_master_key(
    manager: State<'_, MasterKeyManager>,
) -> Result<(), String> {
    manager
        .delete_master_key()
        .await
        .map_err(|e| e.to_string())
}

/// マスターキーを再生成
#[tauri::command]
pub async fn regenerate_master_key(
    manager: State<'_, MasterKeyManager>,
) -> Result<(), String> {
    manager
        .regenerate()
        .await
        .map_err(|e| e.to_string())
}
```

## 初期化フロー

### アプリケーション起動時

```rust
use tauri::Manager;

#[tauri::command]
async fn setup_master_key(
    app_handle: tauri::AppHandle,
) -> Result<(), String> {
    let manager = app_handle.state::<MasterKeyManager>();

    if !manager.is_initialized() {
        // 初回起動時: ユーザーに確認してマスターキーを生成
        manager
            .initialize()
            .await
            .map_err(|e| e.to_string())?;

        // フロントエンドに初期化完了を通知
        app_handle
            .emit_all("master-key-initialized", ())
            .map_err(|e| e.to_string())?;
    }

    Ok(())
}
```

### フロントエンド連携

```typescript
// src/composables/useMasterKey.ts
import { invoke } from '@tauri-apps/api/core';
import { listen } from '@tauri-apps/api/event';

export function useMasterKey() {
  const isInitialized = ref(false);

  const checkInitialization = async () => {
    isInitialized.value = await invoke<boolean>('is_master_key_initialized');
  };

  const initialize = async () => {
    await invoke('initialize_master_key');
    isInitialized.value = true;
  };

  const regenerate = async () => {
    if (confirm('全ての暗号化されたパスワードが使用不能になります。続行しますか?')) {
      await invoke('regenerate_master_key');
    }
  };

  // イベントリスナー
  listen('master-key-initialized', () => {
    isInitialized.value = true;
  });

  return {
    isInitialized,
    checkInitialization,
    initialize,
    regenerate,
  };
}
```

## セキュリティ考慮事項

### 1. キーのライフサイクル

```rust
impl Drop for MasterKeyManager {
    fn drop(&mut self) {
        // アプリケーション終了時にキャッシュをクリア
        // (非同期処理はここでは使えないため、ブロッキング処理)
        if let Some(cache) = Arc::get_mut(&mut self.cache) {
            if let Ok(mut cache) = cache.try_write() {
                *cache = None;
            }
        }
    }
}
```

### 2. キーチェーンアクセス制限

```rust
impl OsKeychain {
    /// アプリケーション固有のアクセスコントロール設定
    #[cfg(target_os = "macos")]
    fn set_access_control() -> Result<(), MasterKeyError> {
        // macOSの場合、Keychainアクセスグループを設定
        // アプリケーション署名と紐付け
        todo!("Implement macOS Keychain access control")
    }

    #[cfg(target_os = "windows")]
    fn set_access_control() -> Result<(), MasterKeyError> {
        // Windowsの場合、Credential Managerのpersistenceを設定
        // ユーザーログオンセッションに限定
        todo!("Implement Windows Credential Manager access control")
    }
}
```

### 3. マイグレーション時のキー移行

```rust
impl MasterKeyManager {
    /// 旧バージョンからマスターキーを移行
    pub async fn migrate_from_legacy(&self, legacy_path: &Path) -> Result<(), MasterKeyError> {
        // 旧バージョンのファイルベースキーを読み込み
        let legacy_key = std::fs::read(legacy_path)
            .map_err(|_| MasterKeyError::NotInitialized)?;

        let master_key = MasterKey::from_bytes(&legacy_key)?;

        // 新しいキーチェーンに保存
        self.keychain.store_key(&self.entry, &master_key)?;

        // 旧ファイルを安全に削除
        secure_delete(legacy_path)?;

        Ok(())
    }
}

/// ファイルを安全に削除（上書き後削除）
fn secure_delete(path: &Path) -> std::io::Result<()> {
    use rand::RngCore;

    let metadata = std::fs::metadata(path)?;
    let size = metadata.len() as usize;

    // ランダムデータで上書き（3回）
    for _ in 0..3 {
        let mut random_data = vec![0u8; size];
        rand::thread_rng().fill_bytes(&mut random_data);
        std::fs::write(path, &random_data)?;
    }

    // ファイル削除
    std::fs::remove_file(path)?;

    Ok(())
}
```

## テスト方針

### ユニットテスト

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    use std::sync::Mutex;

    /// テスト用のインメモリキーチェーン
    struct MockKeychain {
        storage: Mutex<HashMap<String, String>>,
    }

    impl MockKeychain {
        fn new() -> Self {
            Self {
                storage: Mutex::new(HashMap::new()),
            }
        }

        fn key(&self, entry: &KeychainEntry) -> String {
            format!("{}:{}", entry.service, entry.username)
        }
    }

    impl Keychain for MockKeychain {
        fn store_key(&self, entry: &KeychainEntry, key: &MasterKey) -> Result<(), MasterKeyError> {
            let mut storage = self.storage.lock().unwrap();
            storage.insert(self.key(entry), key.to_base64());
            Ok(())
        }

        fn retrieve_key(&self, entry: &KeychainEntry) -> Result<MasterKey, MasterKeyError> {
            let storage = self.storage.lock().unwrap();
            let encoded = storage
                .get(&self.key(entry))
                .ok_or(MasterKeyError::NotInitialized)?;
            MasterKey::from_base64(encoded)
        }

        fn delete_key(&self, entry: &KeychainEntry) -> Result<(), MasterKeyError> {
            let mut storage = self.storage.lock().unwrap();
            storage.remove(&self.key(entry));
            Ok(())
        }

        fn exists(&self, entry: &KeychainEntry) -> bool {
            let storage = self.storage.lock().unwrap();
            storage.contains_key(&self.key(entry))
        }
    }

    #[tokio::test]
    async fn test_initialize_master_key() {
        let manager = MasterKeyManager::with_keychain(Arc::new(MockKeychain::new()));

        assert!(!manager.is_initialized());

        manager.initialize().await.unwrap();

        assert!(manager.is_initialized());
    }

    #[tokio::test]
    async fn test_get_master_key() {
        let manager = MasterKeyManager::with_keychain(Arc::new(MockKeychain::new()));

        manager.initialize().await.unwrap();

        let key1 = manager.get_master_key().await.unwrap();
        let key2 = manager.get_master_key().await.unwrap();

        // 同じキーが返されることを確認
        assert_eq!(key1, key2);
        assert_eq!(key1.len(), 32);
    }

    #[tokio::test]
    async fn test_cache_works() {
        let keychain = Arc::new(MockKeychain::new());
        let manager = MasterKeyManager::with_keychain(keychain.clone());

        manager.initialize().await.unwrap();

        // 1回目の取得（キーチェーンから）
        let key1 = manager.get_master_key().await.unwrap();

        // 2回目の取得（キャッシュから）
        let key2 = manager.get_master_key().await.unwrap();

        assert_eq!(key1, key2);
    }

    #[tokio::test]
    async fn test_clear_cache() {
        let manager = MasterKeyManager::with_keychain(Arc::new(MockKeychain::new()));

        manager.initialize().await.unwrap();
        let _key1 = manager.get_master_key().await.unwrap();

        manager.clear_cache().await;

        // キャッシュクリア後も取得可能
        let key2 = manager.get_master_key().await.unwrap();
        assert_eq!(key2.len(), 32);
    }

    #[tokio::test]
    async fn test_delete_master_key() {
        let manager = MasterKeyManager::with_keychain(Arc::new(MockKeychain::new()));

        manager.initialize().await.unwrap();
        assert!(manager.is_initialized());

        manager.delete_master_key().await.unwrap();
        assert!(!manager.is_initialized());
    }

    #[tokio::test]
    async fn test_regenerate() {
        let manager = MasterKeyManager::with_keychain(Arc::new(MockKeychain::new()));

        manager.initialize().await.unwrap();
        let key1 = manager.get_master_key().await.unwrap();

        manager.regenerate().await.unwrap();
        let key2 = manager.get_master_key().await.unwrap();

        // 異なるキーが生成されることを確認
        assert_ne!(key1, key2);
    }

    #[tokio::test]
    async fn test_double_initialization_fails() {
        let manager = MasterKeyManager::with_keychain(Arc::new(MockKeychain::new()));

        manager.initialize().await.unwrap();

        let result = manager.initialize().await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), MasterKeyError::AlreadyInitialized));
    }
}
```

## 完了条件

- [x] 設計書作成完了
- [ ] マスターキーの生成が正常に動作する
- [ ] OSキーチェーンへの保存・取得が動作する
- [ ] 全OS（Windows/macOS/Linux）でキーチェーン連携が動作する
- [ ] キャッシュ機能が正常に動作する
- [ ] 初期化フローが正常に動作する
- [ ] ユニットテストが全てパスする
- [ ] セキュアなメモリクリアが動作する

## 参考資料

- [keyring crate](https://docs.rs/keyring/)
- [macOS Keychain Services](https://developer.apple.com/documentation/security/keychain_services)
- [Windows Credential Manager](https://docs.microsoft.com/en-us/windows/win32/secauthn/credential-manager)
- [Secret Service API (Linux)](https://specifications.freedesktop.org/secret-service/)
