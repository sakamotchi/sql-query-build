# 1.2.5 データ永続化層のテスト戦略設計書

## 概要

データ永続化層（ファイルストレージ、暗号化ユーティリティ、マスターキー管理、接続情報データモデル）の品質を保証するための包括的なテスト戦略を定義します。

## 目的

- 高品質なデータ永続化層の実現
- リグレッション防止
- セキュリティ脆弱性の早期発見
- 保守性の向上

## テスト方針

### 品質目標

| 指標 | 目標値 | 測定方法 |
|------|--------|----------|
| コードカバレッジ | 80%以上 | cargo-tarpaulin |
| ユニットテスト成功率 | 100% | cargo test |
| 統合テスト成功率 | 100% | cargo test --test |
| セキュリティテスト | 重大な脆弱性ゼロ | 手動監査 + cargo-audit |

### テストレベル

```
┌─────────────────────────────────────┐
│    E2E テスト（Tauri統合）         │  ← フェーズ1.8で実施
├─────────────────────────────────────┤
│    統合テスト                       │  ← このフェーズで実施
├─────────────────────────────────────┤
│    ユニットテスト                   │  ← このフェーズで実施
└─────────────────────────────────────┘
```

## テストケース設計

### 1. ファイルストレージモジュール (1.2.1)

#### ユニットテスト

```rust
// src-tauri/src/storage/file_storage.rs

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    /// テスト用のデータ構造
    #[derive(Serialize, Deserialize, PartialEq, Debug)]
    struct TestData {
        name: String,
        value: i32,
    }

    #[test]
    fn test_write_and_read_success() {
        // 準備
        let temp_dir = TempDir::new().unwrap();
        let storage = FileStorage::new(temp_dir.path().to_path_buf()).unwrap();
        let data = TestData {
            name: "test".to_string(),
            value: 42,
        };

        // 実行: 書き込み
        let result = storage.write("test_key", &data);

        // 検証: 書き込み成功
        assert!(result.is_ok());

        // 実行: 読み込み
        let read_data: TestData = storage.read("test_key").unwrap();

        // 検証: データが一致
        assert_eq!(data, read_data);
    }

    #[test]
    fn test_read_nonexistent_file() {
        let temp_dir = TempDir::new().unwrap();
        let storage = FileStorage::new(temp_dir.path().to_path_buf()).unwrap();

        // 存在しないキーの読み込み
        let result: StorageResult<TestData> = storage.read("nonexistent");

        // エラーが返されることを確認
        assert!(result.is_err());
    }

    #[test]
    fn test_delete_existing_file() {
        let temp_dir = TempDir::new().unwrap();
        let storage = FileStorage::new(temp_dir.path().to_path_buf()).unwrap();
        let data = TestData {
            name: "test".to_string(),
            value: 42,
        };

        // データを書き込み
        storage.write("test_key", &data).unwrap();
        assert!(storage.exists("test_key"));

        // 削除
        let result = storage.delete("test_key");

        // 検証
        assert!(result.is_ok());
        assert!(!storage.exists("test_key"));
    }

    #[test]
    fn test_list_keys() {
        let temp_dir = TempDir::new().unwrap();
        let storage = FileStorage::new(temp_dir.path().to_path_buf()).unwrap();
        let data = TestData {
            name: "test".to_string(),
            value: 42,
        };

        // 複数のキーでデータを書き込み
        storage.write("key1", &data).unwrap();
        storage.write("key2", &data).unwrap();
        storage.write("key3", &data).unwrap();

        // キー一覧を取得
        let keys = storage.list_keys().unwrap();

        // 検証
        assert_eq!(keys.len(), 3);
        assert!(keys.contains(&"key1".to_string()));
        assert!(keys.contains(&"key2".to_string()));
        assert!(keys.contains(&"key3".to_string()));
    }

    #[test]
    fn test_concurrent_access() {
        use std::sync::Arc;
        use std::thread;

        let temp_dir = TempDir::new().unwrap();
        let storage = Arc::new(FileStorage::new(temp_dir.path().to_path_buf()).unwrap());

        // 複数スレッドから同時アクセス
        let handles: Vec<_> = (0..10)
            .map(|i| {
                let storage = Arc::clone(&storage);
                thread::spawn(move || {
                    let data = TestData {
                        name: format!("thread_{}", i),
                        value: i,
                    };
                    storage.write(&format!("key_{}", i), &data).unwrap();
                })
            })
            .collect();

        // 全スレッドの完了を待つ
        for handle in handles {
            handle.join().unwrap();
        }

        // 全てのキーが存在することを確認
        let keys = storage.list_keys().unwrap();
        assert_eq!(keys.len(), 10);
    }

    #[test]
    fn test_path_traversal_protection() {
        let temp_dir = TempDir::new().unwrap();
        let storage = FileStorage::new(temp_dir.path().to_path_buf()).unwrap();
        let data = TestData {
            name: "test".to_string(),
            value: 42,
        };

        // パストラバーサル攻撃を試みる
        let malicious_keys = vec!["../../../etc/passwd", "..\\..\\windows\\system32"];

        for key in malicious_keys {
            let result = storage.write(key, &data);
            // セキュリティ上、拒否されるべき
            assert!(result.is_err() || {
                // または、ベースディレクトリ内に安全に保存される
                let path = temp_dir.path().join(format!("{}.json", key));
                path.starts_with(temp_dir.path())
            });
        }
    }
}
```

#### テストケース一覧

| ID | テストケース名 | 目的 | 優先度 |
|----|--------------|------|--------|
| FS-001 | 正常な書き込み・読み込み | 基本機能の動作確認 | 高 |
| FS-002 | 存在しないファイルの読み込み | エラーハンドリング | 高 |
| FS-003 | ファイルの削除 | 削除機能の動作確認 | 高 |
| FS-004 | キー一覧取得 | リスト機能の動作確認 | 中 |
| FS-005 | 並行アクセス | 排他制御の検証 | 高 |
| FS-006 | パストラバーサル攻撃 | セキュリティ検証 | 高 |
| FS-007 | 大きなデータの書き込み | パフォーマンス検証 | 中 |
| FS-008 | JSONシリアライズエラー | エラーハンドリング | 中 |
| FS-009 | ディスク容量不足 | エラーハンドリング | 低 |

### 2. 暗号化ユーティリティ (1.2.2)

#### ユニットテスト

```rust
// src-tauri/src/crypto/encryption.rs

#[cfg(test)]
mod tests {
    use super::*;

    const TEST_MASTER_KEY: &[u8; 32] = b"test-master-key-32-bytes-long!!!";

    #[test]
    fn test_encrypt_decrypt_roundtrip() {
        let encryptor = AesGcmEncryptor::new();
        let plaintext = b"my secret password";

        // 暗号化
        let encrypted = encryptor.encrypt(plaintext, TEST_MASTER_KEY).unwrap();

        // 復号化
        let decrypted = encryptor.decrypt(&encrypted, TEST_MASTER_KEY).unwrap();

        // 検証
        assert_eq!(plaintext.as_slice(), decrypted.as_slice());
    }

    #[test]
    fn test_wrong_key_fails_decryption() {
        let encryptor = AesGcmEncryptor::new();
        let plaintext = b"my secret password";
        let wrong_key = b"wrong-key-32-bytes-long!!!!!!!!!";

        // 正しいキーで暗号化
        let encrypted = encryptor.encrypt(plaintext, TEST_MASTER_KEY).unwrap();

        // 間違ったキーで復号化を試みる
        let result = encryptor.decrypt(&encrypted, wrong_key);

        // 失敗することを確認
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), CryptoError::DecryptionFailed));
    }

    #[test]
    fn test_nonce_uniqueness() {
        let encryptor = AesGcmEncryptor::new();
        let plaintext = b"same plaintext";

        // 同じ平文を複数回暗号化
        let encrypted1 = encryptor.encrypt(plaintext, TEST_MASTER_KEY).unwrap();
        let encrypted2 = encryptor.encrypt(plaintext, TEST_MASTER_KEY).unwrap();

        // ノンスと暗号文が異なることを確認
        assert_ne!(encrypted1.nonce, encrypted2.nonce);
        assert_ne!(encrypted1.ciphertext, encrypted2.ciphertext);

        // どちらも正しく復号化できることを確認
        let decrypted1 = encryptor.decrypt(&encrypted1, TEST_MASTER_KEY).unwrap();
        let decrypted2 = encryptor.decrypt(&encrypted2, TEST_MASTER_KEY).unwrap();
        assert_eq!(decrypted1, decrypted2);
    }

    #[test]
    fn test_tampered_ciphertext_fails() {
        let encryptor = AesGcmEncryptor::new();
        let plaintext = b"my secret password";

        let mut encrypted = encryptor.encrypt(plaintext, TEST_MASTER_KEY).unwrap();

        // 暗号文を改ざん
        if let Some(byte) = encrypted.ciphertext.first_mut() {
            *byte ^= 0xFF;
        }

        // 復号化は失敗すべき（認証タグ検証失敗）
        let result = encryptor.decrypt(&encrypted, TEST_MASTER_KEY);
        assert!(result.is_err());
    }

    #[test]
    fn test_base64_encoding() {
        let encryptor = AesGcmEncryptor::new();
        let plaintext = b"test data";

        let encrypted = encryptor.encrypt(plaintext, TEST_MASTER_KEY).unwrap();

        // Base64エンコード
        let encoded = encrypted.to_base64().unwrap();

        // Base64文字列であることを確認
        assert!(base64::decode(&encoded).is_ok());

        // デコードして復号化
        let decoded = EncryptedData::from_base64(&encoded).unwrap();
        let decrypted = encryptor.decrypt(&decoded, TEST_MASTER_KEY).unwrap();

        assert_eq!(plaintext.as_slice(), decrypted.as_slice());
    }

    #[test]
    fn test_string_encryption_helpers() {
        let plaintext = "my secret password";

        // 暗号化
        let encrypted = encrypt_string(plaintext, TEST_MASTER_KEY).unwrap();

        // 復号化
        let decrypted = decrypt_string(&encrypted, TEST_MASTER_KEY).unwrap();

        assert_eq!(plaintext, decrypted);
    }

    #[test]
    fn test_encryption_performance() {
        use std::time::Instant;

        let encryptor = AesGcmEncryptor::new();
        let plaintext = b"performance test data";

        let start = Instant::now();

        // 1000回暗号化
        for _ in 0..1000 {
            let _ = encryptor.encrypt(plaintext, TEST_MASTER_KEY).unwrap();
        }

        let duration = start.elapsed();

        // 1000回で1秒以内に完了することを確認
        assert!(duration.as_secs() < 1);
    }

    #[test]
    fn test_key_derivation_consistency() {
        let encryptor = AesGcmEncryptor::new();
        let plaintext = b"test";
        let salt = [0x42u8; 32];

        // 同じソルトとマスターキーから導出されるキーは常に同じ
        let encrypted1 = {
            let mut enc = encryptor.encrypt(plaintext, TEST_MASTER_KEY).unwrap();
            enc.salt = salt.to_vec();
            enc
        };

        let encrypted2 = {
            let mut enc = encryptor.encrypt(plaintext, TEST_MASTER_KEY).unwrap();
            enc.salt = salt.to_vec();
            enc
        };

        // ソルトが同じなら導出されるキーも同じはず
        assert_eq!(encrypted1.salt, encrypted2.salt);
    }
}
```

#### テストケース一覧

| ID | テストケース名 | 目的 | 優先度 |
|----|--------------|------|--------|
| CR-001 | 暗号化・復号化ラウンドトリップ | 基本機能の動作確認 | 高 |
| CR-002 | 間違ったキーでの復号化失敗 | セキュリティ検証 | 高 |
| CR-003 | ノンスの一意性 | セキュリティ検証 | 高 |
| CR-004 | 改ざん検知 | セキュリティ検証 | 高 |
| CR-005 | Base64エンコーディング | データ変換の正当性 | 高 |
| CR-006 | 文字列暗号化ヘルパー | 利便性関数の動作確認 | 中 |
| CR-007 | 暗号化パフォーマンス | 性能要件の確認 | 中 |
| CR-008 | キー導出の一貫性 | PBKDF2の動作確認 | 中 |
| CR-009 | 長いデータの暗号化 | 境界値テスト | 低 |
| CR-010 | 空データの暗号化 | エッジケース | 低 |

### 3. マスターキー管理 (1.2.3)

#### ユニットテスト

```rust
// src-tauri/src/crypto/master_key/manager.rs

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    use std::sync::Mutex;

    // モックキーチェーン（テスト用）
    struct MockKeychain {
        storage: Mutex<HashMap<String, String>>,
    }

    impl MockKeychain {
        fn new() -> Self {
            Self {
                storage: Mutex::new(HashMap::new()),
            }
        }

        fn key(&self, entry: &KeychainEntry) -> String {
            format!("{}:{}", entry.service, entry.username)
        }
    }

    impl Keychain for MockKeychain {
        fn store_key(&self, entry: &KeychainEntry, key: &MasterKey) -> Result<(), MasterKeyError> {
            let mut storage = self.storage.lock().unwrap();
            storage.insert(self.key(entry), key.to_base64());
            Ok(())
        }

        fn retrieve_key(&self, entry: &KeychainEntry) -> Result<MasterKey, MasterKeyError> {
            let storage = self.storage.lock().unwrap();
            let encoded = storage
                .get(&self.key(entry))
                .ok_or(MasterKeyError::NotInitialized)?;
            MasterKey::from_base64(encoded)
        }

        fn delete_key(&self, entry: &KeychainEntry) -> Result<(), MasterKeyError> {
            let mut storage = self.storage.lock().unwrap();
            storage.remove(&self.key(entry));
            Ok(())
        }

        fn exists(&self, entry: &KeychainEntry) -> bool {
            let storage = self.storage.lock().unwrap();
            storage.contains_key(&self.key(entry))
        }
    }

    #[tokio::test]
    async fn test_initialize_master_key() {
        let manager = MasterKeyManager::with_keychain(Arc::new(MockKeychain::new()));

        assert!(!manager.is_initialized());

        manager.initialize().await.unwrap();

        assert!(manager.is_initialized());
    }

    #[tokio::test]
    async fn test_double_initialization_fails() {
        let manager = MasterKeyManager::with_keychain(Arc::new(MockKeychain::new()));

        manager.initialize().await.unwrap();

        let result = manager.initialize().await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_get_master_key() {
        let manager = MasterKeyManager::with_keychain(Arc::new(MockKeychain::new()));

        manager.initialize().await.unwrap();

        let key = manager.get_master_key().await.unwrap();

        assert_eq!(key.len(), 32);
    }

    #[tokio::test]
    async fn test_key_consistency() {
        let manager = MasterKeyManager::with_keychain(Arc::new(MockKeychain::new()));

        manager.initialize().await.unwrap();

        let key1 = manager.get_master_key().await.unwrap();
        let key2 = manager.get_master_key().await.unwrap();

        assert_eq!(key1, key2);
    }

    #[tokio::test]
    async fn test_cache_works() {
        let keychain = Arc::new(MockKeychain::new());
        let manager = MasterKeyManager::with_keychain(keychain.clone());

        manager.initialize().await.unwrap();

        // 1回目の取得（キーチェーンから）
        let key1 = manager.get_master_key().await.unwrap();

        // キーチェーンをクリアしても、キャッシュから取得できる
        {
            let mut storage = keychain.storage.lock().unwrap();
            storage.clear();
        }

        // 2回目の取得（キャッシュから）
        let key2 = manager.get_master_key().await.unwrap();

        assert_eq!(key1, key2);
    }

    #[tokio::test]
    async fn test_delete_master_key() {
        let manager = MasterKeyManager::with_keychain(Arc::new(MockKeychain::new()));

        manager.initialize().await.unwrap();
        assert!(manager.is_initialized());

        manager.delete_master_key().await.unwrap();

        assert!(!manager.is_initialized());
    }

    #[tokio::test]
    async fn test_regenerate() {
        let manager = MasterKeyManager::with_keychain(Arc::new(MockKeychain::new()));

        manager.initialize().await.unwrap();
        let key1 = manager.get_master_key().await.unwrap();

        manager.regenerate().await.unwrap();
        let key2 = manager.get_master_key().await.unwrap();

        // 異なるキーが生成されること
        assert_ne!(key1, key2);
    }
}
```

#### テストケース一覧

| ID | テストケース名 | 目的 | 優先度 |
|----|--------------|------|--------|
| MK-001 | マスターキー初期化 | 基本機能の動作確認 | 高 |
| MK-002 | 二重初期化の防止 | エラーハンドリング | 高 |
| MK-003 | マスターキー取得 | 基本機能の動作確認 | 高 |
| MK-004 | キーの一貫性 | データ整合性の確認 | 高 |
| MK-005 | キャッシュ機能 | パフォーマンス最適化の確認 | 中 |
| MK-006 | マスターキー削除 | 削除機能の動作確認 | 中 |
| MK-007 | キー再生成 | 再生成機能の動作確認 | 中 |
| MK-008 | OS統合テスト（Windows） | 実機動作確認 | 高 |
| MK-009 | OS統合テスト（macOS） | 実機動作確認 | 高 |
| MK-010 | OS統合テスト（Linux） | 実機動作確認 | 高 |

### 4. 接続情報データモデル (1.2.4)

#### ユニットテスト

```rust
// src-tauri/src/models/connection.rs

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_postgresql_connection() {
        let config = ConnectionConfig::Network(NetworkConfig {
            host: "localhost".to_string(),
            port: 5432,
            database: "testdb".to_string(),
            username: "testuser".to_string(),
            encrypted_password: None,
            ssl_config: None,
            options: None,
        });

        let connection = ConnectionInfo::new(
            "Test PostgreSQL".to_string(),
            DatabaseType::PostgreSQL,
            config,
        );

        assert_eq!(connection.name, "Test PostgreSQL");
        assert_eq!(connection.database_type, DatabaseType::PostgreSQL);
        assert!(!connection.id.is_empty());
    }

    #[test]
    fn test_connection_validation() {
        let config = ConnectionConfig::Network(NetworkConfig {
            host: "".to_string(), // 無効なホスト
            port: 5432,
            database: "testdb".to_string(),
            username: "testuser".to_string(),
            encrypted_password: None,
            ssl_config: None,
            options: None,
        });

        let connection = ConnectionInfo::new(
            "Test".to_string(),
            DatabaseType::PostgreSQL,
            config,
        );

        let result = connection.validate();
        assert!(result.is_err());
    }

    #[test]
    fn test_connection_string_generation() {
        let config = ConnectionConfig::Network(NetworkConfig {
            host: "localhost".to_string(),
            port: 5432,
            database: "testdb".to_string(),
            username: "testuser".to_string(),
            encrypted_password: None,
            ssl_config: None,
            options: None,
        });

        let connection = ConnectionInfo::new(
            "Test".to_string(),
            DatabaseType::PostgreSQL,
            config,
        );

        let conn_str = connection
            .build_connection_string(Some("password"))
            .unwrap();

        assert!(conn_str.contains("postgresql://"));
        assert!(conn_str.contains("testuser"));
        assert!(conn_str.contains("localhost"));
        assert!(conn_str.contains("5432"));
        assert!(conn_str.contains("testdb"));
    }

    #[test]
    fn test_connection_collection_add() {
        let mut collection = ConnectionCollection::new();

        let config = ConnectionConfig::Network(NetworkConfig {
            host: "localhost".to_string(),
            port: 5432,
            database: "testdb".to_string(),
            username: "testuser".to_string(),
            encrypted_password: None,
            ssl_config: None,
            options: None,
        });

        let connection = ConnectionInfo::new(
            "Test".to_string(),
            DatabaseType::PostgreSQL,
            config,
        );

        collection.add(connection).unwrap();

        assert_eq!(collection.connections.len(), 1);
    }

    #[test]
    fn test_duplicate_name_prevention() {
        let mut collection = ConnectionCollection::new();

        let config = ConnectionConfig::Network(NetworkConfig {
            host: "localhost".to_string(),
            port: 5432,
            database: "testdb".to_string(),
            username: "testuser".to_string(),
            encrypted_password: None,
            ssl_config: None,
            options: None,
        });

        let connection1 = ConnectionInfo::new(
            "Test".to_string(),
            DatabaseType::PostgreSQL,
            config.clone(),
        );

        let connection2 = ConnectionInfo::new(
            "Test".to_string(),
            DatabaseType::PostgreSQL,
            config,
        );

        collection.add(connection1).unwrap();
        let result = collection.add(connection2);

        assert!(result.is_err());
    }

    #[test]
    fn test_json_serialization() {
        let config = ConnectionConfig::Network(NetworkConfig {
            host: "localhost".to_string(),
            port: 5432,
            database: "testdb".to_string(),
            username: "testuser".to_string(),
            encrypted_password: None,
            ssl_config: None,
            options: None,
        });

        let connection = ConnectionInfo::new(
            "Test".to_string(),
            DatabaseType::PostgreSQL,
            config,
        );

        // JSONシリアライズ
        let json = serde_json::to_string(&connection).unwrap();

        // JSONデシリアライズ
        let deserialized: ConnectionInfo = serde_json::from_str(&json).unwrap();

        assert_eq!(connection.id, deserialized.id);
        assert_eq!(connection.name, deserialized.name);
    }
}
```

#### テストケース一覧

| ID | テストケース名 | 目的 | 優先度 |
|----|--------------|------|--------|
| DM-001 | PostgreSQL接続作成 | 基本機能の動作確認 | 高 |
| DM-002 | MySQL接続作成 | 基本機能の動作確認 | 高 |
| DM-003 | SQLite接続作成 | 基本機能の動作確認 | 高 |
| DM-004 | バリデーション | データ検証の動作確認 | 高 |
| DM-005 | 接続文字列生成 | 接続文字列の正当性確認 | 高 |
| DM-006 | コレクション追加 | コレクション操作の確認 | 高 |
| DM-007 | 重複名防止 | ビジネスロジックの確認 | 高 |
| DM-008 | JSONシリアライゼーション | データ永続化の確認 | 高 |
| DM-009 | 環境別設定 | テーマ機能の確認 | 中 |
| DM-010 | メタデータ更新 | タイムスタンプ機能の確認 | 低 |

## 統合テスト

### 統合テストケース

```rust
// src-tauri/tests/integration_persistence.rs

use sql_query_builder::storage::FileStorage;
use sql_query_builder::crypto::{AesGcmEncryptor, Encryptor};
use sql_query_builder::crypto::master_key::MasterKeyManager;
use sql_query_builder::models::{ConnectionInfo, ConnectionConfig, NetworkConfig, DatabaseType};

#[tokio::test]
async fn test_full_connection_save_load_cycle() {
    // セットアップ
    let temp_dir = tempfile::TempDir::new().unwrap();
    let storage = FileStorage::new(temp_dir.path().to_path_buf()).unwrap();
    let encryptor = AesGcmEncryptor::new();
    let key_manager = MasterKeyManager::new();

    // マスターキー初期化
    key_manager.initialize().await.unwrap();
    let master_key = key_manager.get_master_key().await.unwrap();

    // 接続情報作成
    let mut connection = ConnectionInfo::new(
        "Integration Test DB".to_string(),
        DatabaseType::PostgreSQL,
        ConnectionConfig::Network(NetworkConfig {
            host: "localhost".to_string(),
            port: 5432,
            database: "testdb".to_string(),
            username: "testuser".to_string(),
            encrypted_password: None,
            ssl_config: None,
            options: None,
        }),
    );

    // パスワードを暗号化
    let password = "my_secret_password";
    let encrypted_password = encryptor
        .encrypt(password.as_bytes(), &master_key)
        .unwrap()
        .to_base64()
        .unwrap();

    if let ConnectionConfig::Network(ref mut config) = connection.connection {
        config.encrypted_password = Some(encrypted_password);
    }

    // 保存
    storage.write("test_connection", &connection).unwrap();

    // 読み込み
    let loaded: ConnectionInfo = storage.read("test_connection").unwrap();

    // 検証
    assert_eq!(loaded.name, "Integration Test DB");

    // パスワードを復号化
    if let ConnectionConfig::Network(ref config) = loaded.connection {
        let encrypted_data = crate::crypto::EncryptedData::from_base64(
            config.encrypted_password.as_ref().unwrap(),
        )
        .unwrap();

        let decrypted = encryptor.decrypt(&encrypted_data, &master_key).unwrap();
        let decrypted_password = String::from_utf8(decrypted).unwrap();

        assert_eq!(decrypted_password, password);
    }
}
```

## テスト環境構築

### 必要な依存関係

```toml
[dev-dependencies]
tempfile = "3.0"           # 一時ファイル・ディレクトリ作成
tokio = { version = "1.0", features = ["full"] }
cargo-tarpaulin = "0.27"   # コードカバレッジ測定（ツール）
cargo-audit = "0.18"       # セキュリティ監査（ツール）
```

### テスト実行コマンド

```bash
# 全てのユニットテストを実行
cargo test

# 統合テストのみ実行
cargo test --test integration_persistence

# カバレッジ測定
cargo tarpaulin --out Html --output-dir coverage

# セキュリティ監査
cargo audit
```

## CI/CD統合

### GitHub Actions ワークフロー例

```yaml
# .github/workflows/test.yml
name: Test

on: [push, pull_request]

jobs:
  test:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v3

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable

      - name: Run tests
        run: cargo test --verbose

      - name: Run integration tests
        run: cargo test --test '*' --verbose

  coverage:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Install tarpaulin
        run: cargo install cargo-tarpaulin

      - name: Generate coverage
        run: cargo tarpaulin --out Xml

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./cobertura.xml

  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Security audit
        run: |
          cargo install cargo-audit
          cargo audit
```

## テストデータ管理

### テストフィクスチャ

```rust
// src-tauri/tests/fixtures/mod.rs

pub fn sample_postgresql_connection() -> ConnectionInfo {
    ConnectionInfo::new(
        "Test PostgreSQL".to_string(),
        DatabaseType::PostgreSQL,
        ConnectionConfig::Network(NetworkConfig {
            host: "localhost".to_string(),
            port: 5432,
            database: "testdb".to_string(),
            username: "testuser".to_string(),
            encrypted_password: None,
            ssl_config: None,
            options: None,
        }),
    )
}

pub fn sample_sqlite_connection() -> ConnectionInfo {
    ConnectionInfo::new(
        "Test SQLite".to_string(),
        DatabaseType::SQLite,
        ConnectionConfig::File(FileConfig {
            file_path: "/tmp/test.db".to_string(),
            readonly: false,
        }),
    )
}
```

## テストドキュメント

### テストレポート生成

```bash
# テスト結果をJUnit形式で出力
cargo test -- --format=junit > test-results.xml

# HTMLレポート生成（cargo-testdoc使用）
cargo install cargo-testdoc
cargo testdoc
```

## 完了条件

- [ ] 全ユニットテストが実装され、パスする
- [ ] コードカバレッジが80%以上
- [ ] 統合テストが実装され、パスする
- [ ] 各OS（Windows/macOS/Linux）でテストが通過
- [ ] CI/CDパイプラインでテストが自動実行される
- [ ] セキュリティ監査でクリティカルな問題がゼロ
- [ ] テストドキュメントが整備される

## 参考資料

- [The Rust Programming Language - Testing](https://doc.rust-lang.org/book/ch11-00-testing.html)
- [cargo-tarpaulin](https://github.com/xd009642/tarpaulin)
- [cargo-audit](https://github.com/rustsec/rustsec/tree/main/cargo-audit)
- [Tokio Testing](https://tokio.rs/tokio/topics/testing)
