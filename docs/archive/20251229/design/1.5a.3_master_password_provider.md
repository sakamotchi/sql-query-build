# 1.5a.3 MasterPasswordProvider実装

## 概要

| 項目 | 内容 |
|------|------|
| タスクID | 1.5a.3 |
| タスク名 | MasterPasswordProvider実装 |
| 担当 | BE |
| 工数 | 2日 |
| 依存関係 | 1.5a.1 |
| 完了条件 | PBKDF2キー導出が動作 |

## 目的

ユーザーが設定したマスターパスワードから暗号化キーを導出するプロバイダーを実装する。
起動時にマスターパスワードを入力することで、高いセキュリティを提供する。

## セキュリティ特性

| 項目 | 説明 |
|------|------|
| セキュリティレベル | 高 |
| 暗号化アルゴリズム | AES-256-GCM |
| キー導出 | PBKDF2-HMAC-SHA256（600,000回反復） |
| パスワード保存 | ハッシュのみ保存（Argon2id） |
| 利点 | ユーザーのみが復号可能 |
| 欠点 | 起動時に毎回パスワード入力が必要 |

## アーキテクチャ

### ファイル構成

```
src-tauri/src/crypto/security_provider/
├── master_password.rs      # MasterPasswordProvider実装
└── password_validator.rs   # パスワード強度検証
```

## 設計詳細

### パスワード要件

```rust
/// パスワード要件
#[derive(Debug, Clone)]
pub struct PasswordRequirements {
    /// 最小文字数
    pub min_length: usize,
    /// 最大文字数
    pub max_length: usize,
    /// 大文字を含む必要があるか
    pub require_uppercase: bool,
    /// 小文字を含む必要があるか
    pub require_lowercase: bool,
    /// 数字を含む必要があるか
    pub require_digit: bool,
    /// 記号を含む必要があるか
    pub require_special: bool,
}

impl Default for PasswordRequirements {
    fn default() -> Self {
        Self {
            min_length: 8,
            max_length: 128,
            require_uppercase: false,
            require_lowercase: false,
            require_digit: false,
            require_special: false,
        }
    }
}

/// パスワード検証結果
#[derive(Debug, Clone)]
pub struct PasswordValidationResult {
    pub is_valid: bool,
    pub strength: PasswordStrength,
    pub errors: Vec<String>,
    pub suggestions: Vec<String>,
}

/// パスワード強度
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PasswordStrength {
    VeryWeak,
    Weak,
    Fair,
    Strong,
    VeryStrong,
}

/// パスワードバリデーター
pub struct PasswordValidator {
    requirements: PasswordRequirements,
}

impl PasswordValidator {
    pub fn new(requirements: PasswordRequirements) -> Self {
        Self { requirements }
    }

    pub fn validate(&self, password: &str) -> PasswordValidationResult {
        let mut errors = Vec::new();
        let mut suggestions = Vec::new();

        // 長さチェック
        if password.len() < self.requirements.min_length {
            errors.push(format!(
                "パスワードは{}文字以上必要です",
                self.requirements.min_length
            ));
        }

        if password.len() > self.requirements.max_length {
            errors.push(format!(
                "パスワードは{}文字以下にしてください",
                self.requirements.max_length
            ));
        }

        // 文字種チェック
        let has_uppercase = password.chars().any(|c| c.is_uppercase());
        let has_lowercase = password.chars().any(|c| c.is_lowercase());
        let has_digit = password.chars().any(|c| c.is_numeric());
        let has_special = password.chars().any(|c| !c.is_alphanumeric());

        if self.requirements.require_uppercase && !has_uppercase {
            errors.push("大文字を含めてください".to_string());
        }
        if self.requirements.require_lowercase && !has_lowercase {
            errors.push("小文字を含めてください".to_string());
        }
        if self.requirements.require_digit && !has_digit {
            errors.push("数字を含めてください".to_string());
        }
        if self.requirements.require_special && !has_special {
            errors.push("記号を含めてください".to_string());
        }

        // 強度計算
        let strength = self.calculate_strength(password);

        // 提案
        if strength == PasswordStrength::VeryWeak || strength == PasswordStrength::Weak {
            if !has_uppercase { suggestions.push("大文字を追加するとより安全です".to_string()); }
            if !has_digit { suggestions.push("数字を追加するとより安全です".to_string()); }
            if !has_special { suggestions.push("記号を追加するとより安全です".to_string()); }
            if password.len() < 12 { suggestions.push("12文字以上にするとより安全です".to_string()); }
        }

        PasswordValidationResult {
            is_valid: errors.is_empty(),
            strength,
            errors,
            suggestions,
        }
    }

    fn calculate_strength(&self, password: &str) -> PasswordStrength {
        let mut score = 0;

        // 長さによるスコア
        score += match password.len() {
            0..=7 => 0,
            8..=11 => 1,
            12..=15 => 2,
            16..=19 => 3,
            _ => 4,
        };

        // 文字種によるスコア
        if password.chars().any(|c| c.is_uppercase()) { score += 1; }
        if password.chars().any(|c| c.is_lowercase()) { score += 1; }
        if password.chars().any(|c| c.is_numeric()) { score += 1; }
        if password.chars().any(|c| !c.is_alphanumeric()) { score += 2; }

        match score {
            0..=2 => PasswordStrength::VeryWeak,
            3..=4 => PasswordStrength::Weak,
            5..=6 => PasswordStrength::Fair,
            7..=8 => PasswordStrength::Strong,
            _ => PasswordStrength::VeryStrong,
        }
    }
}
```

### MasterPasswordProvider実装

```rust
use async_trait::async_trait;
use argon2::{Argon2, PasswordHasher, PasswordVerifier, password_hash::{SaltString, rand_core::OsRng}};
use std::sync::RwLock;
use zeroize::Zeroizing;

use super::{
    traits::SecurityProvider,
    types::{ProviderState, SecurityProviderType, InitializeParams, UnlockParams},
    error::{SecurityProviderError, SecurityProviderResult},
};

/// マスターパスワード設定
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MasterPasswordConfig {
    /// 設定バージョン
    pub version: u32,
    /// パスワードハッシュ（Argon2id）
    pub password_hash: String,
    /// キー導出用ソルト
    pub key_salt: Vec<u8>,
    /// PBKDF2反復回数
    pub iterations: u32,
    /// 設定日時
    pub created_at: chrono::DateTime<chrono::Utc>,
    /// 最終更新日時
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

/// マスターパスワードプロバイダー
pub struct MasterPasswordProvider {
    /// プロバイダーの状態
    state: RwLock<ProviderState>,

    /// 暗号化キー（メモリ上にキャッシュ）
    cached_key: RwLock<Option<Zeroizing<Vec<u8>>>>,

    /// 設定ストレージ
    storage: Option<Arc<FileStorage>>,

    /// パスワード検証器
    validator: PasswordValidator,
}

impl MasterPasswordProvider {
    /// PBKDF2のデフォルト反復回数
    const DEFAULT_ITERATIONS: u32 = 600_000;

    /// 設定ファイル名
    const CONFIG_KEY: &'static str = "master_password_config";

    pub fn new() -> Self {
        Self {
            state: RwLock::new(ProviderState::Uninitialized),
            cached_key: RwLock::new(None),
            storage: None,
            validator: PasswordValidator::new(PasswordRequirements::default()),
        }
    }

    pub fn with_storage(mut self, storage: Arc<FileStorage>) -> Self {
        self.storage = Some(storage);

        // 設定が存在すれば状態をLockedに
        if self.config_exists() {
            *self.state.write().unwrap() = ProviderState::Locked;
        }

        self
    }

    /// 設定が存在するかチェック
    fn config_exists(&self) -> bool {
        self.storage.as_ref()
            .map(|s| s.exists(Self::CONFIG_KEY))
            .unwrap_or(false)
    }

    /// 設定を読み込み
    fn load_config(&self) -> SecurityProviderResult<MasterPasswordConfig> {
        let storage = self.storage.as_ref()
            .ok_or_else(|| SecurityProviderError::Internal("Storage not configured".to_string()))?;

        storage.read::<MasterPasswordConfig>(Self::CONFIG_KEY)
            .map_err(|e| SecurityProviderError::StorageError(e.to_string()))
    }

    /// 設定を保存
    fn save_config(&self, config: &MasterPasswordConfig) -> SecurityProviderResult<()> {
        let storage = self.storage.as_ref()
            .ok_or_else(|| SecurityProviderError::Internal("Storage not configured".to_string()))?;

        storage.write(Self::CONFIG_KEY, config)
            .map_err(|e| SecurityProviderError::StorageError(e.to_string()))
    }

    /// パスワードハッシュを生成（Argon2id）
    fn hash_password(&self, password: &str) -> SecurityProviderResult<String> {
        let salt = SaltString::generate(&mut OsRng);
        let argon2 = Argon2::default();

        argon2
            .hash_password(password.as_bytes(), &salt)
            .map(|hash| hash.to_string())
            .map_err(|e| SecurityProviderError::EncryptionError(e.to_string()))
    }

    /// パスワードを検証（Argon2id）
    fn verify_password(&self, password: &str, hash: &str) -> SecurityProviderResult<bool> {
        let argon2 = Argon2::default();
        let parsed_hash = argon2::PasswordHash::new(hash)
            .map_err(|e| SecurityProviderError::EncryptionError(e.to_string()))?;

        Ok(argon2.verify_password(password.as_bytes(), &parsed_hash).is_ok())
    }

    /// 暗号化キーを導出（PBKDF2）
    fn derive_key(&self, password: &str, salt: &[u8], iterations: u32) -> Zeroizing<Vec<u8>> {
        use pbkdf2::pbkdf2_hmac;
        use sha2::Sha256;

        let mut key = Zeroizing::new(vec![0u8; 32]);
        pbkdf2_hmac::<Sha256>(password.as_bytes(), salt, iterations, &mut key);
        key
    }

    /// ランダムなソルトを生成
    fn generate_salt() -> Vec<u8> {
        use rand::RngCore;
        let mut salt = vec![0u8; 32];
        rand::thread_rng().fill_bytes(&mut salt);
        salt
    }
}

#[async_trait]
impl SecurityProvider for MasterPasswordProvider {
    fn provider_type(&self) -> SecurityProviderType {
        SecurityProviderType::MasterPassword
    }

    fn state(&self) -> ProviderState {
        self.state.read().unwrap().clone()
    }

    fn needs_initialization(&self) -> bool {
        !self.config_exists()
    }

    fn needs_unlock(&self) -> bool {
        matches!(*self.state.read().unwrap(), ProviderState::Locked)
    }

    async fn initialize(&mut self, params: InitializeParams) -> SecurityProviderResult<()> {
        let (password, password_confirm) = match params {
            InitializeParams::MasterPassword { password, password_confirm } => {
                (password, password_confirm)
            }
            _ => {
                return Err(SecurityProviderError::InvalidParams(
                    "MasterPassword provider requires MasterPassword params".to_string()
                ));
            }
        };

        // 既に初期化済みの場合はエラー
        if self.config_exists() {
            return Err(SecurityProviderError::AlreadyInitialized);
        }

        // パスワード一致チェック
        if password != password_confirm {
            return Err(SecurityProviderError::PasswordMismatch);
        }

        // パスワード強度チェック
        let validation = self.validator.validate(&password);
        if !validation.is_valid {
            return Err(SecurityProviderError::WeakPassword(
                validation.errors.join(", ")
            ));
        }

        // パスワードハッシュを生成
        let password_hash = self.hash_password(&password)?;

        // キー導出用ソルトを生成
        let key_salt = Self::generate_salt();

        // 暗号化キーを導出
        let key = self.derive_key(&password, &key_salt, Self::DEFAULT_ITERATIONS);

        // 設定を保存
        let now = chrono::Utc::now();
        let config = MasterPasswordConfig {
            version: 1,
            password_hash,
            key_salt: key_salt.clone(),
            iterations: Self::DEFAULT_ITERATIONS,
            created_at: now,
            updated_at: now,
        };
        self.save_config(&config)?;

        // キーをキャッシュ
        *self.cached_key.write().unwrap() = Some(key);

        // 状態を更新
        *self.state.write().unwrap() = ProviderState::Ready;

        Ok(())
    }

    async fn unlock(&mut self, params: UnlockParams) -> SecurityProviderResult<()> {
        let password = match params {
            UnlockParams::MasterPassword { password } => password,
            _ => {
                return Err(SecurityProviderError::InvalidParams(
                    "MasterPassword provider requires MasterPassword params".to_string()
                ));
            }
        };

        // 設定を読み込み
        let config = self.load_config()?;

        // パスワードを検証
        if !self.verify_password(&password, &config.password_hash)? {
            return Err(SecurityProviderError::AuthenticationFailed);
        }

        // 暗号化キーを導出
        let key = self.derive_key(&password, &config.key_salt, config.iterations);

        // キーをキャッシュ
        *self.cached_key.write().unwrap() = Some(key);

        // 状態を更新
        *self.state.write().unwrap() = ProviderState::Ready;

        Ok(())
    }

    async fn lock(&mut self) {
        // キーをクリア（zeroize）
        *self.cached_key.write().unwrap() = None;

        // 状態を更新
        *self.state.write().unwrap() = ProviderState::Locked;
    }

    async fn get_encryption_key(&self) -> SecurityProviderResult<Vec<u8>> {
        let cached = self.cached_key.read().unwrap();
        cached.as_ref()
            .map(|k| k.to_vec())
            .ok_or(SecurityProviderError::Locked)
    }

    async fn reset(&mut self) -> SecurityProviderResult<()> {
        // キーをクリア
        *self.cached_key.write().unwrap() = None;

        // 設定を削除
        if let Some(storage) = &self.storage {
            let _ = storage.delete(Self::CONFIG_KEY);
        }

        // 状態を更新
        *self.state.write().unwrap() = ProviderState::Uninitialized;

        Ok(())
    }

    fn validate(&self) -> SecurityProviderResult<()> {
        Ok(())
    }
}

impl Default for MasterPasswordProvider {
    fn default() -> Self {
        Self::new()
    }
}
```

### パスワード変更機能

```rust
impl MasterPasswordProvider {
    /// マスターパスワードを変更
    pub async fn change_password(
        &mut self,
        current_password: &str,
        new_password: &str,
        new_password_confirm: &str,
    ) -> SecurityProviderResult<()> {
        // 現在のパスワードを検証
        let config = self.load_config()?;
        if !self.verify_password(current_password, &config.password_hash)? {
            return Err(SecurityProviderError::AuthenticationFailed);
        }

        // 新しいパスワードの一致チェック
        if new_password != new_password_confirm {
            return Err(SecurityProviderError::PasswordMismatch);
        }

        // 新しいパスワードの強度チェック
        let validation = self.validator.validate(new_password);
        if !validation.is_valid {
            return Err(SecurityProviderError::WeakPassword(
                validation.errors.join(", ")
            ));
        }

        // 新しいパスワードハッシュを生成
        let new_password_hash = self.hash_password(new_password)?;

        // 新しいキー導出用ソルトを生成
        let new_key_salt = Self::generate_salt();

        // 新しい暗号化キーを導出
        let new_key = self.derive_key(new_password, &new_key_salt, Self::DEFAULT_ITERATIONS);

        // 設定を更新
        let new_config = MasterPasswordConfig {
            version: config.version,
            password_hash: new_password_hash,
            key_salt: new_key_salt,
            iterations: Self::DEFAULT_ITERATIONS,
            created_at: config.created_at,
            updated_at: chrono::Utc::now(),
        };
        self.save_config(&new_config)?;

        // キーをキャッシュ
        *self.cached_key.write().unwrap() = Some(new_key);

        Ok(())
    }
}
```

## Tauriコマンド

```rust
/// マスターパスワードを初期化
#[tauri::command]
pub async fn initialize_master_password(
    manager: State<'_, Arc<SecurityProviderManager>>,
    password: String,
    password_confirm: String,
) -> Result<(), String> {
    manager.initialize(InitializeParams::MasterPassword {
        password,
        password_confirm,
    }).await.map_err(|e| e.to_string())
}

/// マスターパスワードでアンロック
#[tauri::command]
pub async fn unlock_with_master_password(
    manager: State<'_, Arc<SecurityProviderManager>>,
    password: String,
) -> Result<(), String> {
    manager.unlock(UnlockParams::MasterPassword { password })
        .await
        .map_err(|e| e.to_string())
}

/// パスワード強度をチェック
#[tauri::command]
pub async fn check_password_strength(password: String) -> PasswordValidationResult {
    let validator = PasswordValidator::new(PasswordRequirements::default());
    validator.validate(&password)
}
```

## テスト

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn create_test_storage() -> (Arc<FileStorage>, TempDir) {
        let temp_dir = TempDir::new().unwrap();
        let storage = Arc::new(FileStorage::new(temp_dir.path().to_path_buf()).unwrap());
        (storage, temp_dir)
    }

    #[tokio::test]
    async fn test_master_password_initialization() {
        let (storage, _temp) = create_test_storage();
        let mut provider = MasterPasswordProvider::new().with_storage(storage);

        assert!(provider.needs_initialization());

        provider.initialize(InitializeParams::MasterPassword {
            password: "StrongP@ssw0rd!".to_string(),
            password_confirm: "StrongP@ssw0rd!".to_string(),
        }).await.unwrap();

        assert!(!provider.needs_initialization());
        assert!(provider.state().is_ready());
    }

    #[tokio::test]
    async fn test_master_password_mismatch() {
        let (storage, _temp) = create_test_storage();
        let mut provider = MasterPasswordProvider::new().with_storage(storage);

        let result = provider.initialize(InitializeParams::MasterPassword {
            password: "password1".to_string(),
            password_confirm: "password2".to_string(),
        }).await;

        assert!(matches!(result, Err(SecurityProviderError::PasswordMismatch)));
    }

    #[tokio::test]
    async fn test_master_password_unlock() {
        let (storage, _temp) = create_test_storage();
        let mut provider = MasterPasswordProvider::new().with_storage(storage.clone());

        let password = "StrongP@ssw0rd!";
        provider.initialize(InitializeParams::MasterPassword {
            password: password.to_string(),
            password_confirm: password.to_string(),
        }).await.unwrap();

        provider.lock().await;
        assert!(provider.needs_unlock());

        provider.unlock(UnlockParams::MasterPassword {
            password: password.to_string(),
        }).await.unwrap();

        assert!(!provider.needs_unlock());
        assert!(provider.state().is_ready());
    }

    #[tokio::test]
    async fn test_master_password_wrong_password() {
        let (storage, _temp) = create_test_storage();
        let mut provider = MasterPasswordProvider::new().with_storage(storage);

        provider.initialize(InitializeParams::MasterPassword {
            password: "CorrectPassword123!".to_string(),
            password_confirm: "CorrectPassword123!".to_string(),
        }).await.unwrap();

        provider.lock().await;

        let result = provider.unlock(UnlockParams::MasterPassword {
            password: "WrongPassword".to_string(),
        }).await;

        assert!(matches!(result, Err(SecurityProviderError::AuthenticationFailed)));
    }

    #[test]
    fn test_password_validation() {
        let validator = PasswordValidator::new(PasswordRequirements::default());

        // 弱いパスワード
        let result = validator.validate("short");
        assert!(!result.is_valid);

        // 強いパスワード
        let result = validator.validate("StrongP@ssw0rd!");
        assert!(result.is_valid);
        assert!(matches!(result.strength, PasswordStrength::Strong | PasswordStrength::VeryStrong));
    }
}
```

## 実装チェックリスト

- [ ] `PasswordRequirements` 構造体実装
- [ ] `PasswordValidator` 実装
- [ ] `MasterPasswordConfig` 構造体実装
- [ ] `MasterPasswordProvider` 構造体実装
- [ ] `SecurityProvider` trait実装
- [ ] Argon2idパスワードハッシュ実装
- [ ] PBKDF2キー導出実装
- [ ] パスワード変更機能実装
- [ ] Tauriコマンド実装
- [ ] ユニットテスト作成

---

**作成日**: 2025-11-24
**作成者**: Claude Code
