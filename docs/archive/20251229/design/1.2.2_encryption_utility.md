# 1.2.2 暗号化ユーティリティ設計書

## 概要

データベース接続情報に含まれるパスワードなどの機密情報を安全に保存するための暗号化/復号化ユーティリティを実装します。

## 目的

- データベースパスワードの安全な暗号化
- 復号化による平文パスワードの取得
- マスターキーベースの暗号化方式
- 将来的なアルゴリズム変更に対応可能な設計

## セキュリティ要件

1. **暗号化アルゴリズム**
   - AES-256-GCM（認証付き暗号化）
   - PBKDF2によるキー導出
   - ランダムなソルトとノンス（IV）の使用

2. **鍵管理**
   - マスターキーは別モジュールで管理（1.2.3参照）
   - キーはメモリ上でのみ保持
   - 使用後のメモリクリア（zeroize）

3. **データ完全性**
   - GCMタグによる改ざん検知
   - 復号化失敗時の適切なエラーハンドリング

## アーキテクチャ

### モジュール構成

```
src-tauri/src/
├── crypto/
│   ├── mod.rs              # 暗号化モジュールのエントリポイント
│   ├── encryption.rs       # 暗号化/復号化実装
│   ├── key_derivation.rs   # キー導出機能
│   ├── error.rs            # エラー型定義
│   └── types.rs            # 暗号化データ型定義
```

### 責務

1. **暗号化エンジン (`encryption.rs`)**
   - AES-GCMによる暗号化/復号化
   - ノンスの生成
   - 暗号化データのシリアライズ

2. **キー導出 (`key_derivation.rs`)**
   - PBKDF2によるマスターキーからの鍵導出
   - ソルト生成
   - パラメータ管理

3. **型定義 (`types.rs`)**
   - 暗号化データ構造
   - キー型定義

## データモデル

### 暗号化データ構造

```rust
use serde::{Deserialize, Serialize};

/// 暗号化されたデータを表す構造体
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncryptedData {
    /// 暗号化アルゴリズムのバージョン（将来の変更に対応）
    pub version: u32,

    /// AES-GCMのノンス（12バイト）
    pub nonce: Vec<u8>,

    /// PBKDF2のソルト（32バイト）
    pub salt: Vec<u8>,

    /// 暗号化されたデータ（暗号文 + 認証タグ）
    pub ciphertext: Vec<u8>,

    /// PBKDF2の反復回数
    pub iterations: u32,
}

impl EncryptedData {
    /// Base64エンコードされた文字列に変換
    pub fn to_base64(&self) -> Result<String, CryptoError> {
        let json = serde_json::to_string(self)?;
        Ok(base64::encode(json.as_bytes()))
    }

    /// Base64エンコードされた文字列から復元
    pub fn from_base64(encoded: &str) -> Result<Self, CryptoError> {
        let decoded = base64::decode(encoded)?;
        let data = serde_json::from_slice(&decoded)?;
        Ok(data)
    }
}
```

### キー型定義

```rust
use zeroize::Zeroize;

/// 暗号化キーを安全に保持する構造体
#[derive(Zeroize)]
#[zeroize(drop)]
pub struct EncryptionKey {
    key: [u8; 32], // AES-256用の32バイトキー
}

impl EncryptionKey {
    /// 新しいキーを作成（ランダム生成）
    pub fn generate() -> Result<Self, CryptoError> {
        use rand::RngCore;
        let mut key = [0u8; 32];
        rand::thread_rng().fill_bytes(&mut key);
        Ok(Self { key })
    }

    /// バイト配列からキーを作成
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, CryptoError> {
        if bytes.len() != 32 {
            return Err(CryptoError::InvalidKeyLength);
        }
        let mut key = [0u8; 32];
        key.copy_from_slice(bytes);
        Ok(Self { key })
    }

    /// キーのバイト表現を取得
    pub fn as_bytes(&self) -> &[u8] {
        &self.key
    }
}
```

## 暗号化実装

### Encryptorトレイト

```rust
/// 暗号化/復号化を行うトレイト
pub trait Encryptor {
    /// データを暗号化
    fn encrypt(&self, plaintext: &[u8], master_key: &[u8]) -> Result<EncryptedData, CryptoError>;

    /// データを復号化
    fn decrypt(&self, encrypted: &EncryptedData, master_key: &[u8]) -> Result<Vec<u8>, CryptoError>;
}
```

### AES-GCM Encryptor実装

```rust
use aes_gcm::{
    aead::{Aead, KeyInit, OsRng},
    Aes256Gcm, Nonce,
};
use rand::RngCore;

/// AES-256-GCMを使用した暗号化実装
pub struct AesGcmEncryptor {
    /// PBKDF2の反復回数
    iterations: u32,
}

impl AesGcmEncryptor {
    /// デフォルトの反復回数（600,000回）
    const DEFAULT_ITERATIONS: u32 = 600_000;

    /// 新しいEncryptorインスタンスを作成
    pub fn new() -> Self {
        Self {
            iterations: Self::DEFAULT_ITERATIONS,
        }
    }

    /// カスタム反復回数でEncryptorを作成
    pub fn with_iterations(iterations: u32) -> Self {
        Self { iterations }
    }

    /// マスターキーから暗号化キーを導出
    fn derive_key(&self, master_key: &[u8], salt: &[u8]) -> Result<EncryptionKey, CryptoError> {
        use pbkdf2::pbkdf2_hmac;
        use sha2::Sha256;

        let mut key = [0u8; 32];
        pbkdf2_hmac::<Sha256>(master_key, salt, self.iterations, &mut key);

        EncryptionKey::from_bytes(&key)
    }

    /// ランダムなソルトを生成
    fn generate_salt(&self) -> [u8; 32] {
        let mut salt = [0u8; 32];
        rand::thread_rng().fill_bytes(&mut salt);
        salt
    }

    /// ランダムなノンスを生成
    fn generate_nonce(&self) -> [u8; 12] {
        let mut nonce = [0u8; 12];
        rand::thread_rng().fill_bytes(&mut nonce);
        nonce
    }
}

impl Encryptor for AesGcmEncryptor {
    fn encrypt(&self, plaintext: &[u8], master_key: &[u8]) -> Result<EncryptedData, CryptoError> {
        // ソルトとノンスを生成
        let salt = self.generate_salt();
        let nonce_bytes = self.generate_nonce();

        // マスターキーから暗号化キーを導出
        let encryption_key = self.derive_key(master_key, &salt)?;

        // AES-GCM暗号化
        let cipher = Aes256Gcm::new_from_slice(encryption_key.as_bytes())
            .map_err(|_| CryptoError::EncryptionFailed)?;

        let nonce = Nonce::from_slice(&nonce_bytes);

        let ciphertext = cipher
            .encrypt(nonce, plaintext)
            .map_err(|_| CryptoError::EncryptionFailed)?;

        Ok(EncryptedData {
            version: 1,
            nonce: nonce_bytes.to_vec(),
            salt: salt.to_vec(),
            ciphertext,
            iterations: self.iterations,
        })
    }

    fn decrypt(&self, encrypted: &EncryptedData, master_key: &[u8]) -> Result<Vec<u8>, CryptoError> {
        // バージョンチェック
        if encrypted.version != 1 {
            return Err(CryptoError::UnsupportedVersion(encrypted.version));
        }

        // マスターキーから暗号化キーを導出
        let encryption_key = self.derive_key(master_key, &encrypted.salt)?;

        // AES-GCM復号化
        let cipher = Aes256Gcm::new_from_slice(encryption_key.as_bytes())
            .map_err(|_| CryptoError::DecryptionFailed)?;

        let nonce = Nonce::from_slice(&encrypted.nonce);

        let plaintext = cipher
            .decrypt(nonce, encrypted.ciphertext.as_ref())
            .map_err(|_| CryptoError::DecryptionFailed)?;

        Ok(plaintext)
    }
}
```

### 便利な関数

```rust
/// 文字列を暗号化してBase64エンコードされた文字列を返す
pub fn encrypt_string(plaintext: &str, master_key: &[u8]) -> Result<String, CryptoError> {
    let encryptor = AesGcmEncryptor::new();
    let encrypted = encryptor.encrypt(plaintext.as_bytes(), master_key)?;
    encrypted.to_base64()
}

/// Base64エンコードされた暗号化文字列を復号化
pub fn decrypt_string(encrypted_base64: &str, master_key: &[u8]) -> Result<String, CryptoError> {
    let encryptor = AesGcmEncryptor::new();
    let encrypted = EncryptedData::from_base64(encrypted_base64)?;
    let plaintext = encryptor.decrypt(&encrypted, master_key)?;

    String::from_utf8(plaintext)
        .map_err(|_| CryptoError::InvalidUtf8)
}
```

## エラー型定義

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum CryptoError {
    #[error("暗号化に失敗しました")]
    EncryptionFailed,

    #[error("復号化に失敗しました（キーが間違っているか、データが破損しています）")]
    DecryptionFailed,

    #[error("サポートされていないバージョンです: {0}")]
    UnsupportedVersion(u32),

    #[error("キーの長さが不正です")]
    InvalidKeyLength,

    #[error("Base64デコードエラー: {0}")]
    Base64Error(#[from] base64::DecodeError),

    #[error("JSON変換エラー: {0}")]
    SerializationError(#[from] serde_json::Error),

    #[error("UTF-8変換エラー")]
    InvalidUtf8,

    #[error("キー導出エラー")]
    KeyDerivationError,
}

pub type CryptoResult<T> = Result<T, CryptoError>;
```

## 必要な依存関係

```toml
[dependencies]
# 暗号化
aes-gcm = "0.10"          # AES-GCM暗号化
pbkdf2 = "0.12"           # PBKDF2キー導出
sha2 = "0.10"             # SHA-256ハッシュ関数
rand = "0.8"              # 乱数生成
zeroize = "1.6"           # メモリゼロクリア

# エンコーディング
base64 = "0.21"           # Base64エンコード/デコード

# シリアライゼーション
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# エラーハンドリング
thiserror = "1.0"
```

## セキュリティベストプラクティス

### 1. メモリ管理

```rust
// zeroizeを使用してキーをメモリから安全に削除
use zeroize::Zeroize;

fn process_sensitive_data(master_key: &[u8]) -> Result<(), CryptoError> {
    let mut encryption_key = derive_key(master_key)?;

    // 処理実行
    // ...

    // 使用後はメモリをゼロクリア
    encryption_key.zeroize();

    Ok(())
}
```

### 2. タイミング攻撃対策

```rust
// 定数時間比較を使用
use subtle::ConstantTimeEq;

fn verify_key(provided: &[u8], expected: &[u8]) -> bool {
    provided.ct_eq(expected).into()
}
```

### 3. パラメータ設定

```rust
/// セキュリティレベルに応じたパラメータセット
pub enum SecurityLevel {
    /// 低速だが高セキュリティ（本番環境推奨）
    High,
    /// 中速・中セキュリティ（開発環境）
    Medium,
    /// 高速・低セキュリティ（テスト用のみ）
    Low,
}

impl SecurityLevel {
    pub fn iterations(&self) -> u32 {
        match self {
            Self::High => 600_000,    // OWASP推奨（2023年）
            Self::Medium => 100_000,
            Self::Low => 10_000,
        }
    }
}
```

## API設計

### Tauriコマンド

```rust
use tauri::State;
use crate::crypto::{encrypt_string, decrypt_string};
use crate::crypto::master_key::MasterKeyManager;

#[tauri::command]
pub async fn encrypt_password(
    password: String,
    key_manager: State<'_, MasterKeyManager>,
) -> Result<String, String> {
    let master_key = key_manager
        .get_master_key()
        .await
        .map_err(|e| e.to_string())?;

    encrypt_string(&password, &master_key)
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn decrypt_password(
    encrypted_password: String,
    key_manager: State<'_, MasterKeyManager>,
) -> Result<String, String> {
    let master_key = key_manager
        .get_master_key()
        .await
        .map_err(|e| e.to_string())?;

    decrypt_string(&encrypted_password, &master_key)
        .map_err(|e| e.to_string())
}
```

## テスト方針

### ユニットテスト

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encrypt_decrypt() {
        let encryptor = AesGcmEncryptor::new();
        let master_key = b"test-master-key-32-bytes-long!!!";
        let plaintext = b"sensitive password";

        // 暗号化
        let encrypted = encryptor.encrypt(plaintext, master_key).unwrap();

        // 復号化
        let decrypted = encryptor.decrypt(&encrypted, master_key).unwrap();

        assert_eq!(plaintext, decrypted.as_slice());
    }

    #[test]
    fn test_wrong_key_fails() {
        let encryptor = AesGcmEncryptor::new();
        let master_key = b"correct-key-32-bytes-long!!!!!!";
        let wrong_key = b"wrong-key-32-bytes-long!!!!!!!!!";
        let plaintext = b"sensitive password";

        // 正しいキーで暗号化
        let encrypted = encryptor.encrypt(plaintext, master_key).unwrap();

        // 間違ったキーで復号化
        let result = encryptor.decrypt(&encrypted, wrong_key);

        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), CryptoError::DecryptionFailed));
    }

    #[test]
    fn test_string_encryption() {
        let master_key = b"test-master-key-32-bytes-long!!!";
        let plaintext = "my secret password";

        // 暗号化
        let encrypted = encrypt_string(plaintext, master_key).unwrap();

        // Base64文字列であることを確認
        assert!(base64::decode(&encrypted).is_ok());

        // 復号化
        let decrypted = decrypt_string(&encrypted, master_key).unwrap();

        assert_eq!(plaintext, decrypted);
    }

    #[test]
    fn test_nonce_uniqueness() {
        let encryptor = AesGcmEncryptor::new();
        let master_key = b"test-master-key-32-bytes-long!!!";
        let plaintext = b"same plaintext";

        // 同じ平文を2回暗号化
        let encrypted1 = encryptor.encrypt(plaintext, master_key).unwrap();
        let encrypted2 = encryptor.encrypt(plaintext, master_key).unwrap();

        // ノンスが異なることを確認（同じ平文でも暗号文は異なる）
        assert_ne!(encrypted1.nonce, encrypted2.nonce);
        assert_ne!(encrypted1.ciphertext, encrypted2.ciphertext);

        // 両方とも正しく復号化できることを確認
        let decrypted1 = encryptor.decrypt(&encrypted1, master_key).unwrap();
        let decrypted2 = encryptor.decrypt(&encrypted2, master_key).unwrap();

        assert_eq!(decrypted1, decrypted2);
        assert_eq!(decrypted1, plaintext);
    }

    #[test]
    fn test_base64_roundtrip() {
        let encryptor = AesGcmEncryptor::new();
        let master_key = b"test-master-key-32-bytes-long!!!";
        let plaintext = b"test data";

        let encrypted = encryptor.encrypt(plaintext, master_key).unwrap();

        // Base64エンコード
        let encoded = encrypted.to_base64().unwrap();

        // Base64デコード
        let decoded = EncryptedData::from_base64(&encoded).unwrap();

        // 復号化して元のデータと一致することを確認
        let decrypted = encryptor.decrypt(&decoded, master_key).unwrap();
        assert_eq!(plaintext, decrypted.as_slice());
    }

    #[test]
    fn test_tampered_data_fails() {
        let encryptor = AesGcmEncryptor::new();
        let master_key = b"test-master-key-32-bytes-long!!!";
        let plaintext = b"sensitive data";

        let mut encrypted = encryptor.encrypt(plaintext, master_key).unwrap();

        // 暗号文を改ざん
        if let Some(byte) = encrypted.ciphertext.first_mut() {
            *byte ^= 0xFF;
        }

        // 改ざんされたデータの復号化は失敗すべき
        let result = encryptor.decrypt(&encrypted, master_key);
        assert!(result.is_err());
    }
}
```

### セキュリティテスト

```rust
#[cfg(test)]
mod security_tests {
    use super::*;

    #[test]
    fn test_key_is_zeroized() {
        let key_bytes = [0x42u8; 32];
        let mut key = EncryptionKey::from_bytes(&key_bytes).unwrap();

        // キーが正しく設定されていることを確認
        assert_eq!(key.as_bytes(), &key_bytes);

        // ドロップ
        drop(key);

        // zeroizeが自動的に呼ばれるため、メモリがクリアされる
        // （実際のメモリ検証は困難だが、zeroize crateのテストに依存）
    }

    #[test]
    fn test_sufficient_iterations() {
        let encryptor = AesGcmEncryptor::new();

        // 最低でも100,000回以上の反復を使用していることを確認
        assert!(encryptor.iterations >= 100_000);
    }
}
```

## パフォーマンス考慮事項

### PBKDF2反復回数の調整

```rust
/// ターゲットシステムで適切な反復回数を計算
pub fn calibrate_iterations(target_duration_ms: u64) -> u32 {
    use std::time::Instant;

    let test_key = b"test-key";
    let test_salt = b"test-salt-32-bytes-long!!!!!!!!";
    let mut output = [0u8; 32];

    let mut iterations = 100_000u32;
    let mut best_iterations = iterations;

    for _ in 0..5 {
        let start = Instant::now();
        pbkdf2::pbkdf2_hmac::<sha2::Sha256>(test_key, test_salt, iterations, &mut output);
        let duration = start.elapsed().as_millis() as u64;

        if duration <= target_duration_ms {
            best_iterations = iterations;
            iterations = (iterations as f64 * 1.5) as u32;
        } else {
            break;
        }
    }

    best_iterations
}
```

## マイグレーション戦略

### バージョン対応

```rust
impl Encryptor for AesGcmEncryptor {
    fn decrypt(&self, encrypted: &EncryptedData, master_key: &[u8]) -> Result<Vec<u8>, CryptoError> {
        match encrypted.version {
            1 => self.decrypt_v1(encrypted, master_key),
            // 将来のバージョン
            // 2 => self.decrypt_v2(encrypted, master_key),
            _ => Err(CryptoError::UnsupportedVersion(encrypted.version)),
        }
    }
}
```

## 完了条件

- [x] 設計書作成完了
- [ ] AES-256-GCM暗号化が正常に動作する
- [ ] PBKDF2キー導出が正常に動作する
- [ ] 暗号化/復号化のラウンドトリップが成功する
- [ ] 間違ったキーでの復号化が適切に失敗する
- [ ] 改ざんされたデータの検出が機能する
- [ ] ユニットテストが全てパスする
- [ ] メモリのゼロクリアが動作する

## 参考資料

- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)
- [aes-gcm crate](https://docs.rs/aes-gcm/)
- [pbkdf2 crate](https://docs.rs/pbkdf2/)
- [zeroize crate](https://docs.rs/zeroize/)
- [NIST SP 800-132](https://csrc.nist.gov/publications/detail/sp/800-132/final) - PBKDF推奨事項
