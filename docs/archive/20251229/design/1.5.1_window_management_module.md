# タスク1.5.1: Tauriウィンドウ管理モジュール実装 設計書

## 概要

**タスクID**: 1.5.1
**タスク名**: Tauriウィンドウ管理モジュール実装
**工数**: 2日
**依存関係**: 1.1.5 (開発環境・ビルド設定)
**完了条件**: 複数ウィンドウ起動が可能

---

## 目的

Tauriの複数ウィンドウ機能を活用し、ウィンドウの生成・管理・破棄を行うモジュールを実装する。これにより、ユーザーは複数のデータベース接続を同時に別ウィンドウで操作できるようになる。

---

## 機能要件

### 主要機能

1. **ウィンドウ生成**
   - 新しいウィンドウの作成
   - ウィンドウタイプ別の設定
   - 初期サイズ・位置の指定

2. **ウィンドウ管理**
   - 開いているウィンドウの追跡
   - ウィンドウ情報の取得
   - ウィンドウの検索

3. **ウィンドウ破棄**
   - ウィンドウのクローズ処理
   - 状態の保存

---

## アーキテクチャ

### システム構成

```
┌─────────────────────────────────────────────────────────────────┐
│                    Tauri Application                            │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   ランチャー     │  │  クエリビルダー  │  │  クエリビルダー  │ │
│  │   ウィンドウ     │  │  ウィンドウA     │  │  ウィンドウB     │ │
│  │   (メイン)       │  │  (開発環境)      │  │  (本番環境)      │ │
│  └────────┬────────┘  └────────┬────────┘  └────────┬────────┘ │
│           │                    │                    │          │
│  ┌────────┴────────────────────┴────────────────────┴────────┐ │
│  │              Tauri Window Manager (Rust)                  │ │
│  │  - ウィンドウ生成・破棄                                    │ │
│  │  - ウィンドウ状態管理                                      │ │
│  │  - ウィンドウ間通信                                        │ │
│  └───────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

### モジュール構成

```
src-tauri/src/
├── models/
│   └── window.rs          # ウィンドウデータモデル
├── services/
│   └── window_manager.rs  # ウィンドウ管理サービス
└── storage/
    └── window_state.rs    # ウィンドウ状態永続化
```

---

## 型定義

### window.rs (モデル)

**ファイル**: `src-tauri/src/models/window.rs`

```rust
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// ウィンドウの種類
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum WindowType {
    /// ランチャーウィンドウ（メイン）
    Launcher,
    /// クエリビルダーウィンドウ
    QueryBuilder,
    /// 設定ウィンドウ
    Settings,
}

/// ウィンドウの状態
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WindowState {
    /// ウィンドウID
    pub id: String,
    /// ウィンドウの種類
    pub window_type: WindowType,
    /// 関連する接続ID（クエリビルダーの場合）
    pub connection_id: Option<String>,
    /// ウィンドウ位置X
    pub x: Option<i32>,
    /// ウィンドウ位置Y
    pub y: Option<i32>,
    /// ウィンドウ幅
    pub width: u32,
    /// ウィンドウ高さ
    pub height: u32,
    /// 最大化状態
    pub maximized: bool,
    /// 最小化状態
    pub minimized: bool,
    /// フルスクリーン状態
    pub fullscreen: bool,
    /// 作成日時
    pub created_at: String,
    /// 更新日時
    pub updated_at: String,
}

impl WindowState {
    pub fn new(window_type: WindowType, connection_id: Option<String>) -> Self {
        let now = chrono::Utc::now().to_rfc3339();
        Self {
            id: Uuid::new_v4().to_string(),
            window_type,
            connection_id,
            x: None,
            y: None,
            width: 1200,
            height: 800,
            maximized: false,
            minimized: false,
            fullscreen: false,
            created_at: now.clone(),
            updated_at: now,
        }
    }
}

/// ウィンドウ生成オプション
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WindowCreateOptions {
    /// ウィンドウタイトル
    pub title: String,
    /// ウィンドウの種類
    pub window_type: WindowType,
    /// 関連する接続ID
    pub connection_id: Option<String>,
    /// ウィンドウ幅
    pub width: Option<u32>,
    /// ウィンドウ高さ
    pub height: Option<u32>,
    /// 中央に配置するか
    pub center: bool,
    /// 以前の状態を復元するか
    pub restore_state: bool,
}

impl Default for WindowCreateOptions {
    fn default() -> Self {
        Self {
            title: "SQL Query Builder".to_string(),
            window_type: WindowType::QueryBuilder,
            connection_id: None,
            width: Some(1200),
            height: Some(800),
            center: true,
            restore_state: true,
        }
    }
}

/// ウィンドウ情報（フロントエンドへの返却用）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WindowInfo {
    /// ウィンドウラベル（Tauri内部識別子）
    pub label: String,
    /// ウィンドウタイトル
    pub title: String,
    /// ウィンドウの種類
    pub window_type: WindowType,
    /// 関連する接続ID
    pub connection_id: Option<String>,
    /// フォーカス状態
    pub focused: bool,
    /// 可視状態
    pub visible: bool,
}
```

---

## ウィンドウ管理サービス

**ファイル**: `src-tauri/src/services/window_manager.rs`

```rust
use std::collections::HashMap;
use std::sync::Mutex;
use tauri::{AppHandle, Manager, WebviewUrl, WebviewWindowBuilder};

use crate::models::window::{WindowCreateOptions, WindowInfo, WindowState, WindowType};
use crate::storage::window_state::WindowStateStorage;

/// ウィンドウ管理サービス
pub struct WindowManager {
    /// アクティブなウィンドウの状態
    windows: Mutex<HashMap<String, WindowState>>,
    /// ウィンドウ状態ストレージ
    storage: WindowStateStorage,
}

impl WindowManager {
    pub fn new() -> Self {
        Self {
            windows: Mutex::new(HashMap::new()),
            storage: WindowStateStorage::new(),
        }
    }

    /// 新しいウィンドウを作成
    pub fn create_window(
        &self,
        app_handle: &AppHandle,
        options: WindowCreateOptions,
    ) -> Result<WindowInfo, String> {
        let label = self.generate_window_label(&options.window_type, &options.connection_id);

        // 同じ接続のウィンドウが既に存在するかチェック
        if let Some(connection_id) = &options.connection_id {
            if let Some(existing) = self.find_window_by_connection(app_handle, connection_id) {
                // 既存のウィンドウにフォーカス
                if let Some(window) = app_handle.get_webview_window(&existing.label) {
                    let _ = window.set_focus();
                }
                return Ok(existing);
            }
        }

        // 以前の状態を復元
        let saved_state = if options.restore_state {
            self.storage.load_state(&label).ok()
        } else {
            None
        };

        // ウィンドウサイズと位置の決定
        let (width, height) = saved_state
            .as_ref()
            .map(|s| (s.width, s.height))
            .unwrap_or((options.width.unwrap_or(1200), options.height.unwrap_or(800)));

        // URLの決定
        let url = match options.window_type {
            WindowType::Launcher => WebviewUrl::App("index.html".into()),
            WindowType::QueryBuilder => {
                let path = match &options.connection_id {
                    Some(id) => format!("query-builder?connectionId={}", id),
                    None => "query-builder".to_string(),
                };
                WebviewUrl::App(path.into())
            }
            WindowType::Settings => WebviewUrl::App("settings".into()),
        };

        // ウィンドウを作成
        let mut builder = WebviewWindowBuilder::new(app_handle, &label, url)
            .title(&options.title)
            .inner_size(width as f64, height as f64)
            .min_inner_size(800.0, 600.0)
            .resizable(true)
            .decorations(true);

        // 保存された位置を復元
        if let Some(ref state) = saved_state {
            if let (Some(x), Some(y)) = (state.x, state.y) {
                builder = builder.position(x as f64, y as f64);
            }
            if state.maximized {
                builder = builder.maximized(true);
            }
        } else if options.center {
            builder = builder.center();
        }

        let _window = builder
            .build()
            .map_err(|e| format!("Failed to create window: {}", e))?;

        // ウィンドウ状態を記録
        let mut window_state = WindowState::new(options.window_type.clone(), options.connection_id.clone());
        // 永続化時にウィンドウラベルで突き合わせるためIDをラベルと同一にする
        window_state.id = label.clone();
        self.windows
            .lock()
            .unwrap()
            .insert(label.clone(), window_state);

        Ok(WindowInfo {
            label,
            title: options.title,
            window_type: options.window_type,
            connection_id: options.connection_id,
            focused: true,
            visible: true,
        })
    }

    /// ウィンドウを閉じる
    pub fn close_window(&self, app_handle: &AppHandle, label: &str) -> Result<(), String> {
        // 状態を保存
        self.save_window_state(app_handle, label)?;

        // ウィンドウを閉じる
        if let Some(window) = app_handle.get_webview_window(label) {
            window.close().map_err(|e| format!("Failed to close window: {}", e))?;
        }

        // 記録から削除
        self.windows.lock().unwrap().remove(label);

        Ok(())
    }

    /// すべてのウィンドウ情報を取得
    pub fn list_windows(&self, app_handle: &AppHandle) -> Vec<WindowInfo> {
        let windows = self.windows.lock().unwrap();
        windows
            .iter()
            .filter_map(|(label, state)| {
                app_handle.get_webview_window(label).map(|window| WindowInfo {
                    label: label.clone(),
                    title: window.title().unwrap_or_default(),
                    window_type: state.window_type.clone(),
                    connection_id: state.connection_id.clone(),
                    focused: window.is_focused().unwrap_or(false),
                    visible: window.is_visible().unwrap_or(false),
                })
            })
            .collect()
    }

    /// 接続IDでウィンドウを検索
    pub fn find_window_by_connection(
        &self,
        app_handle: &AppHandle,
        connection_id: &str,
    ) -> Option<WindowInfo> {
        let windows = self.windows.lock().unwrap();
        windows.iter().find_map(|(label, state)| {
            if state.connection_id.as_deref() == Some(connection_id) {
                app_handle.get_webview_window(label).map(|window| WindowInfo {
                    label: label.clone(),
                    title: window.title().unwrap_or_default(),
                    window_type: state.window_type.clone(),
                    connection_id: state.connection_id.clone(),
                    focused: window.is_focused().unwrap_or(false),
                    visible: window.is_visible().unwrap_or(false),
                })
            } else {
                None
            }
        })
    }

    /// ウィンドウにフォーカス
    pub fn focus_window(&self, app_handle: &AppHandle, label: &str) -> Result<(), String> {
        if let Some(window) = app_handle.get_webview_window(label) {
            window.set_focus().map_err(|e| format!("Failed to focus window: {}", e))?;
            window.unminimize().ok();
        }
        Ok(())
    }

    /// ウィンドウタイトルを更新
    pub fn set_window_title(
        &self,
        app_handle: &AppHandle,
        label: &str,
        title: &str,
    ) -> Result<(), String> {
        if let Some(window) = app_handle.get_webview_window(label) {
            window
                .set_title(title)
                .map_err(|e| format!("Failed to set window title: {}", e))?;
        }
        Ok(())
    }

    /// ウィンドウ状態を保存
    pub fn save_window_state(&self, app_handle: &AppHandle, label: &str) -> Result<(), String> {
        let window = app_handle
            .get_webview_window(label)
            .ok_or("Window not found")?;

        let mut windows = self.windows.lock().unwrap();
        if let Some(state) = windows.get_mut(label) {
            // 現在の状態を取得
            if let Ok(position) = window.outer_position() {
                state.x = Some(position.x);
                state.y = Some(position.y);
            }
            if let Ok(size) = window.inner_size() {
                state.width = size.width;
                state.height = size.height;
            }
            state.maximized = window.is_maximized().unwrap_or(false);
            state.minimized = window.is_minimized().unwrap_or(false);
            state.fullscreen = window.is_fullscreen().unwrap_or(false);
            state.updated_at = chrono::Utc::now().to_rfc3339();

            // ストレージに保存
            self.storage.save_state(label, state)?;
        }

        Ok(())
    }

    /// ウィンドウラベルを生成
    fn generate_window_label(&self, window_type: &WindowType, connection_id: &Option<String>) -> String {
        match window_type {
            WindowType::Launcher => "launcher".to_string(),
            WindowType::QueryBuilder => {
                match connection_id {
                    Some(id) => format!("query-builder-{}", id),
                    None => format!("query-builder-{}", uuid::Uuid::new_v4()),
                }
            }
            WindowType::Settings => "settings".to_string(),
        }
    }

    /// すべてのウィンドウ状態を保存
    pub fn save_all_window_states(&self, app_handle: &AppHandle) -> Result<(), String> {
        let labels: Vec<String> = {
            let windows = self.windows.lock().unwrap();
            windows.keys().cloned().collect()
        };

        for label in labels {
            self.save_window_state(app_handle, &label)?;
        }
        Ok(())
    }

    /// 保存されたウィンドウ状態を復元
    pub fn restore_windows(&self, app_handle: &AppHandle) -> Result<Vec<WindowInfo>, String> {
        let saved_states = self.storage.load_all_states()?;
        let mut restored = Vec::new();

        for state in saved_states {
            // ランチャー以外のウィンドウを復元
            if state.window_type != WindowType::Launcher {
                let options = WindowCreateOptions {
                    title: self.generate_title(&state),
                    window_type: state.window_type.clone(),
                    connection_id: state.connection_id.clone(),
                    width: Some(state.width),
                    height: Some(state.height),
                    center: false,
                    restore_state: true,
                };

                if let Ok(info) = self.create_window(app_handle, options) {
                    restored.push(info);
                }
            }
        }

        Ok(restored)
    }

    /// ウィンドウタイトルを生成
    fn generate_title(&self, state: &WindowState) -> String {
        match state.window_type {
            WindowType::Launcher => "SQL Query Builder".to_string(),
            WindowType::QueryBuilder => "SQL Query Builder".to_string(),
            WindowType::Settings => "設定 - SQL Query Builder".to_string(),
        }
    }
}

impl Default for WindowManager {
    fn default() -> Self {
        Self::new()
    }
}
```

---

## ウィンドウ状態ストレージ

**ファイル**: `src-tauri/src/storage/window_state.rs`

```rust
use std::fs;
use std::path::PathBuf;

use crate::models::window::WindowState;

const WINDOW_STATE_FILE: &str = "window_states.json";

/// ウィンドウ状態ストレージ
pub struct WindowStateStorage {
    storage_path: PathBuf,
}

impl WindowStateStorage {
    pub fn new() -> Self {
        let storage_path = dirs::data_local_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join("sql-query-builder")
            .join(WINDOW_STATE_FILE);

        Self { storage_path }
    }

    /// ウィンドウ状態を保存
    pub fn save_state(&self, label: &str, state: &WindowState) -> Result<(), String> {
        let mut states = self.load_all_states().unwrap_or_default();

        // 同じラベルの状態を更新または追加
        if let Some(existing) = states.iter_mut().find(|s| s.id == label) {
            *existing = state.clone();
        } else {
            states.push(state.clone());
        }

        self.save_all_states(&states)
    }

    /// ウィンドウ状態を読み込み
    pub fn load_state(&self, label: &str) -> Result<WindowState, String> {
        let states = self.load_all_states()?;
        states
            .into_iter()
            .find(|s| s.id == label)
            .ok_or_else(|| "Window state not found".to_string())
    }

    /// すべてのウィンドウ状態を読み込み
    pub fn load_all_states(&self) -> Result<Vec<WindowState>, String> {
        if !self.storage_path.exists() {
            return Ok(Vec::new());
        }

        let content = fs::read_to_string(&self.storage_path)
            .map_err(|e| format!("Failed to read window states: {}", e))?;

        serde_json::from_str(&content)
            .map_err(|e| format!("Failed to parse window states: {}", e))
    }

    /// すべてのウィンドウ状態を保存
    fn save_all_states(&self, states: &[WindowState]) -> Result<(), String> {
        // ディレクトリが存在しない場合は作成
        if let Some(parent) = self.storage_path.parent() {
            fs::create_dir_all(parent)
                .map_err(|e| format!("Failed to create directory: {}", e))?;
        }

        let content = serde_json::to_string_pretty(states)
            .map_err(|e| format!("Failed to serialize window states: {}", e))?;

        fs::write(&self.storage_path, content)
            .map_err(|e| format!("Failed to write window states: {}", e))
    }

    /// ウィンドウ状態を削除
    pub fn delete_state(&self, label: &str) -> Result<(), String> {
        let mut states = self.load_all_states().unwrap_or_default();
        states.retain(|s| s.id != label);
        self.save_all_states(&states)
    }

    /// 古いウィンドウ状態をクリーンアップ（30日以上前）
    pub fn cleanup_old_states(&self) -> Result<(), String> {
        let mut states = self.load_all_states().unwrap_or_default();
        let cutoff = chrono::Utc::now() - chrono::Duration::days(30);

        states.retain(|s| {
            chrono::DateTime::parse_from_rfc3339(&s.updated_at)
                .map(|dt| dt > cutoff)
                .unwrap_or(true)
        });

        self.save_all_states(&states)
    }
}

impl Default for WindowStateStorage {
    fn default() -> Self {
        Self::new()
    }
}
```

---

## テスト設計

### ユニットテスト

**ファイル**: `src-tauri/src/models/window_test.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_window_state_creation() {
        let state = WindowState::new(WindowType::QueryBuilder, Some("conn-123".to_string()));

        assert!(!state.id.is_empty());
        assert_eq!(state.window_type, WindowType::QueryBuilder);
        assert_eq!(state.connection_id, Some("conn-123".to_string()));
        assert_eq!(state.width, 1200);
        assert_eq!(state.height, 800);
        assert!(!state.maximized);
    }

    #[test]
    fn test_window_state_creation_without_connection() {
        let state = WindowState::new(WindowType::Launcher, None);

        assert!(!state.id.is_empty());
        assert_eq!(state.window_type, WindowType::Launcher);
        assert_eq!(state.connection_id, None);
    }

    #[test]
    fn test_default_create_options() {
        let options = WindowCreateOptions::default();

        assert_eq!(options.title, "SQL Query Builder");
        assert_eq!(options.window_type, WindowType::QueryBuilder);
        assert!(options.connection_id.is_none());
        assert_eq!(options.width, Some(1200));
        assert_eq!(options.height, Some(800));
        assert!(options.center);
        assert!(options.restore_state);
    }

    #[test]
    fn test_window_type_serialization() {
        let window_type = WindowType::QueryBuilder;
        let serialized = serde_json::to_string(&window_type).unwrap();
        assert_eq!(serialized, "\"query_builder\"");

        let deserialized: WindowType = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, WindowType::QueryBuilder);
    }
}
```

---

## 実装チェックリスト

- [ ] `src-tauri/src/models/window.rs` の作成
  - [ ] WindowType enum定義
  - [ ] WindowState struct定義
  - [ ] WindowCreateOptions struct定義
  - [ ] WindowInfo struct定義
- [ ] `src-tauri/src/services/window_manager.rs` の作成
  - [ ] WindowManager struct定義
  - [ ] create_window メソッド実装
  - [ ] close_window メソッド実装
  - [ ] list_windows メソッド実装
  - [ ] find_window_by_connection メソッド実装
  - [ ] focus_window メソッド実装
  - [ ] set_window_title メソッド実装
- [ ] `src-tauri/src/storage/window_state.rs` の作成
  - [ ] WindowStateStorage struct定義
  - [ ] save_state メソッド実装
  - [ ] load_state メソッド実装
  - [ ] load_all_states メソッド実装
  - [ ] delete_state メソッド実装
- [ ] Cargo.toml への依存関係追加（uuid, chrono, dirs）
- [ ] ユニットテストの作成

---

## 依存関係

### Cargo.toml への追加

```toml
[dependencies]
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
dirs = "5.0"
```

---

## 参考資料

- [Tauri Window Management](https://tauri.app/v2/guide/window/)
- [Tauri Multi-Window](https://tauri.app/v2/guide/multiwindow/)
- [Rust std::sync::Mutex](https://doc.rust-lang.org/std/sync/struct.Mutex.html)
