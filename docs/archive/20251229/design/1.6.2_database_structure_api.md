# タスク1.6.2: データベース構造取得API実装 設計書

## 概要

**タスクID**: 1.6.2
**タスク名**: データベース構造取得API実装
**工数**: 2日
**依存関係**: 1.3.7 (接続テスト機能実装)
**完了条件**: テーブル・カラム情報取得
**UIフレームワーク**: Nuxt UI v4（Tailwind CSS 4ベース）

---

## 目的

接続済みのデータベースからスキーマ、テーブル、カラム、インデックス、外部キーなどのメタデータ情報を取得するAPIを実装する。この情報はクエリビルダーの左パネル（DB構造ツリー）で使用される。

フロントエンドではNuxt UI v4コンポーネントを使用してデータベース構造を表示します。

---

## データ設計

### データベース構造のモデル

```typescript
// src/types/database-structure.ts

/**
 * データベース構造全体
 */
export interface DatabaseStructure {
  /** 接続ID */
  connectionId: string;
  /** データベース名 */
  databaseName: string;
  /** データベース種別 */
  databaseType: 'postgresql' | 'mysql' | 'sqlite';
  /** スキーマ一覧 */
  schemas: Schema[];
  /** 取得日時 */
  fetchedAt: string;
}

/**
 * スキーマ情報
 */
export interface Schema {
  /** スキーマ名 */
  name: string;
  /** システムスキーマかどうか */
  isSystem: boolean;
  /** テーブル一覧 */
  tables: Table[];
  /** ビュー一覧 */
  views: View[];
}

/**
 * テーブル情報
 */
export interface Table {
  /** テーブル名 */
  name: string;
  /** スキーマ名 */
  schema: string;
  /** コメント/説明 */
  comment: string | null;
  /** 推定行数 */
  estimatedRowCount: number | null;
  /** カラム一覧 */
  columns: Column[];
  /** プライマリキー */
  primaryKey: PrimaryKey | null;
  /** インデックス一覧 */
  indexes: Index[];
  /** 外部キー一覧 */
  foreignKeys: ForeignKey[];
  /** 参照されている外部キー */
  referencedBy: ForeignKeyReference[];
}

/**
 * ビュー情報
 */
export interface View {
  /** ビュー名 */
  name: string;
  /** スキーマ名 */
  schema: string;
  /** コメント/説明 */
  comment: string | null;
  /** カラム一覧 */
  columns: Column[];
  /** ビュー定義SQL（オプション） */
  definition: string | null;
}

/**
 * カラム情報
 */
export interface Column {
  /** カラム名 */
  name: string;
  /** データ型 */
  dataType: string;
  /** 表示用データ型（長さ等含む） */
  displayType: string;
  /** NULL許可 */
  nullable: boolean;
  /** デフォルト値 */
  defaultValue: string | null;
  /** プライマリキーの一部か */
  isPrimaryKey: boolean;
  /** 外部キーの一部か */
  isForeignKey: boolean;
  /** ユニーク制約があるか */
  isUnique: boolean;
  /** 自動インクリメントか */
  isAutoIncrement: boolean;
  /** カラム位置（順序） */
  ordinalPosition: number;
  /** コメント/説明 */
  comment: string | null;
}

/**
 * プライマリキー情報
 */
export interface PrimaryKey {
  /** 制約名 */
  name: string;
  /** カラム名リスト */
  columns: string[];
}

/**
 * インデックス情報
 */
export interface Index {
  /** インデックス名 */
  name: string;
  /** ユニークインデックスか */
  isUnique: boolean;
  /** プライマリキーインデックスか */
  isPrimary: boolean;
  /** カラム名リスト */
  columns: string[];
  /** インデックス種別 */
  type: string;
}

/**
 * 外部キー情報
 */
export interface ForeignKey {
  /** 制約名 */
  name: string;
  /** 元カラム */
  columns: string[];
  /** 参照先スキーマ */
  referencedSchema: string;
  /** 参照先テーブル */
  referencedTable: string;
  /** 参照先カラム */
  referencedColumns: string[];
  /** ON DELETE アクション */
  onDelete: string;
  /** ON UPDATE アクション */
  onUpdate: string;
}

/**
 * 外部キー参照情報（このテーブルを参照している外部キー）
 */
export interface ForeignKeyReference {
  /** 参照元スキーマ */
  sourceSchema: string;
  /** 参照元テーブル */
  sourceTable: string;
  /** 参照元カラム */
  sourceColumns: string[];
  /** このテーブルのカラム */
  targetColumns: string[];
  /** 制約名 */
  constraintName: string;
}
```

---

## Rust バックエンド設計

### ファイル構成

```
src-tauri/src/
├── models/
│   └── database_structure.rs    # データ構造定義
├── services/
│   └── database_inspector.rs    # DB構造取得サービス
├── database/
│   ├── mod.rs
│   ├── postgresql_inspector.rs  # PostgreSQL用実装
│   ├── mysql_inspector.rs       # MySQL用実装
│   └── sqlite_inspector.rs      # SQLite用実装
└── commands/
    └── database_structure.rs    # Tauriコマンド
```

---

### models/database_structure.rs

```rust
use serde::{Deserialize, Serialize};

/// データベース構造全体
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseStructure {
    pub connection_id: String,
    pub database_name: String,
    pub database_type: String,
    pub schemas: Vec<Schema>,
    pub fetched_at: String,
}

/// スキーマ情報
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Schema {
    pub name: String,
    pub is_system: bool,
    pub tables: Vec<Table>,
    pub views: Vec<View>,
}

/// テーブル情報
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Table {
    pub name: String,
    pub schema: String,
    pub comment: Option<String>,
    pub estimated_row_count: Option<i64>,
    pub columns: Vec<Column>,
    pub primary_key: Option<PrimaryKey>,
    pub indexes: Vec<Index>,
    pub foreign_keys: Vec<ForeignKey>,
    pub referenced_by: Vec<ForeignKeyReference>,
}

/// ビュー情報
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct View {
    pub name: String,
    pub schema: String,
    pub comment: Option<String>,
    pub columns: Vec<Column>,
    pub definition: Option<String>,
}

/// カラム情報
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Column {
    pub name: String,
    pub data_type: String,
    pub display_type: String,
    pub nullable: bool,
    pub default_value: Option<String>,
    pub is_primary_key: bool,
    pub is_foreign_key: bool,
    pub is_unique: bool,
    pub is_auto_increment: bool,
    pub ordinal_position: i32,
    pub comment: Option<String>,
}

/// プライマリキー情報
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PrimaryKey {
    pub name: String,
    pub columns: Vec<String>,
}

/// インデックス情報
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Index {
    pub name: String,
    pub is_unique: bool,
    pub is_primary: bool,
    pub columns: Vec<String>,
    #[serde(rename = "type")]
    pub index_type: String,
}

/// 外部キー情報
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForeignKey {
    pub name: String,
    pub columns: Vec<String>,
    pub referenced_schema: String,
    pub referenced_table: String,
    pub referenced_columns: Vec<String>,
    pub on_delete: String,
    pub on_update: String,
}

/// 外部キー参照情報
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForeignKeyReference {
    pub source_schema: String,
    pub source_table: String,
    pub source_columns: Vec<String>,
    pub target_columns: Vec<String>,
    pub constraint_name: String,
}
```

---

### services/database_inspector.rs

```rust
use async_trait::async_trait;
use crate::models::database_structure::*;
use crate::models::connection::Connection;

/// データベース構造取得のトレイト
#[async_trait]
pub trait DatabaseInspector: Send + Sync {
    /// スキーマ一覧を取得
    async fn get_schemas(&self) -> Result<Vec<Schema>, String>;

    /// テーブル一覧を取得
    async fn get_tables(&self, schema: &str) -> Result<Vec<Table>, String>;

    /// ビュー一覧を取得
    async fn get_views(&self, schema: &str) -> Result<Vec<View>, String>;

    /// カラム一覧を取得
    async fn get_columns(&self, schema: &str, table: &str) -> Result<Vec<Column>, String>;

    /// インデックス一覧を取得
    async fn get_indexes(&self, schema: &str, table: &str) -> Result<Vec<Index>, String>;

    /// 外部キー一覧を取得
    async fn get_foreign_keys(&self, schema: &str, table: &str) -> Result<Vec<ForeignKey>, String>;

    /// 外部キー参照を取得
    async fn get_foreign_key_references(
        &self,
        schema: &str,
        table: &str,
    ) -> Result<Vec<ForeignKeyReference>, String>;

    /// データベース構造全体を取得
    async fn get_database_structure(&self) -> Result<DatabaseStructure, String>;
}

/// インスペクターファクトリ
pub struct DatabaseInspectorFactory;

impl DatabaseInspectorFactory {
    pub fn create(connection: &Connection) -> Result<Box<dyn DatabaseInspector>, String> {
        match connection.db_type.as_str() {
            "postgresql" => Ok(Box::new(
                crate::database::postgresql_inspector::PostgresqlInspector::new(connection)?
            )),
            "mysql" => Ok(Box::new(
                crate::database::mysql_inspector::MysqlInspector::new(connection)?
            )),
            "sqlite" => Ok(Box::new(
                crate::database::sqlite_inspector::SqliteInspector::new(connection)?
            )),
            _ => Err(format!("Unsupported database type: {}", connection.db_type)),
        }
    }
}
```

---

### database/postgresql_inspector.rs

```rust
use async_trait::async_trait;
use sqlx::postgres::PgPool;
use crate::models::connection::Connection;
use crate::models::database_structure::*;
use crate::services::database_inspector::DatabaseInspector;

pub struct PostgresqlInspector {
    pool: PgPool,
    database_name: String,
}

impl PostgresqlInspector {
    pub async fn new(connection: &Connection) -> Result<Self, String> {
        let connection_string = format!(
            "postgres://{}:{}@{}:{}/{}",
            connection.username,
            connection.password, // 復号化済みを想定
            connection.host,
            connection.port,
            connection.database
        );

        let pool = PgPool::connect(&connection_string)
            .await
            .map_err(|e| format!("Failed to connect: {}", e))?;

        Ok(Self {
            pool,
            database_name: connection.database.clone(),
        })
    }
}

#[async_trait]
impl DatabaseInspector for PostgresqlInspector {
    async fn get_schemas(&self) -> Result<Vec<Schema>, String> {
        let query = r#"
            SELECT
                schema_name,
                CASE
                    WHEN schema_name IN ('pg_catalog', 'information_schema', 'pg_toast')
                    THEN true
                    ELSE false
                END as is_system
            FROM information_schema.schemata
            WHERE schema_name NOT LIKE 'pg_temp_%'
              AND schema_name NOT LIKE 'pg_toast_temp_%'
            ORDER BY
                CASE WHEN schema_name = 'public' THEN 0 ELSE 1 END,
                schema_name
        "#;

        let rows = sqlx::query_as::<_, (String, bool)>(query)
            .fetch_all(&self.pool)
            .await
            .map_err(|e| format!("Failed to get schemas: {}", e))?;

        let mut schemas = Vec::new();
        for (name, is_system) in rows {
            let tables = self.get_tables(&name).await?;
            let views = self.get_views(&name).await?;

            schemas.push(Schema {
                name,
                is_system,
                tables,
                views,
            });
        }

        Ok(schemas)
    }

    async fn get_tables(&self, schema: &str) -> Result<Vec<Table>, String> {
        let query = r#"
            SELECT
                t.table_name,
                obj_description(
                    (quote_ident(t.table_schema) || '.' || quote_ident(t.table_name))::regclass
                ) as comment,
                (
                    SELECT reltuples::bigint
                    FROM pg_class
                    WHERE oid = (quote_ident(t.table_schema) || '.' || quote_ident(t.table_name))::regclass
                ) as estimated_rows
            FROM information_schema.tables t
            WHERE t.table_schema = $1
              AND t.table_type = 'BASE TABLE'
            ORDER BY t.table_name
        "#;

        let rows = sqlx::query_as::<_, (String, Option<String>, Option<i64>)>(query)
            .bind(schema)
            .fetch_all(&self.pool)
            .await
            .map_err(|e| format!("Failed to get tables: {}", e))?;

        let mut tables = Vec::new();
        for (name, comment, estimated_row_count) in rows {
            let columns = self.get_columns(schema, &name).await?;
            let indexes = self.get_indexes(schema, &name).await?;
            let foreign_keys = self.get_foreign_keys(schema, &name).await?;
            let referenced_by = self.get_foreign_key_references(schema, &name).await?;
            let primary_key = self.get_primary_key(schema, &name).await?;

            tables.push(Table {
                name,
                schema: schema.to_string(),
                comment,
                estimated_row_count,
                columns,
                primary_key,
                indexes,
                foreign_keys,
                referenced_by,
            });
        }

        Ok(tables)
    }

    async fn get_views(&self, schema: &str) -> Result<Vec<View>, String> {
        let query = r#"
            SELECT
                v.table_name,
                obj_description(
                    (quote_ident(v.table_schema) || '.' || quote_ident(v.table_name))::regclass
                ) as comment,
                pg_get_viewdef(
                    (quote_ident(v.table_schema) || '.' || quote_ident(v.table_name))::regclass
                ) as definition
            FROM information_schema.views v
            WHERE v.table_schema = $1
            ORDER BY v.table_name
        "#;

        let rows = sqlx::query_as::<_, (String, Option<String>, Option<String>)>(query)
            .bind(schema)
            .fetch_all(&self.pool)
            .await
            .map_err(|e| format!("Failed to get views: {}", e))?;

        let mut views = Vec::new();
        for (name, comment, definition) in rows {
            let columns = self.get_columns(schema, &name).await?;

            views.push(View {
                name,
                schema: schema.to_string(),
                comment,
                columns,
                definition,
            });
        }

        Ok(views)
    }

    async fn get_columns(&self, schema: &str, table: &str) -> Result<Vec<Column>, String> {
        let query = r#"
            SELECT
                c.column_name,
                c.data_type,
                CASE
                    WHEN c.character_maximum_length IS NOT NULL
                    THEN c.data_type || '(' || c.character_maximum_length || ')'
                    WHEN c.numeric_precision IS NOT NULL AND c.numeric_scale IS NOT NULL
                    THEN c.data_type || '(' || c.numeric_precision || ',' || c.numeric_scale || ')'
                    ELSE c.data_type
                END as display_type,
                c.is_nullable = 'YES' as nullable,
                c.column_default,
                COALESCE(
                    (SELECT true FROM information_schema.key_column_usage kcu
                     JOIN information_schema.table_constraints tc
                       ON kcu.constraint_name = tc.constraint_name
                      AND kcu.table_schema = tc.table_schema
                     WHERE tc.constraint_type = 'PRIMARY KEY'
                       AND kcu.table_schema = c.table_schema
                       AND kcu.table_name = c.table_name
                       AND kcu.column_name = c.column_name),
                    false
                ) as is_primary_key,
                COALESCE(
                    (SELECT true FROM information_schema.key_column_usage kcu
                     JOIN information_schema.table_constraints tc
                       ON kcu.constraint_name = tc.constraint_name
                      AND kcu.table_schema = tc.table_schema
                     WHERE tc.constraint_type = 'FOREIGN KEY'
                       AND kcu.table_schema = c.table_schema
                       AND kcu.table_name = c.table_name
                       AND kcu.column_name = c.column_name),
                    false
                ) as is_foreign_key,
                COALESCE(
                    (SELECT true FROM information_schema.key_column_usage kcu
                     JOIN information_schema.table_constraints tc
                       ON kcu.constraint_name = tc.constraint_name
                      AND kcu.table_schema = tc.table_schema
                     WHERE tc.constraint_type = 'UNIQUE'
                       AND kcu.table_schema = c.table_schema
                       AND kcu.table_name = c.table_name
                       AND kcu.column_name = c.column_name),
                    false
                ) as is_unique,
                c.column_default LIKE '%nextval%' as is_auto_increment,
                c.ordinal_position,
                col_description(
                    (quote_ident(c.table_schema) || '.' || quote_ident(c.table_name))::regclass,
                    c.ordinal_position
                ) as comment
            FROM information_schema.columns c
            WHERE c.table_schema = $1
              AND c.table_name = $2
            ORDER BY c.ordinal_position
        "#;

        let rows = sqlx::query(query)
            .bind(schema)
            .bind(table)
            .fetch_all(&self.pool)
            .await
            .map_err(|e| format!("Failed to get columns: {}", e))?;

        let columns = rows
            .iter()
            .map(|row| {
                use sqlx::Row;
                Column {
                    name: row.get("column_name"),
                    data_type: row.get("data_type"),
                    display_type: row.get("display_type"),
                    nullable: row.get("nullable"),
                    default_value: row.get("column_default"),
                    is_primary_key: row.get("is_primary_key"),
                    is_foreign_key: row.get("is_foreign_key"),
                    is_unique: row.get("is_unique"),
                    is_auto_increment: row.get("is_auto_increment"),
                    ordinal_position: row.get("ordinal_position"),
                    comment: row.get("comment"),
                }
            })
            .collect();

        Ok(columns)
    }

    async fn get_indexes(&self, schema: &str, table: &str) -> Result<Vec<Index>, String> {
        let query = r#"
            SELECT
                i.relname as index_name,
                ix.indisunique as is_unique,
                ix.indisprimary as is_primary,
                am.amname as index_type,
                array_agg(a.attname ORDER BY array_position(ix.indkey, a.attnum)) as columns
            FROM pg_index ix
            JOIN pg_class t ON t.oid = ix.indrelid
            JOIN pg_class i ON i.oid = ix.indexrelid
            JOIN pg_namespace n ON n.oid = t.relnamespace
            JOIN pg_am am ON am.oid = i.relam
            JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)
            WHERE n.nspname = $1
              AND t.relname = $2
            GROUP BY i.relname, ix.indisunique, ix.indisprimary, am.amname
            ORDER BY i.relname
        "#;

        let rows = sqlx::query(query)
            .bind(schema)
            .bind(table)
            .fetch_all(&self.pool)
            .await
            .map_err(|e| format!("Failed to get indexes: {}", e))?;

        let indexes = rows
            .iter()
            .map(|row| {
                use sqlx::Row;
                Index {
                    name: row.get("index_name"),
                    is_unique: row.get("is_unique"),
                    is_primary: row.get("is_primary"),
                    columns: row.get("columns"),
                    index_type: row.get("index_type"),
                }
            })
            .collect();

        Ok(indexes)
    }

    async fn get_foreign_keys(&self, schema: &str, table: &str) -> Result<Vec<ForeignKey>, String> {
        let query = r#"
            SELECT
                tc.constraint_name,
                array_agg(kcu.column_name ORDER BY kcu.ordinal_position) as columns,
                ccu.table_schema as referenced_schema,
                ccu.table_name as referenced_table,
                array_agg(ccu.column_name ORDER BY kcu.ordinal_position) as referenced_columns,
                rc.delete_rule as on_delete,
                rc.update_rule as on_update
            FROM information_schema.table_constraints tc
            JOIN information_schema.key_column_usage kcu
              ON tc.constraint_name = kcu.constraint_name
             AND tc.table_schema = kcu.table_schema
            JOIN information_schema.constraint_column_usage ccu
              ON tc.constraint_name = ccu.constraint_name
             AND tc.table_schema = ccu.table_schema
            JOIN information_schema.referential_constraints rc
              ON tc.constraint_name = rc.constraint_name
             AND tc.table_schema = rc.constraint_schema
            WHERE tc.constraint_type = 'FOREIGN KEY'
              AND tc.table_schema = $1
              AND tc.table_name = $2
            GROUP BY tc.constraint_name, ccu.table_schema, ccu.table_name,
                     rc.delete_rule, rc.update_rule
        "#;

        let rows = sqlx::query(query)
            .bind(schema)
            .bind(table)
            .fetch_all(&self.pool)
            .await
            .map_err(|e| format!("Failed to get foreign keys: {}", e))?;

        let foreign_keys = rows
            .iter()
            .map(|row| {
                use sqlx::Row;
                ForeignKey {
                    name: row.get("constraint_name"),
                    columns: row.get("columns"),
                    referenced_schema: row.get("referenced_schema"),
                    referenced_table: row.get("referenced_table"),
                    referenced_columns: row.get("referenced_columns"),
                    on_delete: row.get("on_delete"),
                    on_update: row.get("on_update"),
                }
            })
            .collect();

        Ok(foreign_keys)
    }

    async fn get_foreign_key_references(
        &self,
        schema: &str,
        table: &str,
    ) -> Result<Vec<ForeignKeyReference>, String> {
        let query = r#"
            SELECT
                tc.table_schema as source_schema,
                tc.table_name as source_table,
                array_agg(kcu.column_name ORDER BY kcu.ordinal_position) as source_columns,
                array_agg(ccu.column_name ORDER BY kcu.ordinal_position) as target_columns,
                tc.constraint_name
            FROM information_schema.table_constraints tc
            JOIN information_schema.key_column_usage kcu
              ON tc.constraint_name = kcu.constraint_name
             AND tc.table_schema = kcu.table_schema
            JOIN information_schema.constraint_column_usage ccu
              ON tc.constraint_name = ccu.constraint_name
             AND tc.table_schema = ccu.table_schema
            WHERE tc.constraint_type = 'FOREIGN KEY'
              AND ccu.table_schema = $1
              AND ccu.table_name = $2
            GROUP BY tc.table_schema, tc.table_name, tc.constraint_name
        "#;

        let rows = sqlx::query(query)
            .bind(schema)
            .bind(table)
            .fetch_all(&self.pool)
            .await
            .map_err(|e| format!("Failed to get foreign key references: {}", e))?;

        let references = rows
            .iter()
            .map(|row| {
                use sqlx::Row;
                ForeignKeyReference {
                    source_schema: row.get("source_schema"),
                    source_table: row.get("source_table"),
                    source_columns: row.get("source_columns"),
                    target_columns: row.get("target_columns"),
                    constraint_name: row.get("constraint_name"),
                }
            })
            .collect();

        Ok(references)
    }

    async fn get_database_structure(&self) -> Result<DatabaseStructure, String> {
        let schemas = self.get_schemas().await?;

        Ok(DatabaseStructure {
            connection_id: String::new(), // 呼び出し元で設定
            database_name: self.database_name.clone(),
            database_type: "postgresql".to_string(),
            schemas,
            fetched_at: chrono::Utc::now().to_rfc3339(),
        })
    }
}

impl PostgresqlInspector {
    async fn get_primary_key(&self, schema: &str, table: &str) -> Result<Option<PrimaryKey>, String> {
        let query = r#"
            SELECT
                tc.constraint_name,
                array_agg(kcu.column_name ORDER BY kcu.ordinal_position) as columns
            FROM information_schema.table_constraints tc
            JOIN information_schema.key_column_usage kcu
              ON tc.constraint_name = kcu.constraint_name
             AND tc.table_schema = kcu.table_schema
            WHERE tc.constraint_type = 'PRIMARY KEY'
              AND tc.table_schema = $1
              AND tc.table_name = $2
            GROUP BY tc.constraint_name
        "#;

        let row = sqlx::query(query)
            .bind(schema)
            .bind(table)
            .fetch_optional(&self.pool)
            .await
            .map_err(|e| format!("Failed to get primary key: {}", e))?;

        if let Some(row) = row {
            use sqlx::Row;
            Ok(Some(PrimaryKey {
                name: row.get("constraint_name"),
                columns: row.get("columns"),
            }))
        } else {
            Ok(None)
        }
    }
}
```

---

### commands/database_structure.rs

```rust
use tauri::{command, State};
use crate::models::database_structure::*;
use crate::services::database_inspector::DatabaseInspectorFactory;
use crate::services::connection_service::ConnectionService;

/// データベース構造を取得
#[command]
pub async fn get_database_structure(
    connection_id: String,
    connection_service: State<'_, ConnectionService>,
) -> Result<DatabaseStructure, String> {
    // 接続情報を取得
    let connection = connection_service
        .get_connection(&connection_id)
        .await?
        .ok_or_else(|| format!("Connection not found: {}", connection_id))?;

    // インスペクターを作成
    let inspector = DatabaseInspectorFactory::create(&connection)?;

    // 構造を取得
    let mut structure = inspector.get_database_structure().await?;
    structure.connection_id = connection_id;

    Ok(structure)
}

/// スキーマ一覧のみ取得
#[command]
pub async fn get_schemas(
    connection_id: String,
    connection_service: State<'_, ConnectionService>,
) -> Result<Vec<Schema>, String> {
    let connection = connection_service
        .get_connection(&connection_id)
        .await?
        .ok_or_else(|| format!("Connection not found: {}", connection_id))?;

    let inspector = DatabaseInspectorFactory::create(&connection)?;
    inspector.get_schemas().await
}

/// テーブル一覧のみ取得
#[command]
pub async fn get_tables(
    connection_id: String,
    schema: String,
    connection_service: State<'_, ConnectionService>,
) -> Result<Vec<Table>, String> {
    let connection = connection_service
        .get_connection(&connection_id)
        .await?
        .ok_or_else(|| format!("Connection not found: {}", connection_id))?;

    let inspector = DatabaseInspectorFactory::create(&connection)?;
    inspector.get_tables(&schema).await
}

/// カラム一覧のみ取得
#[command]
pub async fn get_columns(
    connection_id: String,
    schema: String,
    table: String,
    connection_service: State<'_, ConnectionService>,
) -> Result<Vec<Column>, String> {
    let connection = connection_service
        .get_connection(&connection_id)
        .await?
        .ok_or_else(|| format!("Connection not found: {}", connection_id))?;

    let inspector = DatabaseInspectorFactory::create(&connection)?;
    inspector.get_columns(&schema, &table).await
}
```

---

## フロントエンド API クライアント

### src/api/database-structure.ts

```typescript
import { invoke } from '@tauri-apps/api/core';
import type {
  DatabaseStructure,
  Schema,
  Table,
  Column,
} from '@/types/database-structure';

/**
 * データベース構造取得API
 */
export const databaseStructureApi = {
  /**
   * データベース構造全体を取得
   */
  async getDatabaseStructure(connectionId: string): Promise<DatabaseStructure> {
    return invoke('get_database_structure', { connectionId });
  },

  /**
   * スキーマ一覧を取得
   */
  async getSchemas(connectionId: string): Promise<Schema[]> {
    return invoke('get_schemas', { connectionId });
  },

  /**
   * テーブル一覧を取得
   */
  async getTables(connectionId: string, schema: string): Promise<Table[]> {
    return invoke('get_tables', { connectionId, schema });
  },

  /**
   * カラム一覧を取得
   */
  async getColumns(
    connectionId: string,
    schema: string,
    table: string
  ): Promise<Column[]> {
    return invoke('get_columns', { connectionId, schema, table });
  },
};
```

---

## 状態管理

### src/stores/database-structure.ts

```typescript
import { defineStore } from 'pinia';
import { databaseStructureApi } from '@/api/database-structure';
import type {
  DatabaseStructure,
  Schema,
  Table,
} from '@/types/database-structure';

interface DatabaseStructureState {
  /** 接続IDごとの構造データ */
  structures: Record<string, DatabaseStructure>;
  /** 読み込み中の接続ID */
  loadingIds: Set<string>;
  /** エラー情報 */
  errors: Record<string, string>;
}

export const useDatabaseStructureStore = defineStore('database-structure', {
  state: (): DatabaseStructureState => ({
    structures: {},
    loadingIds: new Set(),
    errors: {},
  }),

  getters: {
    /**
     * 接続IDから構造を取得
     */
    getStructure:
      (state) =>
      (connectionId: string): DatabaseStructure | null => {
        return state.structures[connectionId] || null;
      },

    /**
     * 読み込み中かどうか
     */
    isLoading:
      (state) =>
      (connectionId: string): boolean => {
        return state.loadingIds.has(connectionId);
      },

    /**
     * エラーを取得
     */
    getError:
      (state) =>
      (connectionId: string): string | null => {
        return state.errors[connectionId] || null;
      },
  },

  actions: {
    /**
     * データベース構造を取得
     */
    async fetchDatabaseStructure(connectionId: string): Promise<void> {
      if (this.loadingIds.has(connectionId)) return;

      this.loadingIds.add(connectionId);
      delete this.errors[connectionId];

      try {
        const structure = await databaseStructureApi.getDatabaseStructure(connectionId);
        this.structures[connectionId] = structure;
      } catch (error) {
        this.errors[connectionId] =
          error instanceof Error ? error.message : 'Unknown error';
        throw error;
      } finally {
        this.loadingIds.delete(connectionId);
      }
    },

    /**
     * 構造を更新（再取得）
     */
    async refreshDatabaseStructure(connectionId: string): Promise<void> {
      delete this.structures[connectionId];
      await this.fetchDatabaseStructure(connectionId);
    },

    /**
     * キャッシュをクリア
     */
    clearCache(connectionId?: string): void {
      if (connectionId) {
        delete this.structures[connectionId];
        delete this.errors[connectionId];
      } else {
        this.structures = {};
        this.errors = {};
      }
    },
  },
});
```

---

## キャッシュ戦略

### キャッシュポリシー

| データ | キャッシュ期間 | 更新トリガー |
|--------|--------------|-------------|
| スキーマ一覧 | セッション中 | 手動更新 |
| テーブル一覧 | セッション中 | 手動更新 |
| カラム情報 | セッション中 | 手動更新 |
| インデックス | セッション中 | 手動更新 |
| 外部キー | セッション中 | 手動更新 |

### 遅延読み込み

大規模データベースへの対応として、以下の遅延読み込み戦略を採用：

1. **初期表示**: スキーマ一覧のみ取得
2. **スキーマ展開時**: そのスキーマのテーブル・ビュー一覧を取得
3. **テーブル展開時**: そのテーブルのカラム・インデックス・外部キーを取得

---

## エラーハンドリング

### エラー種別

| エラー種別 | 対処 |
|-----------|------|
| 接続エラー | 再接続を促すダイアログ表示 |
| 権限エラー | 権限不足のメッセージ表示 |
| タイムアウト | リトライボタン表示 |
| 不明なエラー | エラー詳細とサポート連絡先表示 |

---

## テスト設計

### ユニットテスト

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_get_schemas() {
        // モックデータベースでスキーマ取得をテスト
    }

    #[tokio::test]
    async fn test_get_tables() {
        // モックデータベースでテーブル取得をテスト
    }

    #[tokio::test]
    async fn test_get_columns() {
        // モックデータベースでカラム取得をテスト
    }
}
```

### 統合テスト

```
シナリオ1: PostgreSQL構造取得
1. PostgreSQLテストDBに接続
2. スキーマ一覧を取得
3. publicスキーマのテーブル一覧を取得
4. usersテーブルのカラム一覧を取得
5. 各情報が正しく取得できていることを確認

シナリオ2: 外部キー情報取得
1. 外部キーを持つテーブルのカラム情報を取得
2. 外部キー情報が正しく含まれていることを確認
3. 参照先テーブル情報が正しいことを確認
```

---

## 実装チェックリスト

- [ ] `src-tauri/src/models/database_structure.rs` の作成
- [ ] `src-tauri/src/services/database_inspector.rs` の作成
- [ ] `src-tauri/src/database/postgresql_inspector.rs` の作成
- [ ] `src-tauri/src/database/mysql_inspector.rs` の作成
- [ ] `src-tauri/src/database/sqlite_inspector.rs` の作成
- [ ] `src-tauri/src/commands/database_structure.rs` の作成
- [ ] `src/types/database-structure.ts` の作成
- [ ] `src/api/database-structure.ts` の作成
- [ ] `src/stores/database-structure.ts` の作成
- [ ] キャッシュ機能の実装
- [ ] エラーハンドリングの実装
- [ ] ユニットテストの作成
- [ ] 統合テストの作成

---

## 参考資料

- [Nuxt UI v4 Documentation](https://ui.nuxt.com/)
- [Nuxt UI Components](https://ui.nuxt.com/components)
- [PostgreSQL Information Schema](https://www.postgresql.org/docs/current/information-schema.html)
- [MySQL Information Schema](https://dev.mysql.com/doc/refman/8.0/en/information-schema.html)
- [SQLite sqlite_master](https://www.sqlite.org/schematab.html)
- [sqlx-rs](https://github.com/launchbadge/sqlx)
