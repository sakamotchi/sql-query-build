# 1.5a.1 SecurityProvider trait設計・実装

## 概要

| 項目 | 内容 |
|------|------|
| タスクID | 1.5a.1 |
| タスク名 | SecurityProvider trait設計・実装 |
| 担当 | BE |
| 工数 | 1日 |
| 依存関係 | 1.2.3 |
| 完了条件 | trait定義完了、テスト作成 |

## 目的

DBeaverの設計を参考に、複数のセキュリティプロバイダー（Simple/Master Password/OS Keychain）を統一的に扱うためのtrait（インターフェース）を設計・実装する。

これにより：
- プロバイダーの追加・変更が容易
- 各プロバイダーの実装を独立して開発可能
- テスト時にモックプロバイダーを使用可能

## アーキテクチャ

### モジュール構成

```
src-tauri/src/
├── crypto/
│   ├── mod.rs                    # 既存（security_providerを追加）
│   ├── encryption.rs             # 既存
│   ├── error.rs                  # 既存
│   ├── types.rs                  # 既存
│   ├── master_key/               # 既存
│   └── security_provider/        # 新規追加
│       ├── mod.rs                # モジュールエントリポイント
│       ├── traits.rs             # SecurityProvider trait定義
│       ├── types.rs              # 共通型定義
│       ├── error.rs              # エラー型定義
│       ├── simple.rs             # SimpleProvider（1.5a.2）
│       ├── master_password.rs    # MasterPasswordProvider（1.5a.3）
│       ├── keychain.rs           # KeychainProvider（1.5a.4）
│       └── manager.rs            # SecurityProviderManager
```

## データモデル

### セキュリティプロバイダー種別

```rust
use serde::{Deserialize, Serialize};

/// セキュリティプロバイダーの種別
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SecurityProviderType {
    /// シンプルプロバイダー（固定キー暗号化）
    Simple,

    /// マスターパスワードプロバイダー
    MasterPassword,

    /// OSキーチェーンプロバイダー
    Keychain,
}

impl Default for SecurityProviderType {
    fn default() -> Self {
        Self::Simple
    }
}

impl SecurityProviderType {
    /// 表示名を取得
    pub fn display_name(&self) -> &'static str {
        match self {
            Self::Simple => "Simple (Default)",
            Self::MasterPassword => "Master Password",
            Self::Keychain => "OS Keychain",
        }
    }

    /// 説明を取得
    pub fn description(&self) -> &'static str {
        match self {
            Self::Simple => "アプリ固定のキーで暗号化。パスワード入力不要。",
            Self::MasterPassword => "ユーザー設定のパスワードで暗号化。起動時に入力が必要。",
            Self::Keychain => "OSのセキュアストレージを使用。OS認証が必要な場合あり。",
        }
    }

    /// セキュリティレベル（1-3）
    pub fn security_level(&self) -> u8 {
        match self {
            Self::Simple => 1,
            Self::MasterPassword => 2,
            Self::Keychain => 3,
        }
    }

    /// アンロックが必要かどうか
    pub fn requires_unlock(&self) -> bool {
        match self {
            Self::Simple => false,
            Self::MasterPassword => true,
            Self::Keychain => false, // OSが自動的に認証
        }
    }
}
```

### プロバイダー状態

```rust
/// プロバイダーの状態
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ProviderState {
    /// 未初期化（初回セットアップが必要）
    Uninitialized,

    /// ロック中（アンロックが必要）
    Locked,

    /// 利用可能
    Ready,

    /// エラー状態
    Error(String),
}

impl ProviderState {
    pub fn is_ready(&self) -> bool {
        matches!(self, Self::Ready)
    }

    pub fn is_locked(&self) -> bool {
        matches!(self, Self::Locked)
    }
}
```

## SecurityProvider trait定義

```rust
use async_trait::async_trait;

/// セキュリティプロバイダーのtrait
///
/// 各プロバイダーはこのtraitを実装することで、
/// 統一的なインターフェースで暗号化キーを提供する。
#[async_trait]
pub trait SecurityProvider: Send + Sync {
    /// プロバイダーの種別を取得
    fn provider_type(&self) -> SecurityProviderType;

    /// プロバイダーの現在の状態を取得
    fn state(&self) -> ProviderState;

    /// 初期化が必要かどうか
    fn needs_initialization(&self) -> bool;

    /// アンロックが必要かどうか
    fn needs_unlock(&self) -> bool;

    /// プロバイダーを初期化
    ///
    /// # Arguments
    /// * `params` - 初期化パラメータ（プロバイダーごとに異なる）
    ///
    /// # Returns
    /// 初期化に成功した場合は Ok(())
    async fn initialize(&mut self, params: InitializeParams) -> SecurityProviderResult<()>;

    /// プロバイダーをアンロック
    ///
    /// # Arguments
    /// * `params` - アンロックパラメータ（プロバイダーごとに異なる）
    ///
    /// # Returns
    /// アンロックに成功した場合は Ok(())
    async fn unlock(&mut self, params: UnlockParams) -> SecurityProviderResult<()>;

    /// プロバイダーをロック（メモリ上のキーをクリア）
    async fn lock(&mut self);

    /// 暗号化キーを取得
    ///
    /// # Returns
    /// 暗号化に使用する32バイトのキー
    ///
    /// # Errors
    /// プロバイダーがReadyでない場合はエラー
    async fn get_encryption_key(&self) -> SecurityProviderResult<Vec<u8>>;

    /// プロバイダーをリセット（すべての設定を削除）
    async fn reset(&mut self) -> SecurityProviderResult<()>;

    /// プロバイダーの設定を検証
    fn validate(&self) -> SecurityProviderResult<()>;
}
```

### パラメータ型

```rust
/// 初期化パラメータ
#[derive(Debug, Clone)]
pub enum InitializeParams {
    /// Simpleプロバイダー（パラメータなし）
    Simple,

    /// マスターパスワードプロバイダー
    MasterPassword {
        /// 設定するマスターパスワード
        password: String,
        /// パスワード確認用
        password_confirm: String,
    },

    /// キーチェーンプロバイダー（パラメータなし）
    Keychain,
}

/// アンロックパラメータ
#[derive(Debug, Clone)]
pub enum UnlockParams {
    /// Simpleプロバイダー（パラメータなし）
    Simple,

    /// マスターパスワードプロバイダー
    MasterPassword {
        /// マスターパスワード
        password: String,
    },

    /// キーチェーンプロバイダー（パラメータなし）
    Keychain,
}
```

## エラー型定義

```rust
use thiserror::Error;

/// セキュリティプロバイダーのエラー型
#[derive(Debug, Error)]
pub enum SecurityProviderError {
    /// 未初期化エラー
    #[error("Provider is not initialized")]
    NotInitialized,

    /// ロック中エラー
    #[error("Provider is locked")]
    Locked,

    /// 既に初期化済み
    #[error("Provider is already initialized")]
    AlreadyInitialized,

    /// パスワード不一致
    #[error("Passwords do not match")]
    PasswordMismatch,

    /// パスワードが弱い
    #[error("Password is too weak: {0}")]
    WeakPassword(String),

    /// 認証失敗
    #[error("Authentication failed")]
    AuthenticationFailed,

    /// キーチェーンエラー
    #[error("Keychain error: {0}")]
    KeychainError(String),

    /// 暗号化エラー
    #[error("Encryption error: {0}")]
    EncryptionError(String),

    /// ストレージエラー
    #[error("Storage error: {0}")]
    StorageError(String),

    /// 無効なパラメータ
    #[error("Invalid parameters: {0}")]
    InvalidParams(String),

    /// 内部エラー
    #[error("Internal error: {0}")]
    Internal(String),
}

pub type SecurityProviderResult<T> = Result<T, SecurityProviderError>;
```

## SecurityProviderManager

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

/// セキュリティプロバイダーを管理するマネージャー
pub struct SecurityProviderManager {
    /// 現在のプロバイダー
    provider: Arc<RwLock<Box<dyn SecurityProvider>>>,

    /// 設定ストレージ
    config_storage: Arc<SecurityConfigStorage>,
}

impl SecurityProviderManager {
    /// 新しいマネージャーを作成
    pub async fn new(config_storage: Arc<SecurityConfigStorage>) -> SecurityProviderResult<Self> {
        let config = config_storage.load().await?;
        let provider = Self::create_provider(config.provider_type)?;

        Ok(Self {
            provider: Arc::new(RwLock::new(provider)),
            config_storage,
        })
    }

    /// プロバイダーを作成
    fn create_provider(
        provider_type: SecurityProviderType,
    ) -> SecurityProviderResult<Box<dyn SecurityProvider>> {
        match provider_type {
            SecurityProviderType::Simple => {
                Ok(Box::new(SimpleProvider::new()))
            }
            SecurityProviderType::MasterPassword => {
                Ok(Box::new(MasterPasswordProvider::new()))
            }
            SecurityProviderType::Keychain => {
                Ok(Box::new(KeychainProvider::new()))
            }
        }
    }

    /// 現在のプロバイダー種別を取得
    pub async fn current_provider_type(&self) -> SecurityProviderType {
        self.provider.read().await.provider_type()
    }

    /// プロバイダーの状態を取得
    pub async fn state(&self) -> ProviderState {
        self.provider.read().await.state()
    }

    /// プロバイダーを初期化
    pub async fn initialize(&self, params: InitializeParams) -> SecurityProviderResult<()> {
        let mut provider = self.provider.write().await;
        provider.initialize(params).await
    }

    /// プロバイダーをアンロック
    pub async fn unlock(&self, params: UnlockParams) -> SecurityProviderResult<()> {
        let mut provider = self.provider.write().await;
        provider.unlock(params).await
    }

    /// プロバイダーをロック
    pub async fn lock(&self) {
        let mut provider = self.provider.write().await;
        provider.lock().await;
    }

    /// 暗号化キーを取得
    pub async fn get_encryption_key(&self) -> SecurityProviderResult<Vec<u8>> {
        let provider = self.provider.read().await;
        provider.get_encryption_key().await
    }

    /// プロバイダーを変更
    ///
    /// # Note
    /// プロバイダー変更時は、既存の認証情報を新しいプロバイダーで
    /// 再暗号化する必要がある（1.5a.7で実装）
    pub async fn change_provider(
        &self,
        new_type: SecurityProviderType,
    ) -> SecurityProviderResult<()> {
        // 現在のプロバイダーで認証情報を復号化
        // 新しいプロバイダーを作成
        // 認証情報を再暗号化
        // 設定を保存

        let new_provider = Self::create_provider(new_type)?;

        let mut provider = self.provider.write().await;
        *provider = new_provider;

        // 設定を更新
        let mut config = self.config_storage.load().await?;
        config.provider_type = new_type;
        self.config_storage.save(&config).await?;

        Ok(())
    }
}
```

## フロントエンド向けTauriコマンド

```rust
use tauri::State;

/// プロバイダー情報（フロントエンド向け）
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SecurityProviderInfo {
    pub provider_type: SecurityProviderType,
    pub state: String,
    pub needs_initialization: bool,
    pub needs_unlock: bool,
    pub display_name: String,
    pub description: String,
    pub security_level: u8,
}

/// 現在のセキュリティプロバイダー情報を取得
#[tauri::command]
pub async fn get_security_provider_info(
    manager: State<'_, Arc<SecurityProviderManager>>,
) -> Result<SecurityProviderInfo, String> {
    let provider = manager.provider.read().await;

    Ok(SecurityProviderInfo {
        provider_type: provider.provider_type(),
        state: format!("{:?}", provider.state()),
        needs_initialization: provider.needs_initialization(),
        needs_unlock: provider.needs_unlock(),
        display_name: provider.provider_type().display_name().to_string(),
        description: provider.provider_type().description().to_string(),
        security_level: provider.provider_type().security_level(),
    })
}

/// 利用可能なプロバイダー一覧を取得
#[tauri::command]
pub async fn get_available_providers() -> Vec<SecurityProviderInfo> {
    vec![
        SecurityProviderInfo {
            provider_type: SecurityProviderType::Simple,
            state: "available".to_string(),
            needs_initialization: false,
            needs_unlock: false,
            display_name: SecurityProviderType::Simple.display_name().to_string(),
            description: SecurityProviderType::Simple.description().to_string(),
            security_level: SecurityProviderType::Simple.security_level(),
        },
        SecurityProviderInfo {
            provider_type: SecurityProviderType::MasterPassword,
            state: "available".to_string(),
            needs_initialization: true,
            needs_unlock: true,
            display_name: SecurityProviderType::MasterPassword.display_name().to_string(),
            description: SecurityProviderType::MasterPassword.description().to_string(),
            security_level: SecurityProviderType::MasterPassword.security_level(),
        },
        SecurityProviderInfo {
            provider_type: SecurityProviderType::Keychain,
            state: "available".to_string(),
            needs_initialization: false,
            needs_unlock: false,
            display_name: SecurityProviderType::Keychain.display_name().to_string(),
            description: SecurityProviderType::Keychain.description().to_string(),
            security_level: SecurityProviderType::Keychain.security_level(),
        },
    ]
}
```

## TypeScript型定義

```typescript
// src/types/security.ts

/**
 * セキュリティプロバイダーの種別
 */
export type SecurityProviderType = 'simple' | 'master_password' | 'keychain';

/**
 * プロバイダーの状態
 */
export type ProviderState =
  | 'uninitialized'
  | 'locked'
  | 'ready'
  | 'error';

/**
 * セキュリティプロバイダー情報
 */
export interface SecurityProviderInfo {
  providerType: SecurityProviderType;
  state: ProviderState;
  needsInitialization: boolean;
  needsUnlock: boolean;
  displayName: string;
  description: string;
  securityLevel: number;
}

/**
 * 初期化パラメータ
 */
export type InitializeParams =
  | { type: 'simple' }
  | { type: 'master_password'; password: string; passwordConfirm: string }
  | { type: 'keychain' };

/**
 * アンロックパラメータ
 */
export type UnlockParams =
  | { type: 'simple' }
  | { type: 'master_password'; password: string }
  | { type: 'keychain' };
```

## テスト

### ユニットテスト

```rust
#[cfg(test)]
mod tests {
    use super::*;

    /// モックプロバイダー（テスト用）
    pub struct MockProvider {
        provider_type: SecurityProviderType,
        state: ProviderState,
        key: Option<Vec<u8>>,
    }

    impl MockProvider {
        pub fn new(provider_type: SecurityProviderType) -> Self {
            Self {
                provider_type,
                state: ProviderState::Uninitialized,
                key: None,
            }
        }

        pub fn with_state(mut self, state: ProviderState) -> Self {
            self.state = state;
            self
        }

        pub fn with_key(mut self, key: Vec<u8>) -> Self {
            self.key = Some(key);
            self.state = ProviderState::Ready;
            self
        }
    }

    #[async_trait]
    impl SecurityProvider for MockProvider {
        fn provider_type(&self) -> SecurityProviderType {
            self.provider_type
        }

        fn state(&self) -> ProviderState {
            self.state.clone()
        }

        fn needs_initialization(&self) -> bool {
            matches!(self.state, ProviderState::Uninitialized)
        }

        fn needs_unlock(&self) -> bool {
            matches!(self.state, ProviderState::Locked)
        }

        async fn initialize(&mut self, _params: InitializeParams) -> SecurityProviderResult<()> {
            self.key = Some(vec![0u8; 32]);
            self.state = ProviderState::Ready;
            Ok(())
        }

        async fn unlock(&mut self, _params: UnlockParams) -> SecurityProviderResult<()> {
            self.state = ProviderState::Ready;
            Ok(())
        }

        async fn lock(&mut self) {
            self.state = ProviderState::Locked;
        }

        async fn get_encryption_key(&self) -> SecurityProviderResult<Vec<u8>> {
            self.key.clone().ok_or(SecurityProviderError::NotInitialized)
        }

        async fn reset(&mut self) -> SecurityProviderResult<()> {
            self.key = None;
            self.state = ProviderState::Uninitialized;
            Ok(())
        }

        fn validate(&self) -> SecurityProviderResult<()> {
            Ok(())
        }
    }

    #[test]
    fn test_security_provider_type_default() {
        let default = SecurityProviderType::default();
        assert_eq!(default, SecurityProviderType::Simple);
    }

    #[test]
    fn test_security_provider_type_display_name() {
        assert_eq!(SecurityProviderType::Simple.display_name(), "Simple (Default)");
        assert_eq!(SecurityProviderType::MasterPassword.display_name(), "Master Password");
        assert_eq!(SecurityProviderType::Keychain.display_name(), "OS Keychain");
    }

    #[test]
    fn test_security_provider_type_security_level() {
        assert_eq!(SecurityProviderType::Simple.security_level(), 1);
        assert_eq!(SecurityProviderType::MasterPassword.security_level(), 2);
        assert_eq!(SecurityProviderType::Keychain.security_level(), 3);
    }

    #[test]
    fn test_security_provider_type_requires_unlock() {
        assert!(!SecurityProviderType::Simple.requires_unlock());
        assert!(SecurityProviderType::MasterPassword.requires_unlock());
        assert!(!SecurityProviderType::Keychain.requires_unlock());
    }

    #[tokio::test]
    async fn test_mock_provider_lifecycle() {
        let mut provider = MockProvider::new(SecurityProviderType::Simple);

        // 初期状態
        assert!(provider.needs_initialization());
        assert!(!provider.needs_unlock());

        // 初期化
        provider.initialize(InitializeParams::Simple).await.unwrap();
        assert!(!provider.needs_initialization());
        assert!(provider.state().is_ready());

        // キー取得
        let key = provider.get_encryption_key().await.unwrap();
        assert_eq!(key.len(), 32);

        // ロック
        provider.lock().await;
        assert!(provider.state().is_locked());

        // リセット
        provider.reset().await.unwrap();
        assert!(provider.needs_initialization());
    }

    #[test]
    fn test_provider_state_checks() {
        assert!(ProviderState::Ready.is_ready());
        assert!(!ProviderState::Locked.is_ready());

        assert!(ProviderState::Locked.is_locked());
        assert!(!ProviderState::Ready.is_locked());
    }
}
```

## 実装チェックリスト

- [ ] `SecurityProviderType` enum実装
- [ ] `ProviderState` enum実装
- [ ] `SecurityProvider` trait定義
- [ ] `InitializeParams` / `UnlockParams` 型定義
- [ ] `SecurityProviderError` エラー型定義
- [ ] `SecurityProviderManager` 実装
- [ ] Tauriコマンド実装（`get_security_provider_info`, `get_available_providers`）
- [ ] TypeScript型定義
- [ ] モックプロバイダー実装
- [ ] ユニットテスト作成
- [ ] ドキュメント作成

## 次のステップ

1. **1.5a.2 SimpleProvider実装**: 固定キー暗号化プロバイダー
2. **1.5a.3 MasterPasswordProvider実装**: マスターパスワードプロバイダー
3. **1.5a.4 KeychainProvider実装**: OSキーチェーンプロバイダー

---

**作成日**: 2025-11-24
**作成者**: Claude Code
