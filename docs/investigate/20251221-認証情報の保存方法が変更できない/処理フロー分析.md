# セキュリティプロバイダー変更の処理フロー分析

## 問題の概要

**症状**: 設定ページのセキュリティタブで、マスターパスワードからSimpleに変更しても、再表示するとマスターパスワードのままになる

**確認済みの事実**:
- ストレージファイル: `/Users/sakamotoyoshitaka/Library/Application Support/com.sqlquerybuilder.sql-query-builder/settings/security-config.json`
- ファイル内容: `provider_type: "master_password"` のまま（変更されていない）

---

## 処理フロー

### 1. フロントエンド: プロバイダー変更の開始

#### 1.1 SecuritySettings.vue - ユーザーがプロバイダーを選択

**ファイル**: `app/components/settings/SecuritySettings.vue`

```vue
<USelect
  :model-value="settings.provider"
  :items="providerOptions"
  @update:model-value="updateProvider"
/>
```

**処理**: `updateProvider` メソッドが呼ばれる

```typescript
const updateProvider = (provider: SecurityProvider) => {
  console.log('[SecuritySettings] updateProvider called', {
    selectedProvider: provider,
    currentProvider: settings.value.provider,
    willSkip: provider === settings.value.provider
  })

  // 同じプロバイダーの場合はスキップ
  if (provider === settings.value.provider) {
    return
  }

  // ProviderChangeDialog のパラメータを設定
  providerChangeParams.value = {
    from: settings.value.provider,
    to: provider
  }

  // ダイアログを開く
  showProviderChangeDialog.value = true
}
```

---

#### 1.2 ProviderChangeDialog.vue - プロバイダー変更ダイアログ

**ファイル**: `app/components/security/ProviderChangeDialog.vue`

**フェーズ**: `confirm` → `authenticate` → `initialize` → `switching` → `complete`

##### Phase 1: confirm（確認）
- ユーザーに変更内容を確認
- 「続行」ボタンをクリック → `nextPhase()` 呼び出し

##### Phase 2: authenticate（認証）
- **条件**: `from` が `master-password` の場合のみ
- マスターパスワード入力
- 「認証」ボタンをクリック → `verifyMasterPassword()` 呼び出し
- 成功したら `initialize` フェーズへ

```typescript
if (currentPhase.value === 'authenticate') {
  const success = await securityStore.verifyMasterPassword(currentPassword.value)
  if (!success) {
    errorMessage.value = 'パスワードが正しくありません'
    return
  }
  currentPhase.value = 'initialize'
  return
}
```

##### Phase 3: initialize（初期化）
- **条件**: `to` が `master-password` の場合のみパスワード設定が必要
- Simpleへの変更の場合は、このフェーズは表示されず直接 `switching` へ
- 「変更」ボタンをクリック → `switchProvider()` 呼び出し

```typescript
if (currentPhase.value === 'initialize') {
  currentPhase.value = 'switching'
  await switchProvider()
}
```

##### Phase 4: switching（切り替え中）
- バックエンドの `switch_security_provider` コマンドを呼び出し

```typescript
const switchProvider = async () => {
  const { invokeCommand } = useTauri()

  const params = {
    targetProvider: toBackendProvider(props.params.to),  // "simple" or "master_password"
    currentPassword: props.params.from === 'master-password' ? currentPassword.value : null,
    newPassword: props.params.to === 'master-password' ? newPassword.value : null,
    newPasswordConfirm: props.params.to === 'master-password' ? newPasswordConfirm.value : null
  }

  console.log('[ProviderChangeDialog] Calling switch_security_provider with params:', params)

  await invokeCommand('switch_security_provider', params)

  currentPhase.value = 'complete'

  // 設定を再読み込み
  await securityStore.loadSettings()

  // 2秒後にダイアログを閉じる
  setTimeout(() => {
    isOpen.value = false
    reset()
  }, 2000)
}
```

---

### 2. バックエンド: switch_security_provider コマンド

**ファイル**: `src-tauri/src/commands/security.rs`

#### 2.1 パラメータの準備

```rust
#[tauri::command]
pub async fn switch_security_provider(
    switcher: State<'_, Arc<ProviderSwitcher>>,
    storage: State<'_, Arc<SecurityConfigStorage>>,
    manager: State<'_, Arc<SecurityProviderManager>>,
    target_provider: SecurityProviderType,
    current_password: Option<String>,
    new_password: Option<String>,
    new_password_confirm: Option<String>,
) -> Result<SwitchResult, String>
```

**例**: マスターパスワード → Simple の場合
- `target_provider`: `SecurityProviderType::Simple`
- `current_password`: Some("ユーザーが入力したパスワード")
- `new_password`: None
- `new_password_confirm`: None

#### 2.2 現在のプロバイダーを取得

```rust
let current_provider = switcher.current_provider_type().await;
println!("[switch_security_provider] Switching from {:?} to {:?}", current_provider, target_provider);
```

#### 2.3 マスターパスワード設定のクリア

```rust
// マスターパスワードプロバイダーに切り替える場合、既存の設定をクリア
if target_provider == SecurityProviderType::MasterPassword {
    let _ = manager.clear_master_password_config().await;
}

// マスターパスワードプロバイダーから他のプロバイダーに切り替える場合、設定をクリア
if current_provider == SecurityProviderType::MasterPassword
    && target_provider != SecurityProviderType::MasterPassword
{
    let _ = manager.clear_master_password_config().await;
}
```

#### 2.4 認証パラメータと初期化パラメータの準備

```rust
let current_auth = match current_provider {
    SecurityProviderType::Simple => UnlockParams::Simple,
    SecurityProviderType::MasterPassword => UnlockParams::MasterPassword {
        password: current_password.unwrap_or_default(),
    },
    SecurityProviderType::Keychain => UnlockParams::Keychain,
};

let new_init = match target_provider {
    SecurityProviderType::Simple => InitializeParams::Simple,
    SecurityProviderType::MasterPassword => InitializeParams::MasterPassword {
        password: new_password.unwrap_or_default(),
        password_confirm: new_password_confirm.unwrap_or_default(),
    },
    SecurityProviderType::Keychain => InitializeParams::Keychain,
};
```

#### 2.5 プロバイダー切り替えの実行

```rust
let result = switcher
    .switch(SwitchParams {
        target_provider,
        current_auth,
        new_init,
    })
    .await
    .map_err(|e| e.to_string())?;

println!("[switch_security_provider] Switch completed, updating storage for {:?}", target_provider);
```

#### 2.6 ストレージの更新（重要！）

```rust
// プロバイダー切り替え後、ストレージの設定も更新
// まず、provider_typeを更新
storage
    .change_provider(target_provider)
    .await
    .map_err(|e| {
        println!("[switch_security_provider] Error changing provider to {:?}: {}", target_provider, e);
        e.to_string()
    })?;
println!("[switch_security_provider] Successfully changed provider_type to {:?}", target_provider);

// 次に、プロバイダー固有の設定を更新（必要な場合のみ）
match target_provider {
    SecurityProviderType::Simple => {
        // Simpleプロバイダーは追加設定不要（change_providerで既に設定済み）
    }
    SecurityProviderType::MasterPassword => {
        // is_configuredをtrueに更新
        storage
            .update_provider_config(ProviderSpecificConfig::MasterPassword {
                is_configured: true,
            })
            .await
            .map_err(|e| e.to_string())?;
    }
    SecurityProviderType::Keychain => {
        // is_initializedをtrueに更新
        storage
            .update_provider_config(ProviderSpecificConfig::Keychain {
                is_initialized: true,
            })
            .await
            .map_err(|e| e.to_string())?;
    }
}
```

---

### 3. ストレージ層: SecurityConfigStorage

**ファイル**: `src-tauri/src/crypto/security_provider/config.rs`

#### 3.1 change_provider メソッド

```rust
pub async fn change_provider(
    &self,
    provider_type: SecurityProviderType,
) -> Result<(), SecurityConfigError> {
    println!("[SecurityConfigStorage::change_provider] Called with provider_type: {:?}", provider_type);

    // キャッシュまたはファイルから現在の設定を読み込み
    let mut config = self.load().await?;
    println!("[SecurityConfigStorage::change_provider] Loaded config: provider_type={:?}", config.provider_type);

    // provider_type を更新
    config.provider_type = provider_type;

    // provider_config も初期値に設定
    config.provider_config = match provider_type {
        SecurityProviderType::Simple => ProviderSpecificConfig::Simple,
        SecurityProviderType::MasterPassword => ProviderSpecificConfig::MasterPassword {
            is_configured: false,
        },
        SecurityProviderType::Keychain => ProviderSpecificConfig::Keychain {
            is_initialized: false,
        },
    };

    println!("[SecurityConfigStorage::change_provider] Updated config: provider_type={:?}, config={:?}", config.provider_type, config.provider_config);

    // ファイルに保存 & キャッシュ更新
    let result = self.save(&config).await;
    println!("[SecurityConfigStorage::change_provider] Save result: {:?}", result);
    result
}
```

#### 3.2 save メソッド

```rust
pub async fn save(&self, config: &SecurityConfig) -> Result<(), SecurityConfigError> {
    let mut config = config.clone();
    config.updated_at = Utc::now();

    // ファイルに書き込み
    self.file_storage
        .write(&self.storage_key, &config)  // storage_key = "security-config"
        .map_err(|e| SecurityConfigError::StorageError(e.to_string()))?;

    // キャッシュを更新
    *self.cache.write().await = Some(config);

    Ok(())
}
```

#### 3.3 load メソッド

```rust
pub async fn load(&self) -> Result<SecurityConfig, SecurityConfigError> {
    // キャッシュをチェック
    if let Some(config) = self.cache.read().await.as_ref() {
        return Ok(config.clone());
    }

    // ファイルから読み込み
    let config = match self.file_storage.read::<SecurityConfig>(&self.storage_key) {
        Ok(c) => c,
        Err(crate::storage::StorageError::NotFound(_)) => SecurityConfig::default(),
        Err(e) => return Err(SecurityConfigError::StorageError(e.to_string())),
    };

    // キャッシュに保存
    *self.cache.write().await = Some(config.clone());

    Ok(config)
}
```

---

### 4. フロントエンド: 設定の再読み込み

#### 4.1 ProviderChangeDialog - 切り替え完了後

```typescript
// switchProvider() 内で切り替え完了後
currentPhase.value = 'complete'

// 設定を再読み込み
await securityStore.loadSettings()
```

#### 4.2 SecurityStore - loadSettings

**ファイル**: `app/stores/security.ts`

```typescript
async loadSettings() {
  this.loading = true
  this.error = null

  try {
    const { invokeCommand, isAvailable } = useTauri()

    if (!isAvailable.value) {
      console.info('Tauri is not available; using default security settings in browser mode.')
      return
    }

    const settings = await invokeCommand<SecuritySettings>('get_security_settings')
    if (settings) {
      this.settings = settings
    }
  } catch (error) {
    this.error = error instanceof Error ? error.message : 'Failed to load security settings'
    console.error('Failed to load security settings:', error)
  } finally {
    this.loading = false
  }
}
```

#### 4.3 バックエンド: get_security_settings

**ファイル**: `src-tauri/src/commands/settings.rs`

```rust
#[tauri::command]
pub async fn get_security_settings(
    config_storage: State<'_, Arc<SecurityConfigStorage>>,
) -> Result<SecuritySettings, String> {
    println!("[get_security_settings] Called");

    // SecurityConfigStorage::load() を呼び出し
    let config = config_storage.load().await.map_err(|e| e.to_string())?;
    println!("[get_security_settings] Loaded config: provider_type={:?}, provider_config={:?}", config.provider_type, config.provider_config);

    // プロバイダー名を文字列に変換
    let provider = match config.provider_type {
        SecurityProviderType::Simple => "simple",
        SecurityProviderType::MasterPassword => "master-password",
        SecurityProviderType::Keychain => "keychain",
    };

    // マスターパスワードが設定されているかチェック
    let master_password_set = matches!(
        config.provider_config,
        ProviderSpecificConfig::MasterPassword { is_configured: true }
    );

    let result = SecuritySettings {
        provider: provider.to_string(),
        level: "medium".to_string(),
        master_password_set,
    };
    println!("[get_security_settings] Returning: provider={}, master_password_set={}", result.provider, result.master_password_set);
    Ok(result)
}
```

---

## 想定される問題点

### 可能性1: `switch_security_provider` が呼ばれていない
- ダイアログの途中でエラーが発生している
- フロントエンドのログで確認: `[ProviderChangeDialog] Calling switch_security_provider`

### 可能性2: `storage.change_provider()` が失敗している
- バックエンドのログで確認:
  - `[switch_security_provider] Switch completed, updating storage`
  - `[SecurityConfigStorage::change_provider] Called with provider_type: Simple`
  - `[SecurityConfigStorage::change_provider] Save result: Ok(())`

### 可能性3: ファイル保存は成功しているが、キャッシュが更新されていない
- `save()` メソッドはキャッシュも更新しているはず
- しかし、別のインスタンスが古いキャッシュを持っている可能性

### 可能性4: ファイル保存は成功しているが、読み込み時に古いキャッシュを返している
- `load()` メソッドはキャッシュを優先的に返す
- ファイルは更新されているが、キャッシュがクリアされていない

### 可能性5: ProviderSwitcher が内部で別の設定を持っている
- `switcher.switch()` の後、`storage.change_provider()` を呼んでいる
- しかし、`switcher` 自体が古い設定を保持している可能性
- 次回起動時に `switcher` が古い設定で初期化される

---

## デバッグ手順

### ステップ1: ログの確認
1. アプリを再起動
2. マスターパスワード → Simple に変更
3. 以下のログを確認:

**期待されるログ順序**:
```
[ProviderChangeDialog] Calling switch_security_provider with params: ...
[switch_security_provider] Switching from MasterPassword to Simple
[switch_security_provider] Switch completed, updating storage for Simple
[SecurityConfigStorage::change_provider] Called with provider_type: Simple
[SecurityConfigStorage::change_provider] Loaded config: provider_type=MasterPassword
[SecurityConfigStorage::change_provider] Updated config: provider_type=Simple, config=Simple
[SecurityConfigStorage::change_provider] Save result: Ok(())
[switch_security_provider] Successfully changed provider_type to Simple
[get_security_settings] Called
[get_security_settings] Loaded config: provider_type=Simple, provider_config=Simple
[get_security_settings] Returning: provider=simple, master_password_set=false
```

### ステップ2: ファイルの確認
```bash
cat "/Users/sakamotoyoshitaka/Library/Application Support/com.sqlquerybuilder.sql-query-builder/settings/security-config.json" | jq .
```

期待される内容:
```json
{
  "version": 1,
  "provider_type": "simple",
  "provider_config_type": "Simple",
  "created_at": "...",
  "updated_at": "..."
}
```

### ステップ3: キャッシュのクリア確認
- `clear_cache()` メソッドが呼ばれているか
- 複数の `SecurityConfigStorage` インスタンスが存在していないか

---

## 次のアクション

1. **ログ収集**: 上記の手順でログを確認
2. **ファイル確認**: 変更後のファイル内容を確認
3. **問題特定**: ログとファイルの状態から問題箇所を特定
4. **修正**: 特定された問題に応じて修正
