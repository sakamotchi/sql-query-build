# 1.5a.4 KeychainProvider実装（既存ラップ）

## 概要

| 項目 | 内容 |
|------|------|
| タスクID | 1.5a.4 |
| タスク名 | KeychainProvider実装（既存ラップ） |
| 担当 | BE |
| 工数 | 1日 |
| 依存関係 | 1.5a.1, 1.2.3 |
| 完了条件 | OSキーチェーン連携が動作 |

## 目的

既存の`MasterKeyManager`（1.2.3で実装済み）をラップし、`SecurityProvider` traitを実装するプロバイダーを作成する。
OSのセキュアストレージ（macOS Keychain、Windows Credential Manager）を使用して最高レベルのセキュリティを提供する。

## セキュリティ特性

| 項目 | 説明 |
|------|------|
| セキュリティレベル | 最高 |
| キー保存先 | OSセキュアストレージ |
| 認証 | OS認証（Touch ID、Windows Hello等） |
| 利点 | OSレベルのセキュリティ、生体認証対応 |
| 欠点 | OS認証プロンプトが表示される場合がある |

## 設計詳細

### KeychainProvider実装

```rust
use async_trait::async_trait;
use std::sync::Arc;
use tokio::sync::RwLock;

use super::{
    traits::SecurityProvider,
    types::{ProviderState, SecurityProviderType, InitializeParams, UnlockParams},
    error::{SecurityProviderError, SecurityProviderResult},
};
use crate::crypto::master_key::{MasterKeyManager, MasterKeyError};

/// OSキーチェーンプロバイダー
///
/// 既存のMasterKeyManagerをラップして、SecurityProvider traitを実装する。
pub struct KeychainProvider {
    /// 既存のマスターキー管理
    manager: Arc<MasterKeyManager>,

    /// プロバイダーの状態
    state: RwLock<ProviderState>,

    /// 暗号化キーのキャッシュ
    cached_key: RwLock<Option<Vec<u8>>>,
}

impl KeychainProvider {
    /// 新しいKeychainProviderを作成
    pub fn new() -> Self {
        let manager = Arc::new(MasterKeyManager::new());
        let state = if manager.is_initialized() {
            ProviderState::Ready
        } else {
            ProviderState::Uninitialized
        };

        Self {
            manager,
            state: RwLock::new(state),
            cached_key: RwLock::new(None),
        }
    }

    /// 既存のMasterKeyManagerを使用して作成
    pub fn with_manager(manager: Arc<MasterKeyManager>) -> Self {
        let state = if manager.is_initialized() {
            ProviderState::Ready
        } else {
            ProviderState::Uninitialized
        };

        Self {
            manager,
            state: RwLock::new(state),
            cached_key: RwLock::new(None),
        }
    }

    /// MasterKeyErrorをSecurityProviderErrorに変換
    fn convert_error(err: MasterKeyError) -> SecurityProviderError {
        match err {
            MasterKeyError::NotInitialized => SecurityProviderError::NotInitialized,
            MasterKeyError::AlreadyInitialized => SecurityProviderError::AlreadyInitialized,
            MasterKeyError::KeychainError(msg) => SecurityProviderError::KeychainError(msg),
            MasterKeyError::InvalidKey(_) => SecurityProviderError::EncryptionError("Invalid key".to_string()),
            _ => SecurityProviderError::Internal(err.to_string()),
        }
    }
}

#[async_trait]
impl SecurityProvider for KeychainProvider {
    fn provider_type(&self) -> SecurityProviderType {
        SecurityProviderType::Keychain
    }

    fn state(&self) -> ProviderState {
        self.state.read().blocking_read().clone()
    }

    fn needs_initialization(&self) -> bool {
        !self.manager.is_initialized()
    }

    fn needs_unlock(&self) -> bool {
        // KeychainプロバイダーはOSが認証を管理するため、
        // 明示的なアンロックは不要
        false
    }

    async fn initialize(&mut self, params: InitializeParams) -> SecurityProviderResult<()> {
        if !matches!(params, InitializeParams::Keychain) {
            return Err(SecurityProviderError::InvalidParams(
                "Keychain provider requires Keychain params".to_string()
            ));
        }

        // MasterKeyManagerを初期化
        self.manager.initialize()
            .await
            .map_err(Self::convert_error)?;

        // キーを取得してキャッシュ
        let key = self.manager.get_master_key()
            .await
            .map_err(Self::convert_error)?;

        *self.cached_key.write().await = Some(key);
        *self.state.write().await = ProviderState::Ready;

        Ok(())
    }

    async fn unlock(&mut self, params: UnlockParams) -> SecurityProviderResult<()> {
        if !matches!(params, UnlockParams::Keychain) {
            return Err(SecurityProviderError::InvalidParams(
                "Keychain provider requires Keychain params".to_string()
            ));
        }

        // キーを取得してキャッシュ
        // OSキーチェーンへのアクセス時にOS認証が行われる可能性がある
        let key = self.manager.get_master_key()
            .await
            .map_err(Self::convert_error)?;

        *self.cached_key.write().await = Some(key);
        *self.state.write().await = ProviderState::Ready;

        Ok(())
    }

    async fn lock(&mut self) {
        // キャッシュをクリア
        *self.cached_key.write().await = None;
        self.manager.clear_cache().await;

        *self.state.write().await = ProviderState::Locked;
    }

    async fn get_encryption_key(&self) -> SecurityProviderResult<Vec<u8>> {
        // キャッシュをチェック
        {
            let cached = self.cached_key.read().await;
            if let Some(key) = cached.as_ref() {
                return Ok(key.clone());
            }
        }

        // キャッシュにない場合はMasterKeyManagerから取得
        let key = self.manager.get_master_key()
            .await
            .map_err(Self::convert_error)?;

        // キャッシュに保存
        *self.cached_key.write().await = Some(key.clone());

        Ok(key)
    }

    async fn reset(&mut self) -> SecurityProviderResult<()> {
        // キャッシュをクリア
        *self.cached_key.write().await = None;

        // MasterKeyManagerをリセット
        self.manager.delete_master_key()
            .await
            .map_err(Self::convert_error)?;

        *self.state.write().await = ProviderState::Uninitialized;

        Ok(())
    }

    fn validate(&self) -> SecurityProviderResult<()> {
        Ok(())
    }
}

impl Default for KeychainProvider {
    fn default() -> Self {
        Self::new()
    }
}
```

### 起動時の自動アンロック

```rust
impl KeychainProvider {
    /// 起動時に自動的にキーを取得（キャッシュに読み込み）
    pub async fn auto_unlock(&mut self) -> SecurityProviderResult<()> {
        if self.manager.is_initialized() {
            self.unlock(UnlockParams::Keychain).await?;
        }
        Ok(())
    }
}
```

## 既存実装との統合

### MasterKeyManagerとの関係

```
┌─────────────────────────────────────────────┐
│           KeychainProvider                   │
│  (SecurityProvider trait実装)                │
├─────────────────────────────────────────────┤
│  ┌─────────────────────────────────────┐   │
│  │       MasterKeyManager (既存)        │   │
│  │  - initialize()                      │   │
│  │  - get_master_key()                  │   │
│  │  - delete_master_key()               │   │
│  │  - clear_cache()                     │   │
│  └──────────────┬──────────────────────┘   │
│                 │                           │
│  ┌──────────────▼──────────────────────┐   │
│  │        OsKeychain (既存)             │   │
│  │  - store_key()                       │   │
│  │  - retrieve_key()                    │   │
│  │  - delete_key()                      │   │
│  └─────────────────────────────────────┘   │
└─────────────────────────────────────────────┘
```

## テスト

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::crypto::master_key::keychain::tests::MockKeychain;

    fn create_mock_provider() -> KeychainProvider {
        let mock_keychain = Arc::new(MockKeychain::new());
        let manager = Arc::new(MasterKeyManager::with_keychain(mock_keychain));
        KeychainProvider::with_manager(manager)
    }

    #[tokio::test]
    async fn test_keychain_provider_initialization() {
        let mut provider = create_mock_provider();

        assert!(provider.needs_initialization());

        provider.initialize(InitializeParams::Keychain).await.unwrap();

        assert!(!provider.needs_initialization());
        assert!(provider.state().is_ready());
    }

    #[tokio::test]
    async fn test_keychain_provider_get_key() {
        let mut provider = create_mock_provider();

        provider.initialize(InitializeParams::Keychain).await.unwrap();

        let key = provider.get_encryption_key().await.unwrap();
        assert_eq!(key.len(), 32);
    }

    #[tokio::test]
    async fn test_keychain_provider_no_unlock_required() {
        let provider = create_mock_provider();
        assert!(!provider.needs_unlock());
    }

    #[tokio::test]
    async fn test_keychain_provider_reset() {
        let mut provider = create_mock_provider();

        provider.initialize(InitializeParams::Keychain).await.unwrap();
        assert!(!provider.needs_initialization());

        provider.reset().await.unwrap();
        assert!(provider.needs_initialization());
    }

    #[tokio::test]
    async fn test_keychain_provider_key_consistency() {
        let mut provider = create_mock_provider();

        provider.initialize(InitializeParams::Keychain).await.unwrap();

        let key1 = provider.get_encryption_key().await.unwrap();
        let key2 = provider.get_encryption_key().await.unwrap();

        assert_eq!(key1, key2);
    }
}
```

## 実装チェックリスト

- [ ] `KeychainProvider` 構造体実装
- [ ] `SecurityProvider` trait実装
- [ ] `MasterKeyManager` との統合
- [ ] エラー変換実装
- [ ] 自動アンロック機能実装
- [ ] ユニットテスト作成（MockKeychain使用）
- [ ] 統合テスト作成

---

**作成日**: 2025-11-24
**作成者**: Claude Code
