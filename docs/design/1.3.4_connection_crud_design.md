# タスク1.3.4: 接続CRUD機能実装(Rust) 設計書

## 概要

**タスクID**: 1.3.4
**タスク名**: 接続CRUD機能実装(Rust)
**工数**: 3日
**依存関係**: 1.2.5 (データ永続化層のテスト作成)
**完了条件**: 接続の作成・編集・削除が可能

---

## 目的

Rustバックエンドで接続情報のCRUD(Create, Read, Update, Delete)操作を実装する。暗号化されたパスワード管理、ファイルベースの永続化、トランザクション的な操作を提供する。

---

## アーキテクチャ

### モジュール構成

```
src-tauri/src/
├── commands/
│   └── connection.rs       # Tauriコマンド定義
├── services/
│   └── connection_service.rs  # ビジネスロジック
├── models/
│   └── connection.rs       # データモデル定義
└── storage/
    └── connection_storage.rs  # ストレージ層
```

---

## データモデル

### Connection構造体

**ファイル**: `src-tauri/src/models/connection.rs`

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Connection {
    pub id: String,
    pub name: String,
    pub environment: Environment,
    pub theme_color: String,
    pub host: String,
    pub port: u16,
    pub database: String,
    pub username: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,  // 暗号化されたパスワード
    pub db_type: DatabaseType,
    pub ssl: bool,

    // 詳細設定
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ssh_tunnel: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ssh_host: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ssh_port: Option<u16>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ssh_username: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<u32>,

    // メタデータ
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_used_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum Environment {
    Development,
    Test,
    Staging,
    Production,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum DatabaseType {
    #[serde(rename = "postgresql")]
    PostgreSQL,
    #[serde(rename = "mysql")]
    MySQL,
    #[serde(rename = "sqlite")]
    SQLite,
}

impl Connection {
    pub fn new(
        name: String,
        environment: Environment,
        db_type: DatabaseType,
        host: String,
        port: u16,
        database: String,
        username: String,
    ) -> Self {
        let now = Utc::now();
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            name,
            environment,
            theme_color: Self::default_theme_color(&environment),
            host,
            port,
            database,
            username,
            password: None,
            db_type,
            ssl: false,
            ssh_tunnel: None,
            ssh_host: None,
            ssh_port: None,
            ssh_username: None,
            timeout: Some(30),
            created_at: now,
            updated_at: now,
            last_used_at: None,
        }
    }

    fn default_theme_color(environment: &Environment) -> String {
        match environment {
            Environment::Development => "#4CAF50".to_string(),
            Environment::Test => "#2196F3".to_string(),
            Environment::Staging => "#FF9800".to_string(),
            Environment::Production => "#F44336".to_string(),
        }
    }
}
```

---

## ストレージ層

### ConnectionStorage

**ファイル**: `src-tauri/src/storage/connection_storage.rs`

```rust
use std::fs;
use std::path::PathBuf;
use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use crate::models::connection::Connection;

#[derive(Debug, Serialize, Deserialize)]
struct ConnectionsData {
    connections: Vec<Connection>,
}

pub struct ConnectionStorage {
    file_path: PathBuf,
}

impl ConnectionStorage {
    pub fn new(app_data_dir: PathBuf) -> Result<Self> {
        // データディレクトリの作成
        fs::create_dir_all(&app_data_dir)
            .context("Failed to create app data directory")?;

        let file_path = app_data_dir.join("connections.json");

        // ファイルが存在しない場合は初期化
        if !file_path.exists() {
            let initial_data = ConnectionsData {
                connections: Vec::new(),
            };
            let json = serde_json::to_string_pretty(&initial_data)?;
            fs::write(&file_path, json)?;
        }

        Ok(Self { file_path })
    }

    /// すべての接続を取得
    pub fn get_all(&self) -> Result<Vec<Connection>> {
        let data = self.read_file()?;
        Ok(data.connections)
    }

    /// IDで接続を取得
    pub fn get_by_id(&self, id: &str) -> Result<Option<Connection>> {
        let connections = self.get_all()?;
        Ok(connections.into_iter().find(|c| c.id == id))
    }

    /// 接続を作成
    pub fn create(&self, connection: Connection) -> Result<Connection> {
        let mut data = self.read_file()?;

        // ID重複チェック
        if data.connections.iter().any(|c| c.id == connection.id) {
            anyhow::bail!("Connection with ID {} already exists", connection.id);
        }

        data.connections.push(connection.clone());
        self.write_file(&data)?;
        Ok(connection)
    }

    /// 接続を更新
    pub fn update(&self, connection: Connection) -> Result<Connection> {
        let mut data = self.read_file()?;

        let index = data
            .connections
            .iter()
            .position(|c| c.id == connection.id)
            .ok_or_else(|| anyhow::anyhow!("Connection not found"))?;

        data.connections[index] = connection.clone();
        self.write_file(&data)?;
        Ok(connection)
    }

    /// 接続を削除
    pub fn delete(&self, id: &str) -> Result<()> {
        let mut data = self.read_file()?;

        let index = data
            .connections
            .iter()
            .position(|c| c.id == id)
            .ok_or_else(|| anyhow::anyhow!("Connection not found"))?;

        data.connections.remove(index);
        self.write_file(&data)?;
        Ok(())
    }

    /// 最終使用日時を更新
    pub fn update_last_used(&self, id: &str) -> Result<()> {
        let mut data = self.read_file()?;

        let connection = data
            .connections
            .iter_mut()
            .find(|c| c.id == id)
            .ok_or_else(|| anyhow::anyhow!("Connection not found"))?;

        connection.last_used_at = Some(chrono::Utc::now());
        self.write_file(&data)?;
        Ok(())
    }

    /// ファイルからデータを読み込み
    fn read_file(&self) -> Result<ConnectionsData> {
        let content = fs::read_to_string(&self.file_path)
            .context("Failed to read connections file")?;

        let data: ConnectionsData = serde_json::from_str(&content)
            .context("Failed to parse connections file")?;

        Ok(data)
    }

    /// ファイルにデータを書き込み
    fn write_file(&self, data: &ConnectionsData) -> Result<()> {
        let json = serde_json::to_string_pretty(data)?;

        // 一時ファイルに書き込んでから置き換え(アトミック操作)
        let temp_path = self.file_path.with_extension("tmp");
        fs::write(&temp_path, json)?;
        fs::rename(temp_path, &self.file_path)?;

        Ok(())
    }
}
```

---

## サービス層

### ConnectionService

**ファイル**: `src-tauri/src/services/connection_service.rs`

```rust
use anyhow::Result;
use chrono::Utc;
use crate::models::connection::Connection;
use crate::storage::connection_storage::ConnectionStorage;
use crate::utils::encryption::EncryptionService;

pub struct ConnectionService {
    storage: ConnectionStorage,
    encryption: EncryptionService,
}

impl ConnectionService {
    pub fn new(storage: ConnectionStorage, encryption: EncryptionService) -> Self {
        Self { storage, encryption }
    }

    /// すべての接続を取得(パスワードは除外)
    pub fn get_all(&self) -> Result<Vec<Connection>> {
        let mut connections = self.storage.get_all()?;

        // パスワードを除外
        for conn in &mut connections {
            conn.password = None;
        }

        Ok(connections)
    }

    /// IDで接続を取得(パスワード含む、復号化)
    pub fn get_by_id(&self, id: &str, include_password: bool) -> Result<Option<Connection>> {
        let connection = self.storage.get_by_id(id)?;

        if let Some(mut conn) = connection {
            if include_password {
                // パスワードを復号化
                if let Some(encrypted_password) = &conn.password {
                    let decrypted = self.encryption.decrypt(encrypted_password)?;
                    conn.password = Some(decrypted);
                }
            } else {
                conn.password = None;
            }
            Ok(Some(conn))
        } else {
            Ok(None)
        }
    }

    /// 接続を作成
    pub fn create(&self, mut connection: Connection) -> Result<Connection> {
        // パスワードを暗号化
        if let Some(password) = &connection.password {
            let encrypted = self.encryption.encrypt(password)?;
            connection.password = Some(encrypted);
        }

        self.storage.create(connection)
    }

    /// 接続を更新
    pub fn update(&self, mut connection: Connection) -> Result<Connection> {
        // 更新日時を設定
        connection.updated_at = Utc::now();

        // パスワードを暗号化
        if let Some(password) = &connection.password {
            let encrypted = self.encryption.encrypt(password)?;
            connection.password = Some(encrypted);
        }

        self.storage.update(connection)
    }

    /// 接続を削除
    pub fn delete(&self, id: &str) -> Result<()> {
        self.storage.delete(id)
    }

    /// 最終使用日時を更新
    pub fn mark_as_used(&self, id: &str) -> Result<()> {
        self.storage.update_last_used(id)
    }

    /// 接続を検証
    pub fn validate(&self, connection: &Connection) -> Result<()> {
        // 必須フィールドのチェック
        if connection.name.is_empty() {
            anyhow::bail!("Connection name is required");
        }
        if connection.host.is_empty() {
            anyhow::bail!("Host is required");
        }
        if connection.database.is_empty() {
            anyhow::bail!("Database name is required");
        }
        if connection.username.is_empty() {
            anyhow::bail!("Username is required");
        }

        // ポート番号の範囲チェック
        if connection.port == 0 || connection.port > 65535 {
            anyhow::bail!("Port must be between 1 and 65535");
        }

        Ok(())
    }
}
```

---

## Tauriコマンド層

### Connectionコマンド

**ファイル**: `src-tauri/src/commands/connection.rs`

```rust
use tauri::State;
use crate::models::connection::Connection;
use crate::services::connection_service::ConnectionService;

type ConnectionServiceState = State<'_, ConnectionService>;

#[tauri::command]
pub async fn get_connections(
    service: ConnectionServiceState,
) -> Result<Vec<Connection>, String> {
    service
        .get_all()
        .map_err(|e| format!("Failed to get connections: {}", e))
}

#[tauri::command]
pub async fn get_connection(
    id: String,
    include_password: bool,
    service: ConnectionServiceState,
) -> Result<Option<Connection>, String> {
    service
        .get_by_id(&id, include_password)
        .map_err(|e| format!("Failed to get connection: {}", e))
}

#[tauri::command]
pub async fn create_connection(
    connection: Connection,
    service: ConnectionServiceState,
) -> Result<Connection, String> {
    // バリデーション
    service
        .validate(&connection)
        .map_err(|e| format!("Validation error: {}", e))?;

    service
        .create(connection)
        .map_err(|e| format!("Failed to create connection: {}", e))
}

#[tauri::command]
pub async fn update_connection(
    connection: Connection,
    service: ConnectionServiceState,
) -> Result<Connection, String> {
    // バリデーション
    service
        .validate(&connection)
        .map_err(|e| format!("Validation error: {}", e))?;

    service
        .update(connection)
        .map_err(|e| format!("Failed to update connection: {}", e))
}

#[tauri::command]
pub async fn delete_connection(
    id: String,
    service: ConnectionServiceState,
) -> Result<(), String> {
    service
        .delete(&id)
        .map_err(|e| format!("Failed to delete connection: {}", e))
}

#[tauri::command]
pub async fn mark_connection_used(
    id: String,
    service: ConnectionServiceState,
) -> Result<(), String> {
    service
        .mark_as_used(&id)
        .map_err(|e| format!("Failed to update last used: {}", e))
}
```

---

## main.rsへの統合

**ファイル**: `src-tauri/src/main.rs`

```rust
mod commands;
mod models;
mod services;
mod storage;
mod utils;

use tauri::Manager;
use storage::connection_storage::ConnectionStorage;
use services::connection_service::ConnectionService;
use utils::encryption::EncryptionService;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .setup(|app| {
            // アプリケーションデータディレクトリを取得
            let app_data_dir = app
                .path()
                .app_data_dir()
                .expect("Failed to get app data directory");

            // ストレージとサービスの初期化
            let storage = ConnectionStorage::new(app_data_dir.clone())
                .expect("Failed to initialize connection storage");

            let encryption = EncryptionService::new()
                .expect("Failed to initialize encryption service");

            let connection_service = ConnectionService::new(storage, encryption);

            // サービスを状態として管理
            app.manage(connection_service);

            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            commands::connection::get_connections,
            commands::connection::get_connection,
            commands::connection::create_connection,
            commands::connection::update_connection,
            commands::connection::delete_connection,
            commands::connection::mark_connection_used,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

---

## エラーハンドリング

### カスタムエラー型

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ConnectionError {
    #[error("Connection not found: {0}")]
    NotFound(String),

    #[error("Connection already exists: {0}")]
    AlreadyExists(String),

    #[error("Validation error: {0}")]
    ValidationError(String),

    #[error("Encryption error: {0}")]
    EncryptionError(String),

    #[error("Storage error: {0}")]
    StorageError(#[from] std::io::Error),

    #[error("JSON error: {0}")]
    JsonError(#[from] serde_json::Error),
}
```

---

## セキュリティ考慮事項

### パスワード暗号化
- AES-256-GCM を使用
- マスターキーはOSのキーチェーンから取得
- 暗号化されたパスワードのみファイルに保存

### ファイルアクセス
- アプリケーションデータディレクトリのみアクセス
- ファイル書き込みはアトミック操作(一時ファイル→リネーム)
- 適切なファイルパーミッション設定

---

## テスト

### ユニットテスト

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_create_connection() {
        let temp_dir = TempDir::new().unwrap();
        let storage = ConnectionStorage::new(temp_dir.path().to_path_buf()).unwrap();

        let connection = Connection::new(
            "Test DB".to_string(),
            Environment::Development,
            DatabaseType::PostgreSQL,
            "localhost".to_string(),
            5432,
            "testdb".to_string(),
            "testuser".to_string(),
        );

        let result = storage.create(connection.clone()).unwrap();
        assert_eq!(result.id, connection.id);
        assert_eq!(result.name, "Test DB");
    }

    #[test]
    fn test_get_all_connections() {
        let temp_dir = TempDir::new().unwrap();
        let storage = ConnectionStorage::new(temp_dir.path().to_path_buf()).unwrap();

        let connections = storage.get_all().unwrap();
        assert_eq!(connections.len(), 0);
    }

    #[test]
    fn test_update_connection() {
        let temp_dir = TempDir::new().unwrap();
        let storage = ConnectionStorage::new(temp_dir.path().to_path_buf()).unwrap();

        let mut connection = Connection::new(
            "Test DB".to_string(),
            Environment::Development,
            DatabaseType::PostgreSQL,
            "localhost".to_string(),
            5432,
            "testdb".to_string(),
            "testuser".to_string(),
        );

        storage.create(connection.clone()).unwrap();

        connection.name = "Updated DB".to_string();
        let updated = storage.update(connection.clone()).unwrap();
        assert_eq!(updated.name, "Updated DB");
    }

    #[test]
    fn test_delete_connection() {
        let temp_dir = TempDir::new().unwrap();
        let storage = ConnectionStorage::new(temp_dir.path().to_path_buf()).unwrap();

        let connection = Connection::new(
            "Test DB".to_string(),
            Environment::Development,
            DatabaseType::PostgreSQL,
            "localhost".to_string(),
            5432,
            "testdb".to_string(),
            "testuser".to_string(),
        );

        storage.create(connection.clone()).unwrap();
        storage.delete(&connection.id).unwrap();

        let result = storage.get_by_id(&connection.id).unwrap();
        assert!(result.is_none());
    }
}
```

---

## 依存関係

### Cargo.toml

```toml
[dependencies]
tauri = { version = "2.0", features = [] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
anyhow = "1.0"
thiserror = "1.0"

[dev-dependencies]
tempfile = "3.0"
```

---

## 実装チェックリスト

- [ ] `src-tauri/src/models/connection.rs` の作成
- [ ] `src-tauri/src/storage/connection_storage.rs` の作成
- [ ] `src-tauri/src/services/connection_service.rs` の作成
- [ ] `src-tauri/src/commands/connection.rs` の作成
- [ ] エラーハンドリングの実装
- [ ] パスワード暗号化の実装
- [ ] ユニットテストの作成
- [ ] 統合テストの作成
- [ ] ドキュメントの作成
