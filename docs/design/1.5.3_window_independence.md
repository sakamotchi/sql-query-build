# タスク1.5.3: ウィンドウ間独立性確保 設計書

## 概要

**タスクID**: 1.5.3
**タスク名**: ウィンドウ間独立性確保
**工数**: 2日
**依存関係**: 1.5.2 (ウィンドウ起動コマンド実装)
**完了条件**: 各ウィンドウが独立動作

---

## 目的

各ウィンドウが独立した状態を持ち、互いに干渉せずに動作できるようにする。これにより、ユーザーは異なるデータベース環境を同時に操作しても、状態が混在することなく安全に作業できる。

---

## 機能要件

### 主要機能

1. **ウィンドウコンテキスト管理**
   - 各ウィンドウ固有の状態を保持
   - 接続情報との紐付け
   - 環境情報の管理

2. **状態の独立性**
   - Piniaストアのウィンドウ別インスタンス
   - ウィンドウ間でのデータ分離
   - 独立したルーティング

3. **ウィンドウ情報の取得**
   - 現在のウィンドウ識別
   - ウィンドウタイプの判定
   - 関連接続情報の取得

---

## アーキテクチャ

### ウィンドウ独立性の実現方法

```
┌─────────────────────────────────────────────────────────────────┐
│                     Tauri Application                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────┐     ┌─────────────────────┐           │
│  │    ウィンドウA       │     │    ウィンドウB       │           │
│  │  ┌───────────────┐  │     │  ┌───────────────┐  │           │
│  │  │ Vue App       │  │     │  │ Vue App       │  │           │
│  │  │ ┌───────────┐ │  │     │  │ ┌───────────┐ │  │           │
│  │  │ │Pinia Store│ │  │     │  │ │Pinia Store│ │  │           │
│  │  │ │- window   │ │  │     │  │ │- window   │ │  │           │
│  │  │ │- theme    │ │  │     │  │ │- theme    │ │  │           │
│  │  │ │- query    │ │  │     │  │ │- query    │ │  │           │
│  │  │ └───────────┘ │  │     │  │ └───────────┘ │  │           │
│  │  │ ┌───────────┐ │  │     │  │ ┌───────────┐ │  │           │
│  │  │ │ Context   │ │  │     │  │ │ Context   │ │  │           │
│  │  │ │connId: A  │ │  │     │  │ │connId: B  │ │  │           │
│  │  │ │env: dev   │ │  │     │  │ │env: prod  │ │  │           │
│  │  │ └───────────┘ │  │     │  │ └───────────┘ │  │           │
│  │  └───────────────┘  │     │  └───────────────┘  │           │
│  └─────────────────────┘     └─────────────────────┘           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### モジュール構成

```
src/
├── types/
│   └── window.ts          # ウィンドウ型定義
├── stores/
│   └── window.ts          # ウィンドウ状態管理ストア
└── composables/
    └── useWindow.ts       # ウィンドウ操作コンポーザブル
```

---

## 型定義

**ファイル**: `src/types/window.ts`

```typescript
import type { Environment } from '@/types/connection';

/**
 * ウィンドウの種類
 */
export type WindowType = 'launcher' | 'query_builder' | 'settings';

/**
 * ウィンドウ情報
 */
export interface WindowInfo {
  /** ウィンドウラベル */
  label: string;
  /** ウィンドウタイトル */
  title: string;
  /** ウィンドウの種類 */
  windowType: WindowType;
  /** 関連する接続ID */
  connectionId?: string | null;
  /** 環境（バックエンドからは原則返却されないためオプショナル） */
  environment?: Environment | null;
  /** フォーカス状態 */
  focused: boolean;
  /** 可視状態 */
  visible: boolean;
}

/**
 * ウィンドウコンテキスト（各ウィンドウ固有の状態）
 */
export interface WindowContext {
  /** ウィンドウラベル */
  windowLabel: string;
  /** 接続ID */
  connectionId?: string;
  /** 環境タイプ */
  environment?: Environment | string;
  /** ウィンドウの種類 */
  windowType: WindowType;
}

/**
 * ウィンドウイベント
 */
export interface WindowEvent {
  /** イベント種類 */
  type: 'focus' | 'blur' | 'close' | 'resize' | 'move';
  /** ウィンドウラベル */
  label: string;
  /** タイムスタンプ */
  timestamp: number;
}
```

---

## ウィンドウストア

**ファイル**: `src/stores/window.ts`

```typescript
import { defineStore } from 'pinia';
import { getCurrentWindow } from '@tauri-apps/api/window';
import { windowApi } from '@/api/window';
import type { WindowInfo, WindowContext } from '@/types/window';
import type { Environment } from '@/types/connection';

const isTauriEnvironment = () =>
  typeof window !== 'undefined' &&
  ('__TAURI_IPC__' in window || '__TAURI_INTERNALS__' in window);

interface WindowStoreState {
  /** 現在のウィンドウコンテキスト */
  currentContext: WindowContext | null;
  /** 開いているウィンドウリスト */
  openWindows: WindowInfo[];
  /** 初期化済みフラグ */
  initialized: boolean;
  /** 読み込み中フラグ */
  loading: boolean;
  /** エラー */
  error: string | null;
}

export const useWindowStore = defineStore('window', {
  state: (): WindowStoreState => ({
    currentContext: null,
    openWindows: [],
    initialized: false,
    loading: false,
    error: null,
  }),

  getters: {
    /**
     * 現在のウィンドウラベル
     */
    currentWindowLabel(state): string | undefined {
      return state.currentContext?.windowLabel;
    },

    /**
     * 現在の接続ID
     */
    currentConnectionId(state): string | undefined {
      return state.currentContext?.connectionId;
    },

    /**
     * 現在の環境
     */
    currentEnvironment(state): Environment | string | undefined {
      return state.currentContext?.environment;
    },

    /**
     * ランチャーウィンドウかどうか
     */
    isLauncher(state): boolean {
      return state.currentContext?.windowType === 'launcher';
    },

    /**
     * クエリビルダーウィンドウかどうか
     */
    isQueryBuilder(state): boolean {
      return state.currentContext?.windowType === 'query_builder';
    },

    /**
     * 設定ウィンドウかどうか
     */
    isSettings(state): boolean {
      return state.currentContext?.windowType === 'settings';
    },

    /**
     * 開いているウィンドウ数
     */
    windowCount(state): number {
      return state.openWindows.length;
    },

    /**
     * 他のクエリビルダーウィンドウ
     */
    otherQueryBuilders(state): WindowInfo[] {
      return state.openWindows.filter(
        w => w.windowType === 'query_builder' && w.label !== state.currentContext?.windowLabel
      );
    },
  },

  actions: {
    /**
     * ウィンドウストアを初期化
     */
    async initialize() {
      if (this.initialized) return;

      this.loading = true;
      this.error = null;

      try {
        if (!isTauriEnvironment()) {
          this.currentContext = {
            windowLabel: 'launcher',
            windowType: 'launcher',
          };
          this.initialized = true;
          return;
        }

        const window = getCurrentWindow();
        const label = window.label;

        // ウィンドウラベルからコンテキストを推測
        const context = this.parseWindowLabel(label);
        this.currentContext = context;

        // ウィンドウリストを取得
        await this.refreshWindowList();

        this.initialized = true;
      } catch (error) {
        this.error = error instanceof Error ? error.message : 'Failed to initialize';
        console.error('Failed to initialize window store:', error);
      } finally {
        this.loading = false;
      }
    },

    /**
     * ウィンドウラベルからコンテキストを解析
     */
    parseWindowLabel(label: string): WindowContext {
      if (label === 'launcher' || label === 'main') {
        return {
          windowLabel: label,
          windowType: 'launcher',
        };
      }

      if (label === 'settings') {
        return {
          windowLabel: label,
          windowType: 'settings',
        };
      }

      if (label.startsWith('query-builder-')) {
        const connectionId = label.replace('query-builder-', '');
        return {
          windowLabel: label,
          connectionId,
          windowType: 'query_builder',
        };
      }

      // デフォルトはクエリビルダー
      return {
        windowLabel: label,
        windowType: 'query_builder',
      };
    },

    /**
     * ウィンドウコンテキストを設定
     */
    setContext(context: Partial<WindowContext>) {
      if (this.currentContext) {
        this.currentContext = {
          ...this.currentContext,
          ...context,
        };
      }
    },

    /**
     * 接続情報を設定
     */
    setConnectionContext(connectionId: string, environment: Environment | string) {
      this.setContext({
        connectionId,
        environment,
      });
    },

    /**
     * ウィンドウリストを更新
     */
    async refreshWindowList() {
      if (!isTauriEnvironment()) {
        this.openWindows = [];
        return;
      }

      try {
        this.openWindows = await windowApi.listWindows();
      } catch (error) {
        console.error('Failed to refresh window list:', error);
      }
    },

    /**
     * クエリビルダーウィンドウを開く
     */
    async openQueryBuilder(
      connectionId: string,
      connectionName: string,
      environment: Environment | string
    ): Promise<WindowInfo | null> {
      if (!isTauriEnvironment()) {
        console.warn('Window operations are available only in the Tauri runtime.');
        return null;
      }

      try {
        const info = await windowApi.openQueryBuilder(connectionId, connectionName, environment);
        await this.refreshWindowList();
        return info;
      } catch (error) {
        console.error('Failed to open query builder window:', error);
        return null;
      }
    },

    /**
     * 設定ウィンドウを開く
     */
    async openSettings(): Promise<WindowInfo | null> {
      if (!isTauriEnvironment()) {
        console.warn('Window operations are available only in the Tauri runtime.');
        return null;
      }

      try {
        const info = await windowApi.openSettings();
        await this.refreshWindowList();
        return info;
      } catch (error) {
        console.error('Failed to open settings window:', error);
        return null;
      }
    },

    /**
     * ウィンドウにフォーカス
     */
    async focusWindow(label: string) {
      if (!isTauriEnvironment()) return;

      try {
        await windowApi.focusWindow(label);
      } catch (error) {
        console.error('Failed to focus window:', error);
      }
    },

    /**
     * ウィンドウを閉じる
     */
    async closeWindow(label?: string) {
      if (!isTauriEnvironment()) return;

      try {
        const targetLabel = label || this.currentWindowLabel;
        if (targetLabel) {
          await windowApi.closeWindow(targetLabel);
          await this.refreshWindowList();
        }
      } catch (error) {
        console.error('Failed to close window:', error);
      }
    },

    /**
     * 接続IDでウィンドウを検索してフォーカス
     */
    async focusOrOpenQueryBuilder(
      connectionId: string,
      connectionName: string,
      environment: Environment | string
    ): Promise<WindowInfo | null> {
      if (!isTauriEnvironment()) {
        console.warn('Window operations are available only in the Tauri runtime.');
        return null;
      }

      try {
        const existing = await windowApi.findWindowByConnection(connectionId);

        if (existing) {
          await this.focusWindow(existing.label);
          return existing;
        }

        return await this.openQueryBuilder(connectionId, connectionName, environment);
      } catch (error) {
        console.error('Failed to focus or open query builder:', error);
        return null;
      }
    },

    /**
     * コンテキストをリセット
     */
    resetContext() {
      this.currentContext = null;
      this.initialized = false;
    },
  },
});
```

---

## ウィンドウコンポーザブル

**ファイル**: `src/composables/useWindow.ts`

```typescript
import { computed, onMounted, onUnmounted } from 'vue';
import { listen, type UnlistenFn } from '@tauri-apps/api/event';
import { useWindowStore } from '@/stores/window';
import type { WindowInfo } from '@/types/window';
import type { Environment } from '@/types/connection';

const isTauriEnvironment = () =>
  typeof window !== 'undefined' &&
  ('__TAURI_IPC__' in window || '__TAURI_INTERNALS__' in window);

/**
 * ウィンドウ操作コンポーザブル
 */
export function useWindow() {
  const store = useWindowStore();
  let unlistenFocus: UnlistenFn | null = null;
  let unlistenBlur: UnlistenFn | null = null;

  // ウィンドウイベントのリスナーを設定
  const setupEventListeners = async () => {
    if (!isTauriEnvironment()) return;

    try {
      unlistenFocus = await listen('tauri://focus', () => {
        store.refreshWindowList();
      });

      unlistenBlur = await listen('tauri://blur', () => {
        // ブラー時の処理（必要に応じて）
      });
    } catch (error) {
      console.error('Failed to setup event listeners:', error);
    }
  };

  // クリーンアップ
  const cleanup = () => {
    if (unlistenFocus) {
      unlistenFocus();
      unlistenFocus = null;
    }
    if (unlistenBlur) {
      unlistenBlur();
      unlistenBlur = null;
    }
  };

  // ウィンドウストアを初期化
  onMounted(async () => {
    await store.initialize();
    await setupEventListeners();
  });

  onUnmounted(() => {
    cleanup();
  });

  /**
   * 現在のウィンドウコンテキスト
   */
  const context = computed(() => store.currentContext);

  /**
   * 現在の接続ID
   */
  const connectionId = computed(() => store.currentConnectionId);

  /**
   * 現在の環境
   */
  const environment = computed(() => store.currentEnvironment);

  /**
   * ランチャーウィンドウかどうか
   */
  const isLauncher = computed(() => store.isLauncher);

  /**
   * クエリビルダーウィンドウかどうか
   */
  const isQueryBuilder = computed(() => store.isQueryBuilder);

  /**
   * 設定ウィンドウかどうか
   */
  const isSettings = computed(() => store.isSettings);

  /**
   * 開いているウィンドウ数
   */
  const windowCount = computed(() => store.windowCount);

  /**
   * 開いているウィンドウ一覧
   */
  const openWindows = computed(() => store.openWindows);

  /**
   * 他のクエリビルダーウィンドウ
   */
  const otherQueryBuilders = computed(() => store.otherQueryBuilders);

  /**
   * 接続情報を設定
   */
  const setConnectionContext = (connectionId: string, environment: Environment | string) => {
    store.setConnectionContext(connectionId, environment);
  };

  /**
   * クエリビルダーウィンドウを開く
   */
  const openQueryBuilder = async (
    connectionId: string,
    connectionName: string,
    environment: Environment | string
  ): Promise<WindowInfo | null> => {
    return store.focusOrOpenQueryBuilder(connectionId, connectionName, environment);
  };

  /**
   * 設定ウィンドウを開く
   */
  const openSettings = (): Promise<WindowInfo | null> => {
    return store.openSettings();
  };

  /**
   * 現在のウィンドウを閉じる
   */
  const closeCurrentWindow = (): Promise<void> => {
    return store.closeWindow();
  };

  /**
   * ウィンドウにフォーカス
   */
  const focusWindow = (label: string): Promise<void> => {
    return store.focusWindow(label);
  };

  /**
   * ウィンドウリストを更新
   */
  const refreshWindowList = (): Promise<void> => {
    return store.refreshWindowList();
  };

  return {
    // 状態
    context,
    connectionId,
    environment,
    isLauncher,
    isQueryBuilder,
    isSettings,
    windowCount,
    openWindows,
    otherQueryBuilders,

    // 読み込み状態
    loading: computed(() => store.loading),
    error: computed(() => store.error),
    initialized: computed(() => store.initialized),

    // アクション
    setConnectionContext,
    openQueryBuilder,
    openSettings,
    closeCurrentWindow,
    focusWindow,
    refreshWindowList,
  };
}
```

---

## 使用例

### クエリビルダーページでの使用

```vue
<script setup lang="ts">
import { onMounted, watch } from 'vue';
import { useRoute } from 'vue-router';
import { useWindow } from '@/composables/useWindow';
import { useConnectionStore } from '@/stores/connection';

const route = useRoute();
const { connectionId, environment, setConnectionContext, isQueryBuilder } = useWindow();
const connectionStore = useConnectionStore();

// 接続情報を読み込んでコンテキストを設定
const loadConnectionContext = async () => {
  const connId = route.query.connectionId as string;
  if (!connId) return;

  const connection = connectionStore.getConnectionById(connId);
  if (connection) {
    setConnectionContext(connection.id, connection.environment);
  }
};

onMounted(() => {
  if (isQueryBuilder.value) {
    loadConnectionContext();
  }
});

watch(() => route.query.connectionId, () => {
  loadConnectionContext();
});
</script>

<template>
  <div class="query-builder">
    <div v-if="connectionId">
      接続ID: {{ connectionId }}
      環境: {{ environment }}
    </div>
    <!-- クエリビルダーの内容 -->
  </div>
</template>
```

### ウィンドウ切り替えUI

```vue
<script setup lang="ts">
import { useWindow } from '@/composables/useWindow';

const { openWindows, otherQueryBuilders, focusWindow } = useWindow();

const handleWindowClick = async (label: string) => {
  await focusWindow(label);
};
</script>

<template>
  <v-menu>
    <template #activator="{ props }">
      <v-btn v-bind="props" icon="mdi-window-restore">
        <v-badge :content="openWindows.length" color="primary" />
      </v-btn>
    </template>
    <v-list>
      <v-list-item
        v-for="window in openWindows"
        :key="window.label"
        @click="handleWindowClick(window.label)"
      >
        <v-list-item-title>{{ window.title }}</v-list-item-title>
        <template #append>
          <v-icon v-if="window.focused" color="primary">mdi-check</v-icon>
        </template>
      </v-list-item>
    </v-list>
  </v-menu>
</template>
```

---

## テスト設計

### ウィンドウストアテスト

**ファイル**: `tests/stores/window.spec.ts`

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { useWindowStore } from '@/stores/window';
import { windowApi } from '@/api/window';
import { getCurrentWindow } from '@tauri-apps/api/window';
import type { WindowInfo } from '@/types/window';

vi.mock('@tauri-apps/api/window', () => ({
  getCurrentWindow: vi.fn(() => ({ label: 'launcher' })),
}));

vi.mock('@/api/window', () => ({
  windowApi: {
    listWindows: vi.fn(),
    openQueryBuilder: vi.fn(),
    openSettings: vi.fn(),
    focusWindow: vi.fn(),
    closeWindow: vi.fn(),
    findWindowByConnection: vi.fn(),
  },
}));

const windowApiMock = vi.mocked(windowApi);
const getCurrentWindowMock = vi.mocked(getCurrentWindow);

const mockWindow: WindowInfo = {
  label: 'query-builder-123',
  title: 'QB',
  windowType: 'query_builder',
  connectionId: '123',
  focused: true,
  visible: true,
};

beforeEach(() => {
  setActivePinia(createPinia());
  vi.clearAllMocks();
  windowApiMock.listWindows.mockResolvedValue([]);
  windowApiMock.findWindowByConnection.mockResolvedValue(null);
});

it('ラベルからコンテキストを解析できる', () => {
  const store = useWindowStore();
  const context = store.parseWindowLabel('query-builder-conn-123');

  expect(context.windowType).toBe('query_builder');
  expect(context.connectionId).toBe('conn-123');
});

it('initializeでコンテキストを設定し一覧を取得する', async () => {
  const store = useWindowStore();
  getCurrentWindowMock.mockReturnValueOnce({ label: 'query-builder-999' } as any);
  windowApiMock.listWindows.mockResolvedValueOnce([mockWindow]);

  await store.initialize();

  expect(store.currentContext?.windowLabel).toBe('query-builder-999');
  expect(store.openWindows).toHaveLength(1);
});

it('既存ウィンドウがあればフォーカス、無ければ新規作成する', async () => {
  const store = useWindowStore();
  windowApiMock.findWindowByConnection.mockResolvedValueOnce({ ...mockWindow, label: 'existing' });

  await store.focusOrOpenQueryBuilder('123', 'DB', 'development');

  expect(windowApiMock.focusWindow).toHaveBeenCalledWith('existing');
});
```

---

## 実装チェックリスト

- [ ] `src/types/window.ts` の作成
  - [ ] WindowType型定義
  - [ ] WindowInfo型定義
  - [ ] WindowContext型定義
  - [ ] WindowEvent型定義
- [ ] `src/stores/window.ts` の作成
  - [ ] state定義
  - [ ] getters実装
  - [ ] actions実装
  - [ ] parseWindowLabel実装
- [ ] `src/composables/useWindow.ts` の作成
  - [ ] ストア初期化
  - [ ] イベントリスナー設定
  - [ ] 各種computed/methods
- [ ] ユニットテストの作成
- [ ] 各コンポーネントへの統合

---

## 参考資料

- [Pinia Store](https://pinia.vuejs.org/core-concepts/)
- [Vue Composables](https://vuejs.org/guide/reusability/composables.html)
- [Tauri Window API](https://tauri.app/v2/reference/js/window/)
- [Tauri Events](https://tauri.app/v2/guide/events/)
