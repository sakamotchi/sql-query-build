# タスク1.3.5: フロントエンド接続管理Store実装 設計書

## 概要

**タスクID**: 1.3.5
**タスク名**: フロントエンド接続管理Store実装
**工数**: 1日
**依存関係**: 1.3.4 (接続CRUD機能実装(Rust))
**完了条件**: Piniaで状態管理が動作

---

## 目的

Piniaを使用して、接続情報の状態管理を実装する。Tauriコマンドとの連携、ローカルキャッシュ、エラーハンドリングを提供する。

---

## アーキテクチャ

### Piniaストア構成

```
src/stores/
├── connection.ts      # 接続管理ストア
├── theme.ts          # テーマ管理ストア (1.4で実装)
└── types.ts          # 共通型定義
```

---

## 型定義

### types.ts

**ファイル**: `src/stores/types.ts`

```typescript
export interface Connection {
  id: string;
  name: string;
  environment: Environment;
  themeColor: string;
  host: string;
  port: number;
  database: string;
  username: string;
  password?: string;  // オプション(保存しない場合)
  dbType: DatabaseType;
  ssl: boolean;

  // 詳細設定
  sshTunnel?: boolean;
  sshHost?: string;
  sshPort?: number;
  sshUsername?: string;
  timeout?: number;

  // メタデータ
  createdAt: string;
  updatedAt: string;
  lastUsedAt?: string;
}

export type Environment = 'development' | 'test' | 'staging' | 'production';
export type DatabaseType = 'postgresql' | 'mysql' | 'sqlite';

export interface ConnectionFilter {
  searchQuery?: string;
  environment?: Environment | 'all';
  dbType?: DatabaseType | 'all';
}

export type ConnectionSort = 'name' | 'lastUsed' | 'environment' | 'createdAt';

export interface ConnectionStoreState {
  connections: Connection[];
  loading: boolean;
  error: string | null;
  filter: ConnectionFilter;
  sort: ConnectionSort;
}
```

---

## 接続管理ストア

### connection.ts

**ファイル**: `src/stores/connection.ts`

```typescript
import { defineStore } from 'pinia';
import { invoke } from '@tauri-apps/api/core';
import type {
  Connection,
  ConnectionFilter,
  ConnectionSort,
  ConnectionStoreState,
  Environment,
  DatabaseType,
} from './types';

export const useConnectionStore = defineStore('connection', {
  state: (): ConnectionStoreState => ({
    connections: [],
    loading: false,
    error: null,
    filter: {
      searchQuery: '',
      environment: 'all',
      dbType: 'all',
    },
    sort: 'lastUsed',
  }),

  getters: {
    /**
     * フィルタリング済みの接続リスト
     */
    filteredConnections(state): Connection[] {
      let filtered = [...state.connections];

      // 検索フィルター
      if (state.filter.searchQuery) {
        const query = state.filter.searchQuery.toLowerCase();
        filtered = filtered.filter(
          (conn) =>
            conn.name.toLowerCase().includes(query) ||
            conn.host.toLowerCase().includes(query) ||
            conn.database.toLowerCase().includes(query)
        );
      }

      // 環境フィルター
      if (state.filter.environment && state.filter.environment !== 'all') {
        filtered = filtered.filter(
          (conn) => conn.environment === state.filter.environment
        );
      }

      // データベース種別フィルター
      if (state.filter.dbType && state.filter.dbType !== 'all') {
        filtered = filtered.filter((conn) => conn.dbType === state.filter.dbType);
      }

      // ソート
      return this.sortConnections(filtered, state.sort);
    },

    /**
     * 環境別の接続数
     */
    connectionsByEnvironment(state): Record<Environment, number> {
      return state.connections.reduce(
        (acc, conn) => {
          acc[conn.environment] = (acc[conn.environment] || 0) + 1;
          return acc;
        },
        {} as Record<Environment, number>
      );
    },

    /**
     * データベース種別の接続数
     */
    connectionsByDbType(state): Record<DatabaseType, number> {
      return state.connections.reduce(
        (acc, conn) => {
          acc[conn.dbType] = (acc[conn.dbType] || 0) + 1;
          return acc;
        },
        {} as Record<DatabaseType, number>
      );
    },

    /**
     * 最近使用した接続 (上位5件)
     */
    recentConnections(state): Connection[] {
      return [...state.connections]
        .filter((conn) => conn.lastUsedAt)
        .sort(
          (a, b) =>
            new Date(b.lastUsedAt!).getTime() - new Date(a.lastUsedAt!).getTime()
        )
        .slice(0, 5);
    },

    /**
     * IDで接続を取得
     */
    getConnectionById: (state) => (id: string) => {
      return state.connections.find((conn) => conn.id === id);
    },
  },

  actions: {
    /**
     * すべての接続を取得
     */
    async fetchConnections() {
      this.loading = true;
      this.error = null;

      try {
        const connections = await invoke<Connection[]>('get_connections');
        this.connections = connections;
      } catch (error) {
        this.error = `接続情報の取得に失敗しました: ${error}`;
        console.error('Failed to fetch connections:', error);
        throw error;
      } finally {
        this.loading = false;
      }
    },

    /**
     * 接続を作成
     */
    async createConnection(connection: Connection) {
      this.loading = true;
      this.error = null;

      try {
        const created = await invoke<Connection>('create_connection', {
          connection,
        });

        this.connections.push(created);
        return created;
      } catch (error) {
        this.error = `接続の作成に失敗しました: ${error}`;
        console.error('Failed to create connection:', error);
        throw error;
      } finally {
        this.loading = false;
      }
    },

    /**
     * 接続を更新
     */
    async updateConnection(connection: Connection) {
      this.loading = true;
      this.error = null;

      try {
        const updated = await invoke<Connection>('update_connection', {
          connection,
        });

        const index = this.connections.findIndex((c) => c.id === updated.id);
        if (index !== -1) {
          this.connections[index] = updated;
        }

        return updated;
      } catch (error) {
        this.error = `接続の更新に失敗しました: ${error}`;
        console.error('Failed to update connection:', error);
        throw error;
      } finally {
        this.loading = false;
      }
    },

    /**
     * 接続を削除
     */
    async deleteConnection(id: string) {
      this.loading = true;
      this.error = null;

      try {
        await invoke('delete_connection', { id });

        const index = this.connections.findIndex((c) => c.id === id);
        if (index !== -1) {
          this.connections.splice(index, 1);
        }
      } catch (error) {
        this.error = `接続の削除に失敗しました: ${error}`;
        console.error('Failed to delete connection:', error);
        throw error;
      } finally {
        this.loading = false;
      }
    },

    /**
     * 最終使用日時を更新
     */
    async markConnectionAsUsed(id: string) {
      try {
        await invoke('mark_connection_used', { id });

        // ローカルの状態も更新
        const connection = this.connections.find((c) => c.id === id);
        if (connection) {
          connection.lastUsedAt = new Date().toISOString();
        }
      } catch (error) {
        console.error('Failed to mark connection as used:', error);
        // エラーは無視(致命的ではない)
      }
    },

    /**
     * 接続を複製
     */
    async duplicateConnection(id: string) {
      const original = this.getConnectionById(id);
      if (!original) {
        throw new Error('Connection not found');
      }

      const duplicated: Connection = {
        ...original,
        id: crypto.randomUUID(),
        name: `${original.name} (コピー)`,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        lastUsedAt: undefined,
      };

      return this.createConnection(duplicated);
    },

    /**
     * フィルターを設定
     */
    setFilter(filter: Partial<ConnectionFilter>) {
      this.filter = { ...this.filter, ...filter };
    },

    /**
     * フィルターをリセット
     */
    resetFilter() {
      this.filter = {
        searchQuery: '',
        environment: 'all',
        dbType: 'all',
      };
    },

    /**
     * ソート順を設定
     */
    setSort(sort: ConnectionSort) {
      this.sort = sort;
    },

    /**
     * エラーをクリア
     */
    clearError() {
      this.error = null;
    },

    /**
     * 接続をソート
     */
    sortConnections(connections: Connection[], sortBy: ConnectionSort): Connection[] {
      const sorted = [...connections];

      switch (sortBy) {
        case 'name':
          return sorted.sort((a, b) => a.name.localeCompare(b.name));

        case 'lastUsed':
          return sorted.sort((a, b) => {
            if (!a.lastUsedAt && !b.lastUsedAt) return 0;
            if (!a.lastUsedAt) return 1;
            if (!b.lastUsedAt) return -1;
            return (
              new Date(b.lastUsedAt).getTime() - new Date(a.lastUsedAt).getTime()
            );
          });

        case 'environment':
          const envOrder: Record<Environment, number> = {
            development: 0,
            test: 1,
            staging: 2,
            production: 3,
          };
          return sorted.sort(
            (a, b) => envOrder[a.environment] - envOrder[b.environment]
          );

        case 'createdAt':
          return sorted.sort(
            (a, b) =>
              new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
          );

        default:
          return sorted;
      }
    },
  },
});
```

---

## 使用例

### ランチャー画面での使用

```vue
<script setup lang="ts">
import { onMounted } from 'vue';
import { useConnectionStore } from '@/stores/connection';
import { storeToRefs } from 'pinia';

const connectionStore = useConnectionStore();
const { filteredConnections, loading, error } = storeToRefs(connectionStore);

// 接続リストを取得
onMounted(async () => {
  await connectionStore.fetchConnections();
});

// 接続を選択
const handleSelectConnection = async (connection: Connection) => {
  await connectionStore.markConnectionAsUsed(connection.id);
  // ウィンドウを起動...
};

// 接続を削除
const handleDeleteConnection = async (connection: Connection) => {
  if (confirm(`「${connection.name}」を削除してもよろしいですか?`)) {
    await connectionStore.deleteConnection(connection.id);
  }
};

// 検索フィルター
const handleSearch = (query: string) => {
  connectionStore.setFilter({ searchQuery: query });
};
</script>
```

### 接続フォームでの使用

```vue
<script setup lang="ts">
import { ref } from 'vue';
import { useConnectionStore } from '@/stores/connection';
import { useRouter } from 'vue-router';

const props = defineProps<{
  connectionId?: string;
  mode: 'create' | 'edit';
}>();

const connectionStore = useConnectionStore();
const router = useRouter();

const formData = ref<Connection>({
  // ... 初期値
});

// 編集時は既存データを読み込み
if (props.mode === 'edit' && props.connectionId) {
  const existing = connectionStore.getConnectionById(props.connectionId);
  if (existing) {
    formData.value = { ...existing };
  }
}

// 保存
const handleSave = async () => {
  try {
    if (props.mode === 'create') {
      await connectionStore.createConnection(formData.value);
    } else {
      await connectionStore.updateConnection(formData.value);
    }
    router.push('/launcher');
  } catch (error) {
    // エラー表示
  }
};
</script>
```

---

## Composableの作成

### useConnection.ts

**ファイル**: `src/composables/useConnection.ts`

```typescript
import { computed } from 'vue';
import { useConnectionStore } from '@/stores/connection';
import type { Connection } from '@/stores/types';

export function useConnection() {
  const store = useConnectionStore();

  /**
   * 環境別のテーマカラーを取得
   */
  const getEnvironmentColor = (environment: Connection['environment']): string => {
    const colors = {
      development: '#4CAF50',
      test: '#2196F3',
      staging: '#FF9800',
      production: '#F44336',
    };
    return colors[environment];
  };

  /**
   * 環境別のラベルを取得
   */
  const getEnvironmentLabel = (environment: Connection['environment']): string => {
    const labels = {
      development: '開発環境',
      test: 'テスト環境',
      staging: 'ステージング環境',
      production: '本番環境',
    };
    return labels[environment];
  };

  /**
   * データベース種別のラベルを取得
   */
  const getDatabaseTypeLabel = (dbType: Connection['dbType']): string => {
    const labels = {
      postgresql: 'PostgreSQL',
      mysql: 'MySQL',
      sqlite: 'SQLite',
    };
    return labels[dbType];
  };

  /**
   * データベース種別のアイコンを取得
   */
  const getDatabaseTypeIcon = (dbType: Connection['dbType']): string => {
    const icons = {
      postgresql: 'mdi-elephant',
      mysql: 'mdi-dolphin',
      sqlite: 'mdi-database',
    };
    return icons[dbType];
  };

  return {
    // ストアの参照
    store,

    // ゲッター
    connections: computed(() => store.connections),
    filteredConnections: computed(() => store.filteredConnections),
    loading: computed(() => store.loading),
    error: computed(() => store.error),
    recentConnections: computed(() => store.recentConnections),

    // アクション
    fetchConnections: store.fetchConnections,
    createConnection: store.createConnection,
    updateConnection: store.updateConnection,
    deleteConnection: store.deleteConnection,
    duplicateConnection: store.duplicateConnection,
    markConnectionAsUsed: store.markConnectionAsUsed,

    // フィルター
    setFilter: store.setFilter,
    resetFilter: store.resetFilter,
    setSort: store.setSort,
    clearError: store.clearError,

    // ヘルパー関数
    getEnvironmentColor,
    getEnvironmentLabel,
    getDatabaseTypeLabel,
    getDatabaseTypeIcon,
  };
}
```

---

## Piniaプラグイン

### 永続化プラグイン (オプション)

```typescript
import { PiniaPluginContext } from 'pinia';

/**
 * フィルター設定をlocalStorageに保存するプラグイン
 */
export function connectionPersistencePlugin({ store }: PiniaPluginContext) {
  if (store.$id === 'connection') {
    // フィルター設定を復元
    const savedFilter = localStorage.getItem('connection-filter');
    if (savedFilter) {
      try {
        store.$patch({
          filter: JSON.parse(savedFilter),
        });
      } catch (error) {
        console.error('Failed to restore filter:', error);
      }
    }

    // フィルター変更時に保存
    store.$subscribe((mutation, state) => {
      if (mutation.storeId === 'connection') {
        localStorage.setItem('connection-filter', JSON.stringify(state.filter));
      }
    });
  }
}
```

---

## エラーハンドリング

### グローバルエラーハンドラー

```typescript
// src/utils/errorHandler.ts
import { useToast } from '@/composables/useToast';

export function handleConnectionError(error: unknown) {
  const toast = useToast();

  if (error instanceof Error) {
    toast.error(error.message);
  } else if (typeof error === 'string') {
    toast.error(error);
  } else {
    toast.error('予期しないエラーが発生しました');
  }

  console.error('Connection error:', error);
}
```

---

## テスト

### Piniaストアのテスト

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { useConnectionStore } from '@/stores/connection';
import type { Connection } from '@/stores/types';

// Tauriのinvokeをモック
vi.mock('@tauri-apps/api/core', () => ({
  invoke: vi.fn(),
}));

describe('ConnectionStore', () => {
  beforeEach(() => {
    setActivePinia(createPinia());
  });

  it('should fetch connections', async () => {
    const store = useConnectionStore();
    const mockConnections: Connection[] = [
      {
        id: '1',
        name: 'Test DB',
        environment: 'development',
        // ... 他のフィールド
      },
    ];

    const { invoke } = await import('@tauri-apps/api/core');
    vi.mocked(invoke).mockResolvedValue(mockConnections);

    await store.fetchConnections();

    expect(store.connections).toEqual(mockConnections);
    expect(store.loading).toBe(false);
  });

  it('should filter connections by search query', () => {
    const store = useConnectionStore();
    store.connections = [
      { id: '1', name: 'Production DB', environment: 'production' } as Connection,
      { id: '2', name: 'Dev DB', environment: 'development' } as Connection,
    ];

    store.setFilter({ searchQuery: 'prod' });

    expect(store.filteredConnections).toHaveLength(1);
    expect(store.filteredConnections[0].name).toBe('Production DB');
  });

  it('should sort connections by name', () => {
    const store = useConnectionStore();
    store.connections = [
      { id: '1', name: 'Zebra DB', createdAt: '2023-01-01' } as Connection,
      { id: '2', name: 'Alpha DB', createdAt: '2023-01-02' } as Connection,
    ];

    store.setSort('name');

    const sorted = store.filteredConnections;
    expect(sorted[0].name).toBe('Alpha DB');
    expect(sorted[1].name).toBe('Zebra DB');
  });
});
```

---

## 実装チェックリスト

- [ ] `src/stores/types.ts` の作成
- [ ] `src/stores/connection.ts` の作成
- [ ] `src/composables/useConnection.ts` の作成
- [ ] フィルタリング機能の実装
- [ ] ソート機能の実装
- [ ] エラーハンドリングの実装
- [ ] ユニットテストの作成
- [ ] 統合テストの作成

---

## パフォーマンス最適化

### メモ化
- `computed` プロパティで自動的にメモ化
- フィルタリング・ソート結果はキャッシュされる

### 大量データ対応
- 仮想スクロールとの組み合わせ
- ページネーション機能の追加(将来)

---

## アクセシビリティ

### エラーメッセージ
- スクリーンリーダー対応
- aria-live で動的に通知

### ローディング状態
- ローディングインジケーター表示
- スケルトンスクリーンの活用
