# 1.5a.11 既存データマイグレーション実装

## 概要

| 項目 | 内容 |
|------|------|
| タスクID | 1.5a.11 |
| タスク名 | 既存データマイグレーション実装 |
| 担当 | BE |
| 工数 | 2日 |
| 依存関係 | 1.5a.7 |
| 完了条件 | 既存パスワードの新プロバイダーへの移行完了 |

## 目的

既存のキーチェーン方式で保存されているパスワードデータを、新しいセキュリティプロバイダー方式に安全に移行する。

## マイグレーション対象

```
~/.sql-query-build/
├── connections.json          # 既存接続情報（パスワード含む）
└── keychain/                 # 既存キーチェーンデータ
    └── master.key            # マスターキー
```

## 設計詳細

### マイグレーションバージョン

```rust
use serde::{Deserialize, Serialize};

/// マイグレーションバージョン
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum MigrationVersion {
    /// 初期バージョン（キーチェーン方式）
    V1 = 1,
    /// セキュリティプロバイダー方式
    V2 = 2,
}

impl MigrationVersion {
    pub fn current() -> Self {
        Self::V2
    }
}

/// マイグレーション状態
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MigrationState {
    /// 現在のバージョン
    pub current_version: u32,

    /// 最終マイグレーション日時
    pub last_migrated_at: Option<chrono::DateTime<chrono::Utc>>,

    /// マイグレーション履歴
    pub history: Vec<MigrationRecord>,
}

/// マイグレーション記録
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MigrationRecord {
    pub from_version: u32,
    pub to_version: u32,
    pub migrated_at: chrono::DateTime<chrono::Utc>,
    pub items_migrated: u32,
    pub success: bool,
    pub error_message: Option<String>,
}
```

### マイグレーションマネージャー

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

/// マイグレーションマネージャー
pub struct MigrationManager {
    /// ファイルストレージ
    file_storage: Arc<FileStorage>,

    /// 旧キーチェーンマネージャー（読み取り用）
    legacy_keychain: Arc<LegacyKeychainReader>,

    /// 新プロバイダーマネージャー
    provider_manager: Arc<RwLock<SecurityProviderManager>>,

    /// クレデンシャルストレージ
    credential_storage: Arc<CredentialStorage>,

    /// マイグレーション状態
    state: Arc<RwLock<MigrationState>>,
}

impl MigrationManager {
    pub fn new(
        file_storage: Arc<FileStorage>,
        legacy_keychain: Arc<LegacyKeychainReader>,
        provider_manager: Arc<RwLock<SecurityProviderManager>>,
        credential_storage: Arc<CredentialStorage>,
    ) -> Self {
        Self {
            file_storage,
            legacy_keychain,
            provider_manager,
            credential_storage,
            state: Arc::new(RwLock::new(MigrationState {
                current_version: 1,
                last_migrated_at: None,
                history: Vec::new(),
            })),
        }
    }

    /// マイグレーションが必要かチェック
    pub async fn needs_migration(&self) -> Result<bool, MigrationError> {
        let state = self.state.read().await;
        Ok(state.current_version < MigrationVersion::current() as u32)
    }

    /// マイグレーションを実行
    pub async fn migrate(&self) -> Result<MigrationResult, MigrationError> {
        let current_version = {
            self.state.read().await.current_version
        };

        match current_version {
            1 => self.migrate_v1_to_v2().await,
            _ => Ok(MigrationResult::AlreadyUpToDate),
        }
    }

    /// V1（キーチェーン方式）からV2（プロバイダー方式）へ移行
    async fn migrate_v1_to_v2(&self) -> Result<MigrationResult, MigrationError> {
        let started_at = chrono::Utc::now();
        let mut migrated_count = 0;
        let mut errors = Vec::new();

        // 1. 旧接続情報を読み込み
        let legacy_connections = self.load_legacy_connections().await?;

        // 2. 各接続のパスワードを移行
        for connection in &legacy_connections {
            match self.migrate_connection_password(connection).await {
                Ok(_) => {
                    migrated_count += 1;
                }
                Err(e) => {
                    errors.push(MigrationItemError {
                        connection_id: connection.id.clone(),
                        connection_name: connection.name.clone(),
                        error: e.to_string(),
                    });
                }
            }
        }

        // 3. 新しい接続情報形式で保存（パスワードを分離）
        self.save_migrated_connections(&legacy_connections).await?;

        // 4. マイグレーション状態を更新
        let record = MigrationRecord {
            from_version: 1,
            to_version: 2,
            migrated_at: chrono::Utc::now(),
            items_migrated: migrated_count,
            success: errors.is_empty(),
            error_message: if errors.is_empty() {
                None
            } else {
                Some(format!("{} items failed", errors.len()))
            },
        };

        {
            let mut state = self.state.write().await;
            state.current_version = 2;
            state.last_migrated_at = Some(chrono::Utc::now());
            state.history.push(record);
        }

        self.save_migration_state().await?;

        // 5. 旧データのバックアップ（削除はしない）
        self.backup_legacy_data().await?;

        Ok(MigrationResult::Success {
            migrated_count,
            errors,
            duration: chrono::Utc::now() - started_at,
        })
    }

    /// 旧接続情報を読み込み
    async fn load_legacy_connections(&self) -> Result<Vec<LegacyConnectionInfo>, MigrationError> {
        match self.file_storage.read::<Vec<LegacyConnectionInfo>>("connections") {
            Ok(connections) => Ok(connections),
            Err(crate::storage::StorageError::NotFound(_)) => Ok(Vec::new()),
            Err(e) => Err(MigrationError::StorageError(e.to_string())),
        }
    }

    /// 接続のパスワードを移行
    async fn migrate_connection_password(
        &self,
        connection: &LegacyConnectionInfo,
    ) -> Result<(), MigrationError> {
        // 旧方式でパスワードを復号
        let password = match &connection.encrypted_password {
            Some(encrypted) => {
                self.legacy_keychain
                    .decrypt_password(encrypted)
                    .await
                    .map_err(|e| MigrationError::DecryptionFailed(e.to_string()))?
            }
            None => return Ok(()), // パスワードなしの接続
        };

        // 新プロバイダーで暗号化して保存
        self.credential_storage
            .store(&connection.id, &password)
            .await
            .map_err(|e| MigrationError::EncryptionFailed(e.to_string()))?;

        // パスワードをゼロ化
        password.zeroize();

        Ok(())
    }

    /// 移行済み接続情報を保存
    async fn save_migrated_connections(
        &self,
        legacy_connections: &[LegacyConnectionInfo],
    ) -> Result<(), MigrationError> {
        // パスワードを除外した新形式に変換
        let new_connections: Vec<ConnectionInfo> = legacy_connections
            .iter()
            .map(|legacy| legacy.to_new_format())
            .collect();

        self.file_storage
            .write("connections", &new_connections)
            .map_err(|e| MigrationError::StorageError(e.to_string()))?;

        Ok(())
    }

    /// 旧データをバックアップ
    async fn backup_legacy_data(&self) -> Result<(), MigrationError> {
        let backup_key = format!(
            "backup/connections_v1_{}",
            chrono::Utc::now().format("%Y%m%d_%H%M%S")
        );

        // 旧接続情報をバックアップ
        if let Ok(legacy) = self.file_storage.read::<serde_json::Value>("connections") {
            self.file_storage
                .write(&backup_key, &legacy)
                .map_err(|e| MigrationError::StorageError(e.to_string()))?;
        }

        Ok(())
    }

    /// マイグレーション状態を保存
    async fn save_migration_state(&self) -> Result<(), MigrationError> {
        let state = self.state.read().await;
        self.file_storage
            .write("migration-state", &*state)
            .map_err(|e| MigrationError::StorageError(e.to_string()))?;
        Ok(())
    }

    /// マイグレーション状態を読み込み
    pub async fn load_migration_state(&self) -> Result<(), MigrationError> {
        match self.file_storage.read::<MigrationState>("migration-state") {
            Ok(state) => {
                *self.state.write().await = state;
                Ok(())
            }
            Err(crate::storage::StorageError::NotFound(_)) => Ok(()),
            Err(e) => Err(MigrationError::StorageError(e.to_string())),
        }
    }
}
```

### 旧キーチェーンリーダー

```rust
/// 旧キーチェーン方式の読み取り専用インターフェース
pub struct LegacyKeychainReader {
    master_key_manager: Arc<MasterKeyManager>,
    encryptor: Arc<Encryptor>,
}

impl LegacyKeychainReader {
    pub fn new(
        master_key_manager: Arc<MasterKeyManager>,
        encryptor: Arc<Encryptor>,
    ) -> Self {
        Self {
            master_key_manager,
            encryptor,
        }
    }

    /// 旧方式でパスワードを復号
    pub async fn decrypt_password(&self, encrypted: &str) -> Result<String, LegacyKeychainError> {
        // マスターキーを取得
        let master_key = self.master_key_manager
            .get_or_create_master_key()
            .map_err(|e| LegacyKeychainError::KeychainError(e.to_string()))?;

        // Base64デコード
        let encrypted_data: EncryptedData = serde_json::from_str(
            &String::from_utf8(
                base64::decode(encrypted)
                    .map_err(|e| LegacyKeychainError::DecodeError(e.to_string()))?
            ).map_err(|e| LegacyKeychainError::DecodeError(e.to_string()))?
        ).map_err(|e| LegacyKeychainError::DecodeError(e.to_string()))?;

        // 復号
        let password = self.encryptor
            .decrypt(&encrypted_data, &master_key)
            .map_err(|e| LegacyKeychainError::DecryptionError(e.to_string()))?;

        Ok(password)
    }

    /// キーチェーンが利用可能かチェック
    pub fn is_available(&self) -> bool {
        self.master_key_manager.get_or_create_master_key().is_ok()
    }
}
```

### 旧接続情報形式

```rust
/// 旧形式の接続情報（V1）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LegacyConnectionInfo {
    pub id: String,
    pub name: String,
    pub database_type: DatabaseType,
    pub host: Option<String>,
    pub port: Option<u16>,
    pub database: Option<String>,
    pub username: Option<String>,
    /// 旧形式：暗号化されたパスワード（接続情報に含まれる）
    pub encrypted_password: Option<String>,
    pub file_path: Option<String>,
    pub ssl_enabled: Option<bool>,
    pub environment: Option<String>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl LegacyConnectionInfo {
    /// 新形式に変換
    pub fn to_new_format(&self) -> ConnectionInfo {
        let connection = if let Some(host) = &self.host {
            ConnectionConfig::Network(NetworkConfig {
                host: host.clone(),
                port: self.port.unwrap_or(5432),
                database: self.database.clone().unwrap_or_default(),
                username: self.username.clone().unwrap_or_default(),
                encrypted_password: None, // パスワードは別管理
                ssl_config: self.ssl_enabled.map(|enabled| SslConfig {
                    enabled,
                    ..Default::default()
                }),
                options: None,
            })
        } else if let Some(file_path) = &self.file_path {
            ConnectionConfig::File(FileConfig {
                file_path: file_path.clone(),
                readonly: false,
            })
        } else {
            // デフォルト
            ConnectionConfig::Network(NetworkConfig {
                host: "localhost".to_string(),
                port: 5432,
                database: String::new(),
                username: String::new(),
                encrypted_password: None,
                ssl_config: None,
                options: None,
            })
        };

        ConnectionInfo {
            id: self.id.clone(),
            name: self.name.clone(),
            database_type: self.database_type,
            connection,
            environment: EnvironmentConfig::default(),
            metadata: ConnectionMetadata {
                created_at: self.created_at,
                updated_at: self.updated_at,
                last_connected_at: None,
                connection_count: 0,
                tags: Vec::new(),
                note: None,
                is_favorite: false,
            },
        }
    }
}
```

### エラー型

```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum MigrationError {
    #[error("Storage error: {0}")]
    StorageError(String),

    #[error("Decryption failed: {0}")]
    DecryptionFailed(String),

    #[error("Encryption failed: {0}")]
    EncryptionFailed(String),

    #[error("Legacy keychain not available")]
    LegacyKeychainNotAvailable,

    #[error("Migration already in progress")]
    MigrationInProgress,

    #[error("Rollback failed: {0}")]
    RollbackFailed(String),
}

#[derive(Debug, Error)]
pub enum LegacyKeychainError {
    #[error("Keychain error: {0}")]
    KeychainError(String),

    #[error("Decode error: {0}")]
    DecodeError(String),

    #[error("Decryption error: {0}")]
    DecryptionError(String),
}

/// マイグレーション結果
#[derive(Debug)]
pub enum MigrationResult {
    /// 成功
    Success {
        migrated_count: u32,
        errors: Vec<MigrationItemError>,
        duration: chrono::Duration,
    },
    /// すでに最新
    AlreadyUpToDate,
}

/// 個別アイテムのマイグレーションエラー
#[derive(Debug, Clone, Serialize)]
pub struct MigrationItemError {
    pub connection_id: String,
    pub connection_name: String,
    pub error: String,
}
```

### Tauriコマンド

```rust
/// マイグレーションが必要かチェック
#[tauri::command]
pub async fn check_migration_needed(
    manager: State<'_, Arc<MigrationManager>>,
) -> Result<bool, String> {
    manager.needs_migration().await.map_err(|e| e.to_string())
}

/// マイグレーションを実行
#[tauri::command]
pub async fn run_migration(
    manager: State<'_, Arc<MigrationManager>>,
) -> Result<MigrationResultDto, String> {
    let result = manager.migrate().await.map_err(|e| e.to_string())?;

    Ok(match result {
        MigrationResult::Success { migrated_count, errors, duration } => {
            MigrationResultDto {
                status: "success".to_string(),
                migrated_count: Some(migrated_count),
                error_count: Some(errors.len() as u32),
                errors: Some(errors),
                duration_ms: Some(duration.num_milliseconds() as u64),
            }
        }
        MigrationResult::AlreadyUpToDate => {
            MigrationResultDto {
                status: "already_up_to_date".to_string(),
                migrated_count: None,
                error_count: None,
                errors: None,
                duration_ms: None,
            }
        }
    })
}

/// マイグレーション状態を取得
#[tauri::command]
pub async fn get_migration_state(
    manager: State<'_, Arc<MigrationManager>>,
) -> Result<MigrationState, String> {
    manager.load_migration_state().await.map_err(|e| e.to_string())?;
    Ok(manager.state.read().await.clone())
}
```

### フロントエンド統合

```typescript
// src/api/migration.ts
import { invoke } from '@tauri-apps/api/core';

export interface MigrationResult {
  status: 'success' | 'already_up_to_date';
  migrated_count?: number;
  error_count?: number;
  errors?: MigrationItemError[];
  duration_ms?: number;
}

export interface MigrationItemError {
  connection_id: string;
  connection_name: string;
  error: string;
}

export const migrationApi = {
  async checkNeeded(): Promise<boolean> {
    return invoke('check_migration_needed');
  },

  async run(): Promise<MigrationResult> {
    return invoke('run_migration');
  },
};
```

### アプリ起動時のマイグレーションチェック

```typescript
// src/App.vue（抜粋）
import { migrationApi } from '@/api/migration';

const checkAndRunMigration = async () => {
  try {
    const needsMigration = await migrationApi.checkNeeded();

    if (needsMigration) {
      // マイグレーション実行中の表示
      isMigrating.value = true;

      const result = await migrationApi.run();

      if (result.status === 'success') {
        if (result.error_count && result.error_count > 0) {
          // 一部エラーありの通知
          showMigrationWarning(result.errors);
        }
      }

      isMigrating.value = false;
    }
  } catch (error) {
    console.error('Migration failed:', error);
    showMigrationError(error);
  }
};

onMounted(async () => {
  await checkAndRunMigration();
  // 通常の初期化処理
});
```

## テスト

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    async fn setup_test_environment() -> (TempDir, MigrationManager) {
        let temp_dir = TempDir::new().unwrap();
        // テスト用のセットアップ
        // ...
    }

    #[tokio::test]
    async fn test_migration_needed_for_v1() {
        let (temp_dir, manager) = setup_test_environment().await;

        // V1の状態を設定
        // ...

        assert!(manager.needs_migration().await.unwrap());
    }

    #[tokio::test]
    async fn test_migrate_v1_to_v2() {
        let (temp_dir, manager) = setup_test_environment().await;

        // 旧形式のデータを作成
        // ...

        let result = manager.migrate().await.unwrap();

        if let MigrationResult::Success { migrated_count, errors, .. } = result {
            assert!(migrated_count > 0);
            assert!(errors.is_empty());
        } else {
            panic!("Expected successful migration");
        }
    }

    #[tokio::test]
    async fn test_migration_preserves_data() {
        // マイグレーション後もデータが保持されることを確認
    }

    #[tokio::test]
    async fn test_migration_creates_backup() {
        // バックアップが作成されることを確認
    }

    #[tokio::test]
    async fn test_migration_handles_missing_password() {
        // パスワードなしの接続も正しく移行されることを確認
    }
}
```

## 実装チェックリスト

- [ ] `MigrationVersion` enum実装
- [ ] `MigrationState` 構造体実装
- [ ] `MigrationManager` 実装
- [ ] `LegacyKeychainReader` 実装
- [ ] `LegacyConnectionInfo` 変換実装
- [ ] エラー型実装
- [ ] Tauriコマンド実装
- [ ] フロントエンドAPI実装
- [ ] App.vue統合
- [ ] ユニットテスト作成

---

**作成日**: 2025-11-24
**作成者**: Claude Code
