# 1.5a.5 CredentialStorage実装（機密情報分離）

## 概要

| 項目 | 内容 |
|------|------|
| タスクID | 1.5a.5 |
| タスク名 | CredentialStorage実装（機密情報分離） |
| 担当 | BE |
| 工数 | 2日 |
| 依存関係 | 1.5a.2 |
| 完了条件 | credentials.jsonへの分離保存 |

## 目的

接続情報からパスワード等の機密情報を分離し、専用の暗号化ストレージで管理する。
DBeaverの`credentials-config.json`と同様のアプローチ。

## ファイル構造

```
~/.sql-query-build/
├── connections.json          # 接続情報（パスワード以外）- 平文JSON
├── credentials.json          # パスワード等の機密情報 - 暗号化
└── security-config.json      # セキュリティ設定
```

## 設計詳細

### データモデル

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// 接続ID
pub type ConnectionId = String;

/// 認証情報エントリ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CredentialEntry {
    /// パスワード（暗号化前の平文、メモリ上のみ）
    #[serde(skip)]
    pub password: Option<String>,

    /// 暗号化されたパスワード
    pub encrypted_password: Option<String>,

    /// SSHキーのパスフレーズ（暗号化済み）
    pub encrypted_ssh_passphrase: Option<String>,

    /// SSL証明書のパスワード（暗号化済み）
    pub encrypted_ssl_password: Option<String>,

    /// 最終更新日時
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

/// 認証情報コレクション
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CredentialCollection {
    /// バージョン
    pub version: u32,

    /// 認証情報マップ（接続ID -> 認証情報）
    pub credentials: HashMap<ConnectionId, CredentialEntry>,

    /// 作成日時
    pub created_at: chrono::DateTime<chrono::Utc>,

    /// 最終更新日時
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl CredentialCollection {
    pub fn new() -> Self {
        let now = chrono::Utc::now();
        Self {
            version: 1,
            credentials: HashMap::new(),
            created_at: now,
            updated_at: now,
        }
    }
}
```

### CredentialStorage実装

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

use crate::crypto::{encrypt_string, decrypt_string};
use crate::crypto::security_provider::SecurityProviderManager;
use crate::storage::FileStorage;

/// 認証情報ストレージ
pub struct CredentialStorage {
    /// ファイルストレージ
    file_storage: Arc<FileStorage>,

    /// セキュリティプロバイダーマネージャー
    provider_manager: Arc<SecurityProviderManager>,

    /// メモリキャッシュ
    cache: Arc<RwLock<Option<CredentialCollection>>>,

    /// ストレージキー
    storage_key: String,
}

impl CredentialStorage {
    /// ストレージキー
    const STORAGE_KEY: &'static str = "credentials";

    /// 新しいCredentialStorageを作成
    pub fn new(
        file_storage: Arc<FileStorage>,
        provider_manager: Arc<SecurityProviderManager>,
    ) -> Self {
        Self {
            file_storage,
            provider_manager,
            cache: Arc::new(RwLock::new(None)),
            storage_key: Self::STORAGE_KEY.to_string(),
        }
    }

    /// 接続IDに対応する認証情報を取得
    pub async fn get(&self, connection_id: &str) -> Result<Option<CredentialEntry>, CredentialError> {
        let collection = self.load_collection().await?;

        match collection.credentials.get(connection_id) {
            Some(entry) => {
                // パスワードを復号化
                let decrypted = self.decrypt_entry(entry).await?;
                Ok(Some(decrypted))
            }
            None => Ok(None),
        }
    }

    /// パスワードのみを取得
    pub async fn get_password(&self, connection_id: &str) -> Result<Option<String>, CredentialError> {
        let entry = self.get(connection_id).await?;
        Ok(entry.and_then(|e| e.password))
    }

    /// 認証情報を保存
    pub async fn save(
        &self,
        connection_id: &str,
        password: Option<&str>,
        ssh_passphrase: Option<&str>,
        ssl_password: Option<&str>,
    ) -> Result<(), CredentialError> {
        let mut collection = self.load_collection().await?;

        // 暗号化キーを取得
        let key = self.provider_manager.get_encryption_key().await
            .map_err(|e| CredentialError::ProviderError(e.to_string()))?;

        // 各フィールドを暗号化
        let encrypted_password = match password {
            Some(p) if !p.is_empty() => Some(encrypt_string(p, &key)
                .map_err(|e| CredentialError::EncryptionError(e.to_string()))?),
            _ => None,
        };

        let encrypted_ssh_passphrase = match ssh_passphrase {
            Some(p) if !p.is_empty() => Some(encrypt_string(p, &key)
                .map_err(|e| CredentialError::EncryptionError(e.to_string()))?),
            _ => None,
        };

        let encrypted_ssl_password = match ssl_password {
            Some(p) if !p.is_empty() => Some(encrypt_string(p, &key)
                .map_err(|e| CredentialError::EncryptionError(e.to_string()))?),
            _ => None,
        };

        // エントリを作成または更新
        let entry = CredentialEntry {
            password: None, // 平文はメモリ上にのみ保持
            encrypted_password,
            encrypted_ssh_passphrase,
            encrypted_ssl_password,
            updated_at: chrono::Utc::now(),
        };

        collection.credentials.insert(connection_id.to_string(), entry);
        collection.updated_at = chrono::Utc::now();

        // 保存
        self.save_collection(&collection).await?;

        Ok(())
    }

    /// 認証情報を削除
    pub async fn delete(&self, connection_id: &str) -> Result<(), CredentialError> {
        let mut collection = self.load_collection().await?;

        if collection.credentials.remove(connection_id).is_some() {
            collection.updated_at = chrono::Utc::now();
            self.save_collection(&collection).await?;
        }

        Ok(())
    }

    /// 全ての認証情報を削除
    pub async fn delete_all(&self) -> Result<(), CredentialError> {
        let collection = CredentialCollection::new();
        self.save_collection(&collection).await?;
        Ok(())
    }

    /// コレクションを読み込み
    async fn load_collection(&self) -> Result<CredentialCollection, CredentialError> {
        // キャッシュをチェック
        {
            let cache = self.cache.read().await;
            if let Some(collection) = cache.as_ref() {
                return Ok(collection.clone());
            }
        }

        // ファイルから読み込み
        let collection = match self.file_storage.read::<CredentialCollection>(&self.storage_key) {
            Ok(c) => c,
            Err(crate::storage::StorageError::NotFound(_)) => CredentialCollection::new(),
            Err(e) => return Err(CredentialError::StorageError(e.to_string())),
        };

        // キャッシュに保存
        *self.cache.write().await = Some(collection.clone());

        Ok(collection)
    }

    /// コレクションを保存
    async fn save_collection(&self, collection: &CredentialCollection) -> Result<(), CredentialError> {
        self.file_storage.write(&self.storage_key, collection)
            .map_err(|e| CredentialError::StorageError(e.to_string()))?;

        // キャッシュを更新
        *self.cache.write().await = Some(collection.clone());

        Ok(())
    }

    /// エントリを復号化
    async fn decrypt_entry(&self, entry: &CredentialEntry) -> Result<CredentialEntry, CredentialError> {
        let key = self.provider_manager.get_encryption_key().await
            .map_err(|e| CredentialError::ProviderError(e.to_string()))?;

        let password = match &entry.encrypted_password {
            Some(encrypted) => Some(decrypt_string(encrypted, &key)
                .map_err(|e| CredentialError::DecryptionError(e.to_string()))?),
            None => None,
        };

        Ok(CredentialEntry {
            password,
            encrypted_password: entry.encrypted_password.clone(),
            encrypted_ssh_passphrase: entry.encrypted_ssh_passphrase.clone(),
            encrypted_ssl_password: entry.encrypted_ssl_password.clone(),
            updated_at: entry.updated_at,
        })
    }

    /// キャッシュをクリア
    pub async fn clear_cache(&self) {
        *self.cache.write().await = None;
    }

    /// 全ての認証情報を新しいキーで再暗号化
    pub async fn re_encrypt_all(&self, old_key: &[u8], new_key: &[u8]) -> Result<(), CredentialError> {
        let mut collection = self.load_collection().await?;

        for (_, entry) in collection.credentials.iter_mut() {
            // パスワードを復号化して再暗号化
            if let Some(encrypted) = &entry.encrypted_password {
                let decrypted = decrypt_string(encrypted, old_key)
                    .map_err(|e| CredentialError::DecryptionError(e.to_string()))?;
                entry.encrypted_password = Some(encrypt_string(&decrypted, new_key)
                    .map_err(|e| CredentialError::EncryptionError(e.to_string()))?);
            }

            // SSHパスフレーズ
            if let Some(encrypted) = &entry.encrypted_ssh_passphrase {
                let decrypted = decrypt_string(encrypted, old_key)
                    .map_err(|e| CredentialError::DecryptionError(e.to_string()))?;
                entry.encrypted_ssh_passphrase = Some(encrypt_string(&decrypted, new_key)
                    .map_err(|e| CredentialError::EncryptionError(e.to_string()))?);
            }

            // SSL証明書パスワード
            if let Some(encrypted) = &entry.encrypted_ssl_password {
                let decrypted = decrypt_string(encrypted, old_key)
                    .map_err(|e| CredentialError::DecryptionError(e.to_string()))?;
                entry.encrypted_ssl_password = Some(encrypt_string(&decrypted, new_key)
                    .map_err(|e| CredentialError::EncryptionError(e.to_string()))?);
            }

            entry.updated_at = chrono::Utc::now();
        }

        collection.updated_at = chrono::Utc::now();
        self.save_collection(&collection).await?;

        Ok(())
    }
}
```

### エラー型

```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum CredentialError {
    #[error("Storage error: {0}")]
    StorageError(String),

    #[error("Encryption error: {0}")]
    EncryptionError(String),

    #[error("Decryption error: {0}")]
    DecryptionError(String),

    #[error("Provider error: {0}")]
    ProviderError(String),

    #[error("Credential not found: {0}")]
    NotFound(String),
}
```

## ConnectionStorageとの統合

```rust
/// 接続情報ストレージ（既存を拡張）
impl ConnectionStorage {
    /// パスワード付きで接続情報を保存
    pub async fn create_with_password(
        &self,
        connection: ConnectionInfo,
        password: Option<&str>,
        credential_storage: &CredentialStorage,
    ) -> Result<ConnectionInfo, ConnectionError> {
        // 接続情報を保存（パスワードなし）
        let saved = self.create(connection)?;

        // パスワードを別途保存
        if let Some(pwd) = password {
            credential_storage.save(&saved.id, Some(pwd), None, None).await
                .map_err(|e| ConnectionError::StorageError(e.to_string()))?;
        }

        Ok(saved)
    }

    /// 接続情報を削除（認証情報も削除）
    pub async fn delete_with_credentials(
        &self,
        id: &str,
        credential_storage: &CredentialStorage,
    ) -> Result<(), ConnectionError> {
        // 認証情報を削除
        let _ = credential_storage.delete(id).await;

        // 接続情報を削除
        self.delete(id)
    }
}
```

## テスト

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    async fn create_test_storage() -> (CredentialStorage, TempDir) {
        let temp_dir = TempDir::new().unwrap();
        let file_storage = Arc::new(FileStorage::new(temp_dir.path().to_path_buf()).unwrap());

        // モックプロバイダーマネージャーを使用
        let provider_manager = Arc::new(create_mock_provider_manager().await);

        let storage = CredentialStorage::new(file_storage, provider_manager);
        (storage, temp_dir)
    }

    #[tokio::test]
    async fn test_save_and_get_password() {
        let (storage, _temp) = create_test_storage().await;

        storage.save("conn-1", Some("secret123"), None, None).await.unwrap();

        let password = storage.get_password("conn-1").await.unwrap();
        assert_eq!(password, Some("secret123".to_string()));
    }

    #[tokio::test]
    async fn test_delete_credential() {
        let (storage, _temp) = create_test_storage().await;

        storage.save("conn-1", Some("secret123"), None, None).await.unwrap();
        storage.delete("conn-1").await.unwrap();

        let password = storage.get_password("conn-1").await.unwrap();
        assert!(password.is_none());
    }

    #[tokio::test]
    async fn test_update_password() {
        let (storage, _temp) = create_test_storage().await;

        storage.save("conn-1", Some("old_password"), None, None).await.unwrap();
        storage.save("conn-1", Some("new_password"), None, None).await.unwrap();

        let password = storage.get_password("conn-1").await.unwrap();
        assert_eq!(password, Some("new_password".to_string()));
    }

    #[tokio::test]
    async fn test_multiple_credentials() {
        let (storage, _temp) = create_test_storage().await;

        storage.save("conn-1", Some("pass1"), None, None).await.unwrap();
        storage.save("conn-2", Some("pass2"), None, None).await.unwrap();

        assert_eq!(storage.get_password("conn-1").await.unwrap(), Some("pass1".to_string()));
        assert_eq!(storage.get_password("conn-2").await.unwrap(), Some("pass2".to_string()));
    }
}
```

## 実装チェックリスト

- [ ] `CredentialEntry` 構造体実装
- [ ] `CredentialCollection` 構造体実装
- [ ] `CredentialStorage` 構造体実装
- [ ] `CredentialError` エラー型実装
- [ ] 暗号化/復号化機能実装
- [ ] 再暗号化機能実装
- [ ] `ConnectionStorage` との統合
- [ ] キャッシュ機能実装
- [ ] ユニットテスト作成

---

**作成日**: 2025-11-24
**作成者**: Claude Code
