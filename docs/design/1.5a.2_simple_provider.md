# 1.5a.2 SimpleProvider実装

## 概要

| 項目 | 内容 |
|------|------|
| タスクID | 1.5a.2 |
| タスク名 | SimpleProvider実装 |
| 担当 | BE |
| 工数 | 1.5日 |
| 依存関係 | 1.5a.1 |
| 完了条件 | 固定キー暗号化が動作 |

## 目的

パスワード入力なしで利用できるシンプルな暗号化プロバイダーを実装する。
DBeaverのデフォルト暗号化と同様に、アプリ固有のキーを使用してパスワードを暗号化する。

## セキュリティ特性

| 項目 | 説明 |
|------|------|
| セキュリティレベル | 低（カジュアル保護） |
| 暗号化アルゴリズム | AES-256-GCM |
| キー生成 | アプリ固定シード + 環境固有情報 + ランダムソルト |
| 利点 | パスワード入力不要、即座に利用可能 |
| 欠点 | ソースコードにアクセスできれば理論上は復号可能 |

## アーキテクチャ

### ファイル構成

```
src-tauri/src/crypto/security_provider/
├── simple.rs           # SimpleProvider実装
└── simple_key.rs       # キー生成ロジック（内部モジュール）
```

## 設計詳細

### キー生成戦略

DBeaverの問題点（公開されたDESキー）を改善するため、以下の戦略を採用：

1. **アプリ固定シード**: コンパイル時に埋め込まれる固定値
2. **環境固有情報**: マシン固有の情報を組み合わせ
3. **ユーザー固有ソルト**: 初回起動時に生成し、ローカルに保存

```rust
/// キー生成に使用する環境情報
struct EnvironmentInfo {
    /// ホスト名
    hostname: String,
    /// ユーザー名
    username: String,
    /// アプリケーションデータディレクトリのパス
    app_data_path: String,
}

impl EnvironmentInfo {
    fn collect() -> Self {
        Self {
            hostname: hostname::get()
                .map(|h| h.to_string_lossy().to_string())
                .unwrap_or_else(|_| "unknown".to_string()),
            username: whoami::username(),
            app_data_path: app_data_dir()
                .map(|p| p.to_string_lossy().to_string())
                .unwrap_or_else(|| "default".to_string()),
        }
    }

    fn to_bytes(&self) -> Vec<u8> {
        let combined = format!(
            "{}:{}:{}",
            self.hostname, self.username, self.app_data_path
        );
        combined.into_bytes()
    }
}
```

### SimpleProvider実装

```rust
use async_trait::async_trait;
use std::sync::RwLock;
use zeroize::Zeroizing;

use super::{
    traits::SecurityProvider,
    types::{ProviderState, SecurityProviderType, InitializeParams, UnlockParams},
    error::{SecurityProviderError, SecurityProviderResult},
};
use crate::crypto::{AesGcmEncryptor, Encryptor};
use crate::storage::FileStorage;

/// アプリ固定のシード値（コンパイル時に埋め込み）
/// 注意: この値は公開されるため、追加の環境情報と組み合わせて使用
const APP_SEED: &[u8] = b"sql-query-build-v1-simple-provider-seed-2024";

/// シンプルプロバイダー
///
/// アプリ固定のキーを使用してパスワードを暗号化する。
/// パスワード入力不要で即座に利用可能。
pub struct SimpleProvider {
    /// プロバイダーの状態
    state: RwLock<ProviderState>,

    /// 暗号化キー（メモリ上にキャッシュ）
    cached_key: RwLock<Option<Zeroizing<Vec<u8>>>>,

    /// ユーザー固有ソルトのストレージ
    storage: Option<Arc<FileStorage>>,
}

impl SimpleProvider {
    /// 新しいSimpleProviderを作成
    pub fn new() -> Self {
        Self {
            state: RwLock::new(ProviderState::Uninitialized),
            cached_key: RwLock::new(None),
            storage: None,
        }
    }

    /// ストレージを設定
    pub fn with_storage(mut self, storage: Arc<FileStorage>) -> Self {
        self.storage = Some(storage);
        self
    }

    /// マスターキーを生成
    fn generate_master_key(&self, user_salt: &[u8]) -> Zeroizing<Vec<u8>> {
        use sha2::{Sha256, Digest};
        use pbkdf2::pbkdf2_hmac;

        // 環境情報を収集
        let env_info = EnvironmentInfo::collect();
        let env_bytes = env_info.to_bytes();

        // シード材料を結合
        let mut seed_material = Vec::new();
        seed_material.extend_from_slice(APP_SEED);
        seed_material.extend_from_slice(&env_bytes);
        seed_material.extend_from_slice(user_salt);

        // SHA-256でハッシュ化してシードを生成
        let mut hasher = Sha256::new();
        hasher.update(&seed_material);
        let seed = hasher.finalize();

        // PBKDF2でキーを導出
        let mut key = Zeroizing::new(vec![0u8; 32]);
        pbkdf2_hmac::<Sha256>(&seed, user_salt, 100_000, &mut key);

        key
    }

    /// ユーザー固有ソルトを取得または生成
    async fn get_or_create_user_salt(&self) -> SecurityProviderResult<Vec<u8>> {
        let storage = self.storage.as_ref()
            .ok_or_else(|| SecurityProviderError::Internal("Storage not configured".to_string()))?;

        // ソルト設定を読み込み
        match storage.read::<SimpleSaltConfig>("simple_provider_salt") {
            Ok(config) => Ok(config.salt),
            Err(_) => {
                // 新しいソルトを生成
                let salt = Self::generate_random_salt();
                let config = SimpleSaltConfig {
                    version: 1,
                    salt: salt.clone(),
                    created_at: chrono::Utc::now(),
                };
                storage.write("simple_provider_salt", &config)
                    .map_err(|e| SecurityProviderError::StorageError(e.to_string()))?;
                Ok(salt)
            }
        }
    }

    /// ランダムなソルトを生成
    fn generate_random_salt() -> Vec<u8> {
        use rand::RngCore;
        let mut salt = vec![0u8; 32];
        rand::thread_rng().fill_bytes(&mut salt);
        salt
    }
}

/// ソルト設定
#[derive(Debug, Clone, Serialize, Deserialize)]
struct SimpleSaltConfig {
    version: u32,
    salt: Vec<u8>,
    created_at: chrono::DateTime<chrono::Utc>,
}

#[async_trait]
impl SecurityProvider for SimpleProvider {
    fn provider_type(&self) -> SecurityProviderType {
        SecurityProviderType::Simple
    }

    fn state(&self) -> ProviderState {
        self.state.read().unwrap().clone()
    }

    fn needs_initialization(&self) -> bool {
        matches!(*self.state.read().unwrap(), ProviderState::Uninitialized)
    }

    fn needs_unlock(&self) -> bool {
        // Simpleプロバイダーはアンロック不要
        false
    }

    async fn initialize(&mut self, params: InitializeParams) -> SecurityProviderResult<()> {
        // パラメータの検証
        if !matches!(params, InitializeParams::Simple) {
            return Err(SecurityProviderError::InvalidParams(
                "Simple provider requires Simple params".to_string()
            ));
        }

        // ユーザー固有ソルトを取得または生成
        let user_salt = self.get_or_create_user_salt().await?;

        // マスターキーを生成
        let key = self.generate_master_key(&user_salt);

        // キーをキャッシュ
        *self.cached_key.write().unwrap() = Some(key);

        // 状態を更新
        *self.state.write().unwrap() = ProviderState::Ready;

        Ok(())
    }

    async fn unlock(&mut self, params: UnlockParams) -> SecurityProviderResult<()> {
        // Simpleプロバイダーはアンロック不要
        // initialize()と同じ処理を実行
        self.initialize(InitializeParams::Simple).await
    }

    async fn lock(&mut self) {
        // キーをクリア（zeroize）
        *self.cached_key.write().unwrap() = None;

        // 状態を更新（Simpleプロバイダーはロック後すぐにReadyに戻れる）
        *self.state.write().unwrap() = ProviderState::Locked;
    }

    async fn get_encryption_key(&self) -> SecurityProviderResult<Vec<u8>> {
        // キャッシュからキーを取得
        let cached = self.cached_key.read().unwrap();
        match cached.as_ref() {
            Some(key) => Ok(key.to_vec()),
            None => {
                // キーがない場合は自動的に初期化
                drop(cached);
                // Note: selfがmutableでないため、ここでは初期化できない
                // 呼び出し側でinitialize()を呼ぶ必要がある
                Err(SecurityProviderError::NotInitialized)
            }
        }
    }

    async fn reset(&mut self) -> SecurityProviderResult<()> {
        // キーをクリア
        *self.cached_key.write().unwrap() = None;

        // ソルト設定を削除
        if let Some(storage) = &self.storage {
            let _ = storage.delete("simple_provider_salt");
        }

        // 状態を更新
        *self.state.write().unwrap() = ProviderState::Uninitialized;

        Ok(())
    }

    fn validate(&self) -> SecurityProviderResult<()> {
        // Simpleプロバイダーは常に有効
        Ok(())
    }
}

impl Default for SimpleProvider {
    fn default() -> Self {
        Self::new()
    }
}
```

### 自動初期化機能

SimpleProviderは初回アクセス時に自動的に初期化される：

```rust
impl SimpleProvider {
    /// 暗号化キーを取得（自動初期化付き）
    pub async fn get_or_init_encryption_key(&mut self) -> SecurityProviderResult<Vec<u8>> {
        if self.needs_initialization() {
            self.initialize(InitializeParams::Simple).await?;
        }
        self.get_encryption_key().await
    }
}
```

## セキュリティ考慮事項

### キー生成の安全性

1. **多要素シード**: アプリ固定シード + 環境情報 + ユーザーソルトの組み合わせ
2. **PBKDF2**: 100,000回の反復でブルートフォース攻撃を困難に
3. **ユーザー固有ソルト**: 同じアプリでもユーザーごとに異なるキー

### 既知の制限

1. **ソースコードアクセス**: アプリ固定シードは理論上は抽出可能
2. **同一環境での複製**: 環境情報とソルトがコピーされると復号可能
3. **メモリダンプ**: 実行中のメモリからキーを抽出可能

### 緩和策

```rust
impl Drop for SimpleProvider {
    fn drop(&mut self) {
        // プロバイダー破棄時にキーをクリア
        if let Ok(mut cached) = self.cached_key.write() {
            *cached = None;
        }
    }
}
```

## テスト

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn create_test_storage() -> (Arc<FileStorage>, TempDir) {
        let temp_dir = TempDir::new().unwrap();
        let storage = Arc::new(FileStorage::new(temp_dir.path().to_path_buf()).unwrap());
        (storage, temp_dir)
    }

    #[tokio::test]
    async fn test_simple_provider_initialization() {
        let (storage, _temp) = create_test_storage();
        let mut provider = SimpleProvider::new().with_storage(storage);

        assert!(provider.needs_initialization());
        assert_eq!(provider.state(), ProviderState::Uninitialized);

        provider.initialize(InitializeParams::Simple).await.unwrap();

        assert!(!provider.needs_initialization());
        assert_eq!(provider.state(), ProviderState::Ready);
    }

    #[tokio::test]
    async fn test_simple_provider_get_key() {
        let (storage, _temp) = create_test_storage();
        let mut provider = SimpleProvider::new().with_storage(storage);

        provider.initialize(InitializeParams::Simple).await.unwrap();

        let key = provider.get_encryption_key().await.unwrap();
        assert_eq!(key.len(), 32);
    }

    #[tokio::test]
    async fn test_simple_provider_key_consistency() {
        let (storage, _temp) = create_test_storage();
        let mut provider = SimpleProvider::new().with_storage(storage.clone());

        provider.initialize(InitializeParams::Simple).await.unwrap();
        let key1 = provider.get_encryption_key().await.unwrap();

        // 新しいプロバイダーインスタンスでも同じキーが得られる
        let mut provider2 = SimpleProvider::new().with_storage(storage);
        provider2.initialize(InitializeParams::Simple).await.unwrap();
        let key2 = provider2.get_encryption_key().await.unwrap();

        assert_eq!(key1, key2);
    }

    #[tokio::test]
    async fn test_simple_provider_reset() {
        let (storage, _temp) = create_test_storage();
        let mut provider = SimpleProvider::new().with_storage(storage.clone());

        provider.initialize(InitializeParams::Simple).await.unwrap();
        let key1 = provider.get_encryption_key().await.unwrap();

        provider.reset().await.unwrap();
        assert!(provider.needs_initialization());

        // リセット後は新しいソルトで新しいキーが生成される
        provider.initialize(InitializeParams::Simple).await.unwrap();
        let key2 = provider.get_encryption_key().await.unwrap();

        assert_ne!(key1, key2);
    }

    #[tokio::test]
    async fn test_simple_provider_no_unlock_required() {
        let provider = SimpleProvider::new();
        assert!(!provider.needs_unlock());
    }

    #[tokio::test]
    async fn test_simple_provider_lock() {
        let (storage, _temp) = create_test_storage();
        let mut provider = SimpleProvider::new().with_storage(storage);

        provider.initialize(InitializeParams::Simple).await.unwrap();
        provider.lock().await;

        assert!(provider.state().is_locked());

        // ロック後もキー取得はエラー
        assert!(provider.get_encryption_key().await.is_err());
    }
}
```

## 実装チェックリスト

- [ ] `EnvironmentInfo` 構造体実装
- [ ] `SimpleSaltConfig` 構造体実装
- [ ] `SimpleProvider` 構造体実装
- [ ] `SecurityProvider` trait実装
- [ ] キー生成ロジック実装
- [ ] ソルト永続化実装
- [ ] 自動初期化機能実装
- [ ] `Drop` trait実装（zeroize）
- [ ] ユニットテスト作成
- [ ] 統合テスト作成

---

**作成日**: 2025-11-24
**作成者**: Claude Code
