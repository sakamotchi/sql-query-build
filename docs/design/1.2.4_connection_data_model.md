# 1.2.4 接続情報データモデル設計書

## 概要

データベース接続情報を表現するデータ構造を定義します。複数のデータベース種別に対応し、環境別のテーマ設定を含む包括的なモデルを提供します。

## 目的

- データベース接続に必要な全情報を統一的に管理
- 複数データベース種別（PostgreSQL、MySQL、SQLite等）への対応
- 環境別テーマ・色設定の統合
- JSONシリアライズ可能な構造
- バリデーション機能の提供

## データモデル

### 接続情報エンティティ

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use uuid::Uuid;

/// データベース接続情報
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionInfo {
    /// 一意識別子
    pub id: String,

    /// 接続名（ユーザーが設定する表示名）
    pub name: String,

    /// データベース種別
    pub database_type: DatabaseType,

    /// 接続設定
    pub connection: ConnectionConfig,

    /// 環境設定
    pub environment: EnvironmentConfig,

    /// メタデータ
    pub metadata: ConnectionMetadata,
}

impl ConnectionInfo {
    /// 新しい接続情報を作成
    pub fn new(name: String, database_type: DatabaseType, connection: ConnectionConfig) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            name,
            database_type,
            connection,
            environment: EnvironmentConfig::default(),
            metadata: ConnectionMetadata::new(),
        }
    }

    /// 接続文字列を生成
    pub fn build_connection_string(&self, password: Option<&str>) -> Result<String, ConnectionError> {
        match &self.connection {
            ConnectionConfig::Network(config) => {
                config.to_connection_string(&self.database_type, password)
            }
            ConnectionConfig::File(config) => {
                config.to_connection_string()
            }
        }
    }

    /// 接続情報をバリデート
    pub fn validate(&self) -> Result<(), ConnectionError> {
        // 名前のバリデーション
        if self.name.trim().is_empty() {
            return Err(ConnectionError::InvalidName("接続名は必須です".to_string()));
        }

        // 接続設定のバリデーション
        self.connection.validate(&self.database_type)?;

        Ok(())
    }
}
```

### データベース種別

```rust
/// サポートするデータベース種別
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum DatabaseType {
    PostgreSQL,
    MySQL,
    SQLite,
    // 将来の拡張
    // MariaDB,
    // Oracle,
    // SqlServer,
}

impl DatabaseType {
    /// デフォルトポート番号を取得
    pub fn default_port(&self) -> Option<u16> {
        match self {
            Self::PostgreSQL => Some(5432),
            Self::MySQL => Some(3306),
            Self::SQLite => None,
        }
    }

    /// 表示名を取得
    pub fn display_name(&self) -> &'static str {
        match self {
            Self::PostgreSQL => "PostgreSQL",
            Self::MySQL => "MySQL",
            Self::SQLite => "SQLite",
        }
    }

    /// ファイルベースのデータベースかチェック
    pub fn is_file_based(&self) -> bool {
        matches!(self, Self::SQLite)
    }
}
```

### 接続設定

```rust
/// 接続設定（ネットワーク/ファイル）
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "lowercase")]
pub enum ConnectionConfig {
    /// ネットワーク経由の接続（PostgreSQL、MySQL等）
    Network(NetworkConfig),

    /// ファイルベースの接続（SQLite等）
    File(FileConfig),
}

impl ConnectionConfig {
    fn validate(&self, db_type: &DatabaseType) -> Result<(), ConnectionError> {
        match (self, db_type.is_file_based()) {
            (ConnectionConfig::Network(config), false) => config.validate(),
            (ConnectionConfig::File(config), true) => config.validate(),
            _ => Err(ConnectionError::InvalidConfig(
                "データベース種別と接続設定が一致しません".to_string(),
            )),
        }
    }
}

/// ネットワーク接続設定
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkConfig {
    /// ホスト名またはIPアドレス
    pub host: String,

    /// ポート番号
    pub port: u16,

    /// データベース名
    pub database: String,

    /// ユーザー名
    pub username: String,

    /// 暗号化されたパスワード（Base64エンコードされたEncryptedData）
    pub encrypted_password: Option<String>,

    /// SSL/TLS設定
    pub ssl_config: Option<SslConfig>,

    /// 追加のオプション（接続文字列パラメータ）
    pub options: Option<std::collections::HashMap<String, String>>,
}

impl NetworkConfig {
    fn validate(&self) -> Result<(), ConnectionError> {
        if self.host.trim().is_empty() {
            return Err(ConnectionError::InvalidHost);
        }

        if self.port == 0 {
            return Err(ConnectionError::InvalidPort);
        }

        if self.database.trim().is_empty() {
            return Err(ConnectionError::InvalidDatabase);
        }

        if self.username.trim().is_empty() {
            return Err(ConnectionError::InvalidUsername);
        }

        Ok(())
    }

    fn to_connection_string(
        &self,
        db_type: &DatabaseType,
        password: Option<&str>,
    ) -> Result<String, ConnectionError> {
        let pwd = password.unwrap_or("");

        let base = match db_type {
            DatabaseType::PostgreSQL => {
                format!(
                    "postgresql://{}:{}@{}:{}/{}",
                    self.username, pwd, self.host, self.port, self.database
                )
            }
            DatabaseType::MySQL => {
                format!(
                    "mysql://{}:{}@{}:{}/{}",
                    self.username, pwd, self.host, self.port, self.database
                )
            }
            _ => {
                return Err(ConnectionError::InvalidConfig(
                    "ネットワーク接続はこのデータベース種別には使用できません".to_string(),
                ))
            }
        };

        // SSL設定やオプションを追加
        let mut connection_string = base;
        if let Some(ssl) = &self.ssl_config {
            if ssl.enabled {
                connection_string.push_str("?sslmode=require");
            }
        }

        Ok(connection_string)
    }
}

/// SSL/TLS設定
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SslConfig {
    /// SSL/TLS有効化
    pub enabled: bool,

    /// CA証明書パス
    pub ca_cert_path: Option<String>,

    /// クライアント証明書パス
    pub client_cert_path: Option<String>,

    /// クライアント秘密鍵パス
    pub client_key_path: Option<String>,

    /// サーバー証明書の検証を行うか
    pub verify_server_cert: bool,
}

impl Default for SslConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            ca_cert_path: None,
            client_cert_path: None,
            client_key_path: None,
            verify_server_cert: true,
        }
    }
}

/// ファイルベース接続設定
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileConfig {
    /// ファイルパス
    pub file_path: String,

    /// 読み取り専用モード
    pub readonly: bool,
}

impl FileConfig {
    fn validate(&self) -> Result<(), ConnectionError> {
        if self.file_path.trim().is_empty() {
            return Err(ConnectionError::InvalidFilePath);
        }

        Ok(())
    }

    fn to_connection_string(&self) -> Result<String, ConnectionError> {
        let mut connection_string = format!("file:{}", self.file_path);

        if self.readonly {
            connection_string.push_str("?mode=ro");
        }

        Ok(connection_string)
    }
}
```

### 環境設定

```rust
/// 環境設定（テーマ・色）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnvironmentConfig {
    /// 環境種別
    pub environment_type: EnvironmentType,

    /// カスタムテーマカラー（Vuetifyカラー名またはHEXコード）
    pub theme_color: Option<String>,

    /// テーマの明るさ
    pub theme_variant: ThemeVariant,
}

impl Default for EnvironmentConfig {
    fn default() -> Self {
        Self {
            environment_type: EnvironmentType::Development,
            theme_color: None,
            theme_variant: ThemeVariant::Light,
        }
    }
}

impl EnvironmentConfig {
    /// 環境に応じたデフォルトカラーを取得
    pub fn default_color(&self) -> &'static str {
        self.environment_type.default_color()
    }

    /// 実際に使用する色を取得（カスタム色 or デフォルト）
    pub fn effective_color(&self) -> String {
        self.theme_color
            .clone()
            .unwrap_or_else(|| self.default_color().to_string())
    }
}

/// 環境種別
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum EnvironmentType {
    Development,
    Staging,
    Testing,
    Production,
}

impl EnvironmentType {
    /// 環境のデフォルトカラーを取得
    pub fn default_color(&self) -> &'static str {
        match self {
            Self::Development => "blue",
            Self::Staging => "orange",
            Self::Testing => "purple",
            Self::Production => "red",
        }
    }

    /// 環境の表示名を取得
    pub fn display_name(&self) -> &'static str {
        match self {
            Self::Development => "開発環境",
            Self::Staging => "ステージング環境",
            Self::Testing => "テスト環境",
            Self::Production => "本番環境",
        }
    }

    /// 本番環境かチェック
    pub fn is_production(&self) -> bool {
        matches!(self, Self::Production)
    }
}

/// テーマの明るさ
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ThemeVariant {
    Light,
    Dark,
}
```

### メタデータ

```rust
/// 接続情報のメタデータ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionMetadata {
    /// 作成日時
    pub created_at: DateTime<Utc>,

    /// 最終更新日時
    pub updated_at: DateTime<Utc>,

    /// 最終接続日時
    pub last_connected_at: Option<DateTime<Utc>>,

    /// 接続回数
    pub connection_count: u64,

    /// タグ（分類・検索用）
    pub tags: Vec<String>,

    /// メモ
    pub note: Option<String>,

    /// お気に入りフラグ
    pub is_favorite: bool,
}

impl ConnectionMetadata {
    fn new() -> Self {
        let now = Utc::now();
        Self {
            created_at: now,
            updated_at: now,
            last_connected_at: None,
            connection_count: 0,
            tags: Vec::new(),
            note: None,
            is_favorite: false,
        }
    }

    /// 接続成功時に呼び出す
    pub fn record_connection(&mut self) {
        self.last_connected_at = Some(Utc::now());
        self.connection_count += 1;
    }

    /// 更新時刻を更新
    pub fn touch(&mut self) {
        self.updated_at = Utc::now();
    }
}
```

## 接続情報コレクション

```rust
/// 接続情報のコレクション
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionCollection {
    /// バージョン（将来のマイグレーション用）
    pub version: u32,

    /// 接続情報のリスト
    pub connections: Vec<ConnectionInfo>,
}

impl ConnectionCollection {
    /// 新しいコレクションを作成
    pub fn new() -> Self {
        Self {
            version: 1,
            connections: Vec::new(),
        }
    }

    /// 接続情報を追加
    pub fn add(&mut self, connection: ConnectionInfo) -> Result<(), ConnectionError> {
        // 同じ名前の接続が既に存在しないかチェック
        if self.connections.iter().any(|c| c.name == connection.name) {
            return Err(ConnectionError::DuplicateName);
        }

        connection.validate()?;
        self.connections.push(connection);
        Ok(())
    }

    /// IDで接続情報を取得
    pub fn get(&self, id: &str) -> Option<&ConnectionInfo> {
        self.connections.iter().find(|c| c.id == id)
    }

    /// IDで接続情報を取得（可変参照）
    pub fn get_mut(&mut self, id: &str) -> Option<&mut ConnectionInfo> {
        self.connections.iter_mut().find(|c| c.id == id)
    }

    /// 接続情報を更新
    pub fn update(&mut self, id: &str, connection: ConnectionInfo) -> Result<(), ConnectionError> {
        connection.validate()?;

        let index = self
            .connections
            .iter()
            .position(|c| c.id == id)
            .ok_or(ConnectionError::NotFound)?;

        self.connections[index] = connection;
        self.connections[index].metadata.touch();

        Ok(())
    }

    /// 接続情報を削除
    pub fn remove(&mut self, id: &str) -> Result<ConnectionInfo, ConnectionError> {
        let index = self
            .connections
            .iter()
            .position(|c| c.id == id)
            .ok_or(ConnectionError::NotFound)?;

        Ok(self.connections.remove(index))
    }

    /// タグで検索
    pub fn find_by_tag(&self, tag: &str) -> Vec<&ConnectionInfo> {
        self.connections
            .iter()
            .filter(|c| c.metadata.tags.contains(&tag.to_string()))
            .collect()
    }

    /// 環境種別で検索
    pub fn find_by_environment(&self, env_type: EnvironmentType) -> Vec<&ConnectionInfo> {
        self.connections
            .iter()
            .filter(|c| c.environment.environment_type == env_type)
            .collect()
    }

    /// お気に入りのみ取得
    pub fn favorites(&self) -> Vec<&ConnectionInfo> {
        self.connections
            .iter()
            .filter(|c| c.metadata.is_favorite)
            .collect()
    }

    /// 最近使用した順にソート
    pub fn sorted_by_recent(&self) -> Vec<&ConnectionInfo> {
        let mut sorted = self.connections.iter().collect::<Vec<_>>();
        sorted.sort_by(|a, b| {
            b.metadata
                .last_connected_at
                .cmp(&a.metadata.last_connected_at)
        });
        sorted
    }
}
```

## エラー型定義

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ConnectionError {
    #[error("接続名が無効です: {0}")]
    InvalidName(String),

    #[error("ホスト名が無効です")]
    InvalidHost,

    #[error("ポート番号が無効です")]
    InvalidPort,

    #[error("データベース名が無効です")]
    InvalidDatabase,

    #[error("ユーザー名が無効です")]
    InvalidUsername,

    #[error("ファイルパスが無効です")]
    InvalidFilePath,

    #[error("接続設定が無効です: {0}")]
    InvalidConfig(String),

    #[error("同じ名前の接続が既に存在します")]
    DuplicateName,

    #[error("接続情報が見つかりません")]
    NotFound,
}
```

## JSON構造例

### PostgreSQL接続の例

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "本番DB（PostgreSQL）",
  "database_type": "postgresql",
  "connection": {
    "type": "network",
    "host": "db.example.com",
    "port": 5432,
    "database": "production_db",
    "username": "app_user",
    "encrypted_password": "eyJ2ZXJzaW9uIjoxLCJub25jZSI6WzEyMywxMjMsLi4uXX0=",
    "ssl_config": {
      "enabled": true,
      "ca_cert_path": null,
      "client_cert_path": null,
      "client_key_path": null,
      "verify_server_cert": true
    },
    "options": null
  },
  "environment": {
    "environment_type": "production",
    "theme_color": null,
    "theme_variant": "light"
  },
  "metadata": {
    "created_at": "2025-01-15T10:30:00Z",
    "updated_at": "2025-01-20T14:22:00Z",
    "last_connected_at": "2025-01-20T14:22:00Z",
    "connection_count": 42,
    "tags": ["production", "main"],
    "note": "本番環境のメインデータベース",
    "is_favorite": true
  }
}
```

### SQLite接続の例

```json
{
  "id": "660e8400-e29b-41d4-a716-446655440001",
  "name": "開発用ローカルDB",
  "database_type": "sqlite",
  "connection": {
    "type": "file",
    "file_path": "/Users/username/projects/myapp/dev.db",
    "readonly": false
  },
  "environment": {
    "environment_type": "development",
    "theme_color": "teal",
    "theme_variant": "dark"
  },
  "metadata": {
    "created_at": "2025-01-10T09:00:00Z",
    "updated_at": "2025-01-10T09:00:00Z",
    "last_connected_at": null,
    "connection_count": 0,
    "tags": ["local", "dev"],
    "note": null,
    "is_favorite": false
  }
}
```

### コレクションの例

```json
{
  "version": 1,
  "connections": [
    { /* 接続情報1 */ },
    { /* 接続情報2 */ }
  ]
}
```

## 必要な依存関係

```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
thiserror = "1.0"
```

## ヘルパー関数

### ビルダーパターン

```rust
/// 接続情報ビルダー
pub struct ConnectionInfoBuilder {
    name: String,
    database_type: DatabaseType,
    connection: Option<ConnectionConfig>,
    environment: EnvironmentConfig,
}

impl ConnectionInfoBuilder {
    pub fn new(name: impl Into<String>, database_type: DatabaseType) -> Self {
        Self {
            name: name.into(),
            database_type,
            connection: None,
            environment: EnvironmentConfig::default(),
        }
    }

    pub fn network(
        mut self,
        host: impl Into<String>,
        port: u16,
        database: impl Into<String>,
        username: impl Into<String>,
    ) -> Self {
        self.connection = Some(ConnectionConfig::Network(NetworkConfig {
            host: host.into(),
            port,
            database: database.into(),
            username: username.into(),
            encrypted_password: None,
            ssl_config: None,
            options: None,
        }));
        self
    }

    pub fn file(mut self, file_path: impl Into<String>) -> Self {
        self.connection = Some(ConnectionConfig::File(FileConfig {
            file_path: file_path.into(),
            readonly: false,
        }));
        self
    }

    pub fn environment(mut self, env_type: EnvironmentType) -> Self {
        self.environment.environment_type = env_type;
        self
    }

    pub fn theme_color(mut self, color: impl Into<String>) -> Self {
        self.environment.theme_color = Some(color.into());
        self
    }

    pub fn build(self) -> Result<ConnectionInfo, ConnectionError> {
        let connection = self
            .connection
            .ok_or_else(|| ConnectionError::InvalidConfig("接続設定が未設定です".to_string()))?;

        let info = ConnectionInfo::new(self.name, self.database_type, connection);
        info.validate()?;

        Ok(info)
    }
}
```

## 完了条件

- [x] 設計書作成完了
- [ ] データモデルがRustコードとして実装される
- [ ] JSONシリアライズ/デシリアライズが動作する
- [ ] バリデーション機能が正常に動作する
- [ ] 接続文字列生成が正常に動作する
- [ ] コレクション操作が正常に動作する
- [ ] ユニットテストが全てパスする

## 参考資料

- [serde](https://serde.rs/)
- [uuid crate](https://docs.rs/uuid/)
- [chrono crate](https://docs.rs/chrono/)
- [PostgreSQL Connection Strings](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING)
- [MySQL Connection Strings](https://dev.mysql.com/doc/refman/8.0/en/connecting-using-uri-or-key-value-pairs.html)
