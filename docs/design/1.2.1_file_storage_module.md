# 1.2.1 ファイルストレージモジュール設計書

## 概要

接続情報、クエリ履歴、保存済みクエリなどのデータをJSONファイルとして永続化するためのストレージモジュールを実装します。

## 目的

- デスクトップアプリケーションとしてのデータ永続化基盤を提供
- Rust側で安全にファイル操作を行う
- 将来的な拡張性を考慮した設計

## アーキテクチャ

### モジュール構成

```
src-tauri/src/
├── storage/
│   ├── mod.rs              # ストレージモジュールのエントリポイント
│   ├── file_storage.rs     # ファイルストレージの実装
│   ├── error.rs            # エラー型定義
│   └── path_manager.rs     # アプリケーションデータディレクトリ管理
```

### 責務

1. **ファイルストレージ (`file_storage.rs`)**
   - JSONファイルの読み書き
   - ファイルロック管理
   - データの整合性保証

2. **パスマネージャー (`path_manager.rs`)**
   - OS別のアプリケーションデータディレクトリ管理
   - ファイルパスの解決
   - ディレクトリの初期化

3. **エラー管理 (`error.rs`)**
   - ストレージ関連エラーの定義
   - エラーハンドリング

## データストレージ構造

### ディレクトリ構造

```
<アプリケーションデータディレクトリ>/
├── connections/
│   └── connections.json         # 接続情報
├── queries/
│   ├── saved/                   # 保存済みクエリ
│   │   └── {query_id}.json
│   └── history/                 # クエリ履歴
│       └── {date}/
│           └── history.json
├── settings/
│   └── app_settings.json        # アプリケーション設定
└── logs/
    └── audit/                   # 監査ログ
        └── {date}/
            └── audit.json
```

### OS別アプリケーションデータディレクトリ

| OS | パス |
|----|------|
| Windows | `%APPDATA%\sql-query-builder\` |
| macOS | `~/Library/Application Support/sql-query-builder/` |
| Linux | `~/.local/share/sql-query-builder/` |

## データモデル

### ストレージトレイト

```rust
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use crate::storage::error::StorageResult;

/// ジェネリックなストレージ操作を定義するトレイト
pub trait Storage<T>
where
    T: Serialize + for<'de> Deserialize<'de>,
{
    /// データを読み込む
    fn read(&self, key: &str) -> StorageResult<T>;

    /// データを書き込む
    fn write(&self, key: &str, data: &T) -> StorageResult<()>;

    /// データを削除する
    fn delete(&self, key: &str) -> StorageResult<()>;

    /// 全てのキーを取得する
    fn list_keys(&self) -> StorageResult<Vec<String>>;

    /// データが存在するかチェック
    fn exists(&self, key: &str) -> bool;
}
```

### FileStorage実装

```rust
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;
use std::sync::RwLock;

pub struct FileStorage {
    base_path: PathBuf,
    // ファイルアクセスの排他制御用
    lock: RwLock<()>,
}

impl FileStorage {
    /// 新しいFileStorageインスタンスを作成
    pub fn new(base_path: PathBuf) -> StorageResult<Self> {
        // ベースディレクトリが存在しない場合は作成
        if !base_path.exists() {
            fs::create_dir_all(&base_path)?;
        }

        Ok(Self {
            base_path,
            lock: RwLock::new(()),
        })
    }

    /// キーからファイルパスを解決
    fn resolve_path(&self, key: &str) -> PathBuf {
        self.base_path.join(format!("{}.json", key))
    }

    /// JSON形式でファイルに書き込む
    fn write_json<T: Serialize>(&self, path: &PathBuf, data: &T) -> StorageResult<()> {
        let _guard = self.lock.write()?;

        // 親ディレクトリが存在しない場合は作成
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }

        let json = serde_json::to_string_pretty(data)?;
        fs::write(path, json)?;

        Ok(())
    }

    /// JSON形式でファイルから読み込む
    fn read_json<T: for<'de> Deserialize<'de>>(&self, path: &PathBuf) -> StorageResult<T> {
        let _guard = self.lock.read()?;

        let content = fs::read_to_string(path)?;
        let data = serde_json::from_str(&content)?;

        Ok(data)
    }
}
```

### PathManager実装

```rust
use std::path::PathBuf;
use directories::ProjectDirs;

pub struct PathManager {
    project_dirs: ProjectDirs,
}

impl PathManager {
    /// 新しいPathManagerインスタンスを作成
    pub fn new() -> Option<Self> {
        ProjectDirs::from("com", "sqlquerybuilder", "sql-query-builder")
            .map(|project_dirs| Self { project_dirs })
    }

    /// データディレクトリのパスを取得
    pub fn data_dir(&self) -> PathBuf {
        self.project_dirs.data_dir().to_path_buf()
    }

    /// 接続情報ディレクトリのパスを取得
    pub fn connections_dir(&self) -> PathBuf {
        self.data_dir().join("connections")
    }

    /// クエリディレクトリのパスを取得
    pub fn queries_dir(&self) -> PathBuf {
        self.data_dir().join("queries")
    }

    /// 保存済みクエリディレクトリのパスを取得
    pub fn saved_queries_dir(&self) -> PathBuf {
        self.queries_dir().join("saved")
    }

    /// クエリ履歴ディレクトリのパスを取得
    pub fn history_dir(&self) -> PathBuf {
        self.queries_dir().join("history")
    }

    /// 設定ディレクトリのパスを取得
    pub fn settings_dir(&self) -> PathBuf {
        self.data_dir().join("settings")
    }

    /// ログディレクトリのパスを取得
    pub fn logs_dir(&self) -> PathBuf {
        self.data_dir().join("logs")
    }

    /// 監査ログディレクトリのパスを取得
    pub fn audit_logs_dir(&self) -> PathBuf {
        self.logs_dir().join("audit")
    }

    /// 全ての必要なディレクトリを初期化
    pub fn initialize_directories(&self) -> std::io::Result<()> {
        let dirs = vec![
            self.connections_dir(),
            self.saved_queries_dir(),
            self.history_dir(),
            self.settings_dir(),
            self.audit_logs_dir(),
        ];

        for dir in dirs {
            std::fs::create_dir_all(dir)?;
        }

        Ok(())
    }
}
```

### エラー型定義

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum StorageError {
    #[error("ファイル操作エラー: {0}")]
    IoError(#[from] std::io::Error),

    #[error("JSON変換エラー: {0}")]
    SerializationError(#[from] serde_json::Error),

    #[error("ロック取得エラー")]
    LockError,

    #[error("データが見つかりません: {0}")]
    NotFound(String),

    #[error("データが既に存在します: {0}")]
    AlreadyExists(String),

    #[error("パスマネージャーの初期化に失敗しました")]
    PathManagerInitError,
}

pub type StorageResult<T> = Result<T, StorageError>;

// RwLock poisonエラーの変換
impl<T> From<std::sync::PoisonError<T>> for StorageError {
    fn from(_: std::sync::PoisonError<T>) -> Self {
        StorageError::LockError
    }
}
```

## 必要な依存関係

```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"
directories = "5.0"  # OS別のディレクトリパス取得
```

## API設計

### Tauriコマンド

```rust
use tauri::State;
use crate::storage::FileStorage;

#[tauri::command]
pub async fn storage_write(
    key: String,
    data: serde_json::Value,
    storage: State<'_, FileStorage>,
) -> Result<(), String> {
    storage
        .write(&key, &data)
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn storage_read(
    key: String,
    storage: State<'_, FileStorage>,
) -> Result<serde_json::Value, String> {
    storage
        .read(&key)
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn storage_delete(
    key: String,
    storage: State<'_, FileStorage>,
) -> Result<(), String> {
    storage
        .delete(&key)
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn storage_list_keys(
    storage: State<'_, FileStorage>,
) -> Result<Vec<String>, String> {
    storage
        .list_keys()
        .map_err(|e| e.to_string())
}
```

## セキュリティ考慮事項

1. **ファイルパーミッション**
   - ファイル作成時に適切なパーミッション設定（600: 所有者のみ読み書き可能）
   - ディレクトリは700（所有者のみアクセス可能）

2. **パストラバーサル対策**
   - キーのバリデーション
   - `../` などの危険な文字列の拒否

3. **排他制御**
   - RwLockによる読み書きの排他制御
   - 複数プロセスからのアクセスは初期バージョンでは非対応

## パフォーマンス考慮事項

1. **ファイルサイズ管理**
   - 大きなファイルは分割して保存
   - 履歴データは日付ごとに分割

2. **キャッシング**
   - 頻繁に読み込むデータはメモリキャッシュ
   - 変更検知による無効化

3. **非同期I/O**
   - Tokioの非同期ファイルI/Oを活用（必要に応じて）

## テスト方針

### ユニットテスト

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use serde::{Deserialize, Serialize};

    #[derive(Serialize, Deserialize, PartialEq, Debug)]
    struct TestData {
        name: String,
        value: i32,
    }

    #[test]
    fn test_write_and_read() {
        let temp_dir = TempDir::new().unwrap();
        let storage = FileStorage::new(temp_dir.path().to_path_buf()).unwrap();

        let data = TestData {
            name: "test".to_string(),
            value: 42,
        };

        storage.write("test_key", &data).unwrap();
        let read_data: TestData = storage.read("test_key").unwrap();

        assert_eq!(data, read_data);
    }

    #[test]
    fn test_delete() {
        let temp_dir = TempDir::new().unwrap();
        let storage = FileStorage::new(temp_dir.path().to_path_buf()).unwrap();

        let data = TestData {
            name: "test".to_string(),
            value: 42,
        };

        storage.write("test_key", &data).unwrap();
        assert!(storage.exists("test_key"));

        storage.delete("test_key").unwrap();
        assert!(!storage.exists("test_key"));
    }

    #[test]
    fn test_list_keys() {
        let temp_dir = TempDir::new().unwrap();
        let storage = FileStorage::new(temp_dir.path().to_path_buf()).unwrap();

        let data = TestData {
            name: "test".to_string(),
            value: 42,
        };

        storage.write("key1", &data).unwrap();
        storage.write("key2", &data).unwrap();

        let keys = storage.list_keys().unwrap();
        assert_eq!(keys.len(), 2);
        assert!(keys.contains(&"key1".to_string()));
        assert!(keys.contains(&"key2".to_string()));
    }
}
```

### テストに必要な依存関係

```toml
[dev-dependencies]
tempfile = "3.0"  # 一時ディレクトリ作成
```

## マイグレーション戦略

将来的なデータ構造の変更に対応するため：

1. **バージョニング**
   - 各JSONファイルにバージョン番号を含める
   - バージョンに応じた読み込み処理

2. **マイグレーション関数**
   - 旧バージョンから新バージョンへの変換処理
   - アプリケーション起動時に自動実行

```rust
#[derive(Serialize, Deserialize)]
struct VersionedData<T> {
    version: u32,
    data: T,
}
```

## 実装優先順位

1. **Phase 1（必須）**
   - PathManager実装
   - FileStorage基本機能（read/write/delete）
   - エラーハンドリング
   - ディレクトリ初期化

2. **Phase 2（推奨）**
   - list_keys実装
   - ファイルロック機構
   - バリデーション強化

3. **Phase 3（オプション）**
   - キャッシング機能
   - マイグレーション機構
   - 非同期I/O最適化

## 完了条件

- [x] 設計書作成完了
- [x] PathManagerが全OSで正しいディレクトリパスを返す
- [x] FileStorageがJSONの読み書き削除を正常に実行できる
- [x] ユニットテストが全てパスする
- [x] エラーハンドリングが適切に機能する
- [x] ディレクトリ初期化が正常に動作する

## 参考資料

- [directories crate](https://docs.rs/directories/)
- [serde_json](https://docs.rs/serde_json/)
- [Tauri Storage Plugin](https://github.com/tauri-apps/tauri-plugin-store)
