# タスク1.3.7: 接続テスト機能実装 設計書

## 概要

**タスクID**: 1.3.7
**タスク名**: 接続テスト機能実装
**工数**: 1日
**依存関係**: 1.3.6 (Tauri IPC通信実装)
**完了条件**: DB接続確認が可能

---

## 目的

データベース接続設定が正しいことを検証するテスト機能を実装する。接続成功/失敗の判定、サーバー情報の取得、エラーの詳細表示を提供する。

---

## 機能要件

### 基本機能
1. **接続テスト実行**: 設定された接続情報でデータベースに接続を試行
2. **タイムアウト設定**: 指定時間内に接続できない場合はタイムアウト
3. **結果表示**: 成功/失敗の判定と詳細情報を表示
4. **サーバー情報取得**: 成功時にデータベースのバージョン情報を取得

### 検証項目
- [ ] ホスト名の到達可能性
- [ ] ポート番号の接続可能性
- [ ] 認証情報の正当性
- [ ] データベース名の存在確認
- [ ] SSL接続の検証 (有効時)

---

## バックエンド実装

### データベース接続テストサービス

**ファイル**: `src-tauri/src/services/connection_test_service.rs`

```rust
use std::time::{Duration, Instant};
use anyhow::{Context, Result};
use tokio::time::timeout;
use crate::models::connection::{Connection, DatabaseType};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TestConnectionResult {
    pub success: bool,
    pub message: String,
    pub duration: Option<u64>, // ミリ秒
    pub server_version: Option<String>,
    pub server_info: Option<ServerInfo>,
    pub error_details: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ServerInfo {
    pub version: String,
    pub database_name: String,
    pub current_user: String,
    pub encoding: Option<String>,
}

pub struct ConnectionTestService;

impl ConnectionTestService {
    /// 接続をテスト
    pub async fn test_connection(connection: &Connection) -> Result<TestConnectionResult> {
        let start = Instant::now();
        let timeout_duration = Duration::from_secs(connection.timeout.unwrap_or(30) as u64);

        // タイムアウト付きで接続テストを実行
        let result = timeout(
            timeout_duration,
            Self::execute_test(connection),
        ).await;

        let duration = start.elapsed().as_millis() as u64;

        match result {
            Ok(Ok(server_info)) => Ok(TestConnectionResult {
                success: true,
                message: format!("接続に成功しました ({} ms)", duration),
                duration: Some(duration),
                server_version: Some(server_info.version.clone()),
                server_info: Some(server_info),
                error_details: None,
            }),
            Ok(Err(e)) => Ok(TestConnectionResult {
                success: false,
                message: "接続に失敗しました".to_string(),
                duration: Some(duration),
                server_version: None,
                server_info: None,
                error_details: Some(e.to_string()),
            }),
            Err(_) => Ok(TestConnectionResult {
                success: false,
                message: format!("接続がタイムアウトしました ({} 秒)", timeout_duration.as_secs()),
                duration: Some(duration),
                server_version: None,
                server_info: None,
                error_details: Some("Connection timeout".to_string()),
            }),
        }
    }

    /// 実際の接続テストを実行
    async fn execute_test(connection: &Connection) -> Result<ServerInfo> {
        match connection.db_type {
            DatabaseType::PostgreSQL => Self::test_postgresql(connection).await,
            DatabaseType::MySQL => Self::test_mysql(connection).await,
            DatabaseType::SQLite => Self::test_sqlite(connection).await,
        }
    }

    /// PostgreSQL接続テスト
    async fn test_postgresql(connection: &Connection) -> Result<ServerInfo> {
        use sqlx::postgres::{PgConnectOptions, PgPool};
        use std::str::FromStr;

        let mut options = PgConnectOptions::new()
            .host(&connection.host)
            .port(connection.port)
            .database(&connection.database)
            .username(&connection.username);

        if let Some(password) = &connection.password {
            options = options.password(password);
        }

        if connection.ssl {
            options = options.ssl_mode(sqlx::postgres::PgSslMode::Require);
        }

        let pool = PgPool::connect_with(options).await
            .context("Failed to connect to PostgreSQL")?;

        // サーバー情報を取得
        let version_query = sqlx::query_scalar::<_, String>("SELECT version()")
            .fetch_one(&pool)
            .await?;

        let current_user = sqlx::query_scalar::<_, String>("SELECT current_user")
            .fetch_one(&pool)
            .await?;

        let database_name = sqlx::query_scalar::<_, String>("SELECT current_database()")
            .fetch_one(&pool)
            .await?;

        let encoding = sqlx::query_scalar::<_, String>(
            "SELECT pg_encoding_to_char(encoding) FROM pg_database WHERE datname = current_database()"
        )
        .fetch_one(&pool)
        .await
        .ok();

        pool.close().await;

        Ok(ServerInfo {
            version: version_query,
            database_name,
            current_user,
            encoding,
        })
    }

    /// MySQL接続テスト
    async fn test_mysql(connection: &Connection) -> Result<ServerInfo> {
        use sqlx::mysql::{MySqlConnectOptions, MySqlPool};

        let mut options = MySqlConnectOptions::new()
            .host(&connection.host)
            .port(connection.port)
            .database(&connection.database)
            .username(&connection.username);

        if let Some(password) = &connection.password {
            options = options.password(password);
        }

        if connection.ssl {
            options = options.ssl_mode(sqlx::mysql::MySqlSslMode::Required);
        }

        let pool = MySqlPool::connect_with(options).await
            .context("Failed to connect to MySQL")?;

        // サーバー情報を取得
        let version_query = sqlx::query_scalar::<_, String>("SELECT VERSION()")
            .fetch_one(&pool)
            .await?;

        let current_user = sqlx::query_scalar::<_, String>("SELECT USER()")
            .fetch_one(&pool)
            .await?;

        let database_name = sqlx::query_scalar::<_, String>("SELECT DATABASE()")
            .fetch_one(&pool)
            .await?;

        pool.close().await;

        Ok(ServerInfo {
            version: version_query,
            database_name,
            current_user,
            encoding: None,
        })
    }

    /// SQLite接続テスト
    async fn test_sqlite(connection: &Connection) -> Result<ServerInfo> {
        use sqlx::sqlite::{SqliteConnectOptions, SqlitePool};
        use std::str::FromStr;

        let options = SqliteConnectOptions::from_str(&connection.database)?;

        let pool = SqlitePool::connect_with(options).await
            .context("Failed to connect to SQLite")?;

        // サーバー情報を取得
        let version_query = sqlx::query_scalar::<_, String>("SELECT sqlite_version()")
            .fetch_one(&pool)
            .await?;

        pool.close().await;

        Ok(ServerInfo {
            version: format!("SQLite {}", version_query),
            database_name: connection.database.clone(),
            current_user: "local".to_string(),
            encoding: Some("UTF-8".to_string()),
        })
    }
}
```

---

### Tauriコマンド

**ファイル**: `src-tauri/src/commands/connection.rs` (追加)

```rust
use crate::services::connection_test_service::{ConnectionTestService, TestConnectionResult};

/// 接続をテスト
#[tauri::command]
pub async fn test_connection(
    connection: Connection,
) -> Result<TestConnectionResult, String> {
    ConnectionTestService::test_connection(&connection)
        .await
        .map_err(|e| format!("Connection test failed: {}", e))
}
```

---

## フロントエンド実装

### API ラッパー

**ファイル**: `src/api/connection.ts` (追加)

```typescript
export interface TestConnectionResult {
  success: boolean;
  message: string;
  duration?: number;
  serverVersion?: string;
  serverInfo?: ServerInfo;
  errorDetails?: string;
}

export interface ServerInfo {
  version: string;
  databaseName: string;
  currentUser: string;
  encoding?: string;
}

/**
 * 接続をテスト
 */
static async testConnection(connection: Partial<Connection>): Promise<TestConnectionResult> {
  try {
    return await invoke<TestConnectionResult>('test_connection', {
      connection,
    });
  } catch (error) {
    throw new Error(`接続テストに失敗しました: ${error}`);
  }
}
```

---

### 接続テストコンポーネント

**ファイル**: `src/components/connection/ConnectionTestDialog.vue`

```vue
<template>
  <v-dialog v-model="dialog" max-width="600px" persistent>
    <v-card>
      <v-card-title class="text-h5">
        <v-icon class="mr-2">mdi-connection</v-icon>
        接続テスト
      </v-card-title>

      <v-divider></v-divider>

      <v-card-text class="pa-6">
        <!-- テスト中 -->
        <div v-if="testing" class="text-center py-8">
          <v-progress-circular
            indeterminate
            color="primary"
            size="64"
          ></v-progress-circular>
          <div class="text-h6 mt-4">接続を確認中...</div>
          <div class="text-caption text-grey mt-2">
            {{ connection.host }}:{{ connection.port }}
          </div>
        </div>

        <!-- テスト結果 -->
        <div v-else-if="result">
          <!-- 成功 -->
          <v-alert
            v-if="result.success"
            type="success"
            variant="tonal"
            prominent
          >
            <div class="d-flex align-center">
              <v-icon size="large" class="mr-3">mdi-check-circle</v-icon>
              <div>
                <div class="text-h6">接続成功</div>
                <div class="text-body-2 mt-1">{{ result.message }}</div>
              </div>
            </div>
          </v-alert>

          <!-- 失敗 -->
          <v-alert
            v-else
            type="error"
            variant="tonal"
            prominent
          >
            <div class="d-flex align-center">
              <v-icon size="large" class="mr-3">mdi-alert-circle</v-icon>
              <div>
                <div class="text-h6">接続失敗</div>
                <div class="text-body-2 mt-1">{{ result.message }}</div>
              </div>
            </div>
          </v-alert>

          <!-- サーバー情報 (成功時のみ) -->
          <v-card v-if="result.success && result.serverInfo" variant="outlined" class="mt-4">
            <v-card-title class="text-subtitle-1">
              <v-icon class="mr-2">mdi-server</v-icon>
              サーバー情報
            </v-card-title>
            <v-card-text>
              <v-list density="compact">
                <v-list-item>
                  <template v-slot:prepend>
                    <v-icon>mdi-information</v-icon>
                  </template>
                  <v-list-item-title>バージョン</v-list-item-title>
                  <v-list-item-subtitle>{{ result.serverInfo.version }}</v-list-item-subtitle>
                </v-list-item>

                <v-list-item>
                  <template v-slot:prepend>
                    <v-icon>mdi-database</v-icon>
                  </template>
                  <v-list-item-title>データベース</v-list-item-title>
                  <v-list-item-subtitle>{{ result.serverInfo.databaseName }}</v-list-item-subtitle>
                </v-list-item>

                <v-list-item>
                  <template v-slot:prepend>
                    <v-icon>mdi-account</v-icon>
                  </template>
                  <v-list-item-title>ユーザー</v-list-item-title>
                  <v-list-item-subtitle>{{ result.serverInfo.currentUser }}</v-list-item-subtitle>
                </v-list-item>

                <v-list-item v-if="result.serverInfo.encoding">
                  <template v-slot:prepend>
                    <v-icon>mdi-text</v-icon>
                  </template>
                  <v-list-item-title>エンコーディング</v-list-item-title>
                  <v-list-item-subtitle>{{ result.serverInfo.encoding }}</v-list-item-subtitle>
                </v-list-item>

                <v-list-item v-if="result.duration">
                  <template v-slot:prepend>
                    <v-icon>mdi-clock-outline</v-icon>
                  </template>
                  <v-list-item-title>応答時間</v-list-item-title>
                  <v-list-item-subtitle>{{ result.duration }} ms</v-list-item-subtitle>
                </v-list-item>
              </v-list>
            </v-card-text>
          </v-card>

          <!-- エラー詳細 (失敗時のみ) -->
          <v-expansion-panels v-if="!result.success && result.errorDetails" class="mt-4">
            <v-expansion-panel>
              <v-expansion-panel-title>
                <v-icon class="mr-2">mdi-alert-circle-outline</v-icon>
                エラー詳細
              </v-expansion-panel-title>
              <v-expansion-panel-text>
                <pre class="error-details">{{ result.errorDetails }}</pre>
              </v-expansion-panel-text>
            </v-expansion-panel>
          </v-expansion-panels>

          <!-- トラブルシューティング (失敗時のみ) -->
          <v-card v-if="!result.success" variant="outlined" class="mt-4">
            <v-card-title class="text-subtitle-1">
              <v-icon class="mr-2">mdi-lifebuoy</v-icon>
              トラブルシューティング
            </v-card-title>
            <v-card-text>
              <ul class="troubleshooting-list">
                <li>ホスト名とポート番号が正しいか確認してください</li>
                <li>ユーザー名とパスワードが正しいか確認してください</li>
                <li>データベース名が存在するか確認してください</li>
                <li>ファイアウォールで接続がブロックされていないか確認してください</li>
                <li>データベースサーバーが起動しているか確認してください</li>
              </ul>
            </v-card-text>
          </v-card>
        </div>
      </v-card-text>

      <v-divider></v-divider>

      <v-card-actions>
        <v-spacer></v-spacer>
        <v-btn
          v-if="!testing"
          variant="text"
          @click="handleClose"
        >
          閉じる
        </v-btn>
        <v-btn
          v-if="result && !result.success"
          color="primary"
          variant="flat"
          @click="handleRetry"
        >
          再試行
        </v-btn>
      </v-card-actions>
    </v-card>
  </v-dialog>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { ConnectionAPI, type TestConnectionResult } from '@/api/connection';
import type { Connection } from '@/stores/types';

const props = defineProps<{
  connection: Partial<Connection>;
}>();

const emit = defineEmits<{
  close: [];
}>();

const dialog = ref(true);
const testing = ref(false);
const result = ref<TestConnectionResult | null>(null);

// 接続テストを実行
const runTest = async () => {
  testing.value = true;
  result.value = null;

  try {
    result.value = await ConnectionAPI.testConnection(props.connection);
  } catch (error) {
    result.value = {
      success: false,
      message: '接続テストに失敗しました',
      errorDetails: String(error),
    };
  } finally {
    testing.value = false;
  }
};

// 再試行
const handleRetry = () => {
  runTest();
};

// 閉じる
const handleClose = () => {
  dialog.value = false;
  emit('close');
};

// マウント時にテストを実行
runTest();
</script>

<style scoped lang="scss">
.error-details {
  background-color: rgba(0, 0, 0, 0.05);
  padding: 12px;
  border-radius: 4px;
  font-size: 12px;
  overflow-x: auto;
  white-space: pre-wrap;
  word-break: break-all;
}

.troubleshooting-list {
  list-style-position: inside;
  padding-left: 0;

  li {
    margin-bottom: 8px;
  }
}
</style>
```

---

### 接続フォームでの使用

```vue
<script setup lang="ts">
import { ref } from 'vue';
import ConnectionTestDialog from '@/components/connection/ConnectionTestDialog.vue';

const showTestDialog = ref(false);

const handleTestConnection = () => {
  showTestDialog.value = true;
};
</script>

<template>
  <v-btn
    color="primary"
    variant="outlined"
    prepend-icon="mdi-connection"
    @click="handleTestConnection"
  >
    接続テスト
  </v-btn>

  <ConnectionTestDialog
    v-if="showTestDialog"
    :connection="formData"
    @close="showTestDialog = false"
  />
</template>
```

---

## 依存関係

### Cargo.toml

```toml
[dependencies]
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "postgres", "mysql", "sqlite"] }
tokio = { version = "1.0", features = ["full"] }
anyhow = "1.0"
```

---

## テスト

### ユニットテスト

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_postgresql_connection() {
        let connection = Connection {
            host: "localhost".to_string(),
            port: 5432,
            database: "postgres".to_string(),
            username: "postgres".to_string(),
            password: Some("password".to_string()),
            db_type: DatabaseType::PostgreSQL,
            ssl: false,
            timeout: Some(30),
            // ... 他のフィールド
        };

        let result = ConnectionTestService::test_connection(&connection).await;
        assert!(result.is_ok());
    }
}
```

---

## エラーハンドリング

### よくあるエラーと対処法

| エラー | 原因 | 対処法 |
|--------|------|--------|
| Connection refused | サーバーが起動していない | データベースサーバーを起動 |
| Authentication failed | 認証情報が間違っている | ユーザー名/パスワードを確認 |
| Database not found | データベースが存在しない | データベース名を確認 |
| Timeout | 接続に時間がかかりすぎ | タイムアウト値を増やす |
| SSL required | SSL接続が必須 | SSL設定を有効化 |

---

## セキュリティ考慮事項

### パスワード保護
- テスト時のパスワードはメモリ上でのみ使用
- ログに出力しない

### エラーメッセージ
- 詳細なエラー情報は開発環境のみ表示
- 本番環境では一般的なメッセージのみ表示

---

## 実装チェックリスト

- [ ] `src-tauri/src/services/connection_test_service.rs` の作成
- [ ] `src/components/connection/ConnectionTestDialog.vue` の作成
- [ ] PostgreSQL接続テストの実装
- [ ] MySQL接続テストの実装
- [ ] SQLite接続テストの実装
- [ ] タイムアウト処理の実装
- [ ] エラーハンドリングの実装
- [ ] ユニットテストの作成
- [ ] E2Eテストの作成
