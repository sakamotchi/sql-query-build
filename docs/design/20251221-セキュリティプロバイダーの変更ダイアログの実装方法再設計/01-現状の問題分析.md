# 現状の問題分析

## 対象コンポーネント
`app/components/security/ProviderChangeDialog.vue`

## 現在の実装の問題点

### 1. 単一コンポーネントで複数フローを制御
現在の`ProviderChangeDialog.vue`は、以下の4つのフローパターンを1つのコンポーネントで処理している:

1. **Simple → Master Password**
   - confirm → initialize → switching → complete

2. **Master Password → Simple**
   - confirm → authenticate → switching → complete

3. **Simple → Keychain**
   - confirm → initialize → switching → complete

4. **Master Password → Keychain**
   - confirm → authenticate → switching → complete

### 2. `nextPhase`関数の複雑性

```typescript
const nextPhase = async () => {
  // 80-88行目: confirmフェーズでの分岐
  if (currentPhase.value === 'confirm') {
    const nextPhase = props.params.from === 'master-password' ? 'authenticate' : 'initialize'
    currentPhase.value = nextPhase
    return
  }

  // 91-110行目: authenticateフェーズでの分岐
  if (currentPhase.value === 'authenticate') {
    // パスワード検証
    currentPhase.value = 'initialize'

    // さらなる分岐: 移行先がマスターパスワードでない場合は自動で次へ
    if (props.params.to !== 'master-password') {
      currentPhase.value = 'switching'
      await nextTick()
      await switchProvider()
    }
    return
  }

  // 113-117行目: initializeフェーズ
  if (currentPhase.value === 'initialize') {
    currentPhase.value = 'switching'
    await switchProvider()
  }
}
```

**問題点:**
- from/toの組み合わせによって処理フローが大きく変わる
- 特に91-110行目の`authenticate`フェーズでは、移行先プロバイダーによって処理が分岐
- コードの可読性が低く、保守が困難
- 新しいプロバイダー追加時の影響範囲が広い

### 3. テンプレートの複雑性

```vue
<div v-if="currentPhase === 'authenticate'" class="space-y-4">
  <!-- マスターパスワード認証用UI -->
</div>

<div v-if="currentPhase === 'initialize' && params.to === 'master-password'" class="space-y-4">
  <!-- 新しいマスターパスワード設定用UI -->
</div>
```

**問題点:**
- `v-if`条件が`currentPhase`だけでなく`params.to`にも依存
- フェーズとプロバイダーの組み合わせでUIが決まる複雑な構造

### 4. `canProceed`の複雑な条件判定

```typescript
const canProceed = computed(() => {
  if (currentPhase.value === 'confirm') return true

  if (currentPhase.value === 'authenticate') {
    return props.params.from === 'master-password' ? !!currentPassword.value : true
  }

  if (currentPhase.value === 'initialize') {
    return props.params.to === 'master-password'
      ? newPassword.value.length >= 8 && newPassword.value === newPasswordConfirm.value
      : true
  }

  return false
})
```

**問題点:**
- フェーズとプロバイダーの組み合わせで検証ロジックが変わる
- 三項演算子のネストで可読性が低い

## 影響範囲

### テスト容易性
- 1コンポーネントで全パターンをテストする必要があり、テストケースが爆発的に増加
- フローごとの独立したテストが困難

### 保守性
- バグ修正時に他のフローへの影響を常に考慮する必要がある
- 特定フローの変更が他フローに予期しない影響を与えるリスク

### 拡張性
- 新しいプロバイダー(例: Hardware Token)追加時、既存の複雑な条件分岐をさらに拡張する必要がある
- フロー追加のコストが高い

## 結論

現在の単一コンポーネントによる実装は、初期段階では問題なかったが、プロバイダー間の移行パターンが増えるにつれて複雑性が増している。

**推奨される解決策:**
- フローごとに専用のダイアログコンポーネントを作成
- 共通処理は共通化し、フロー固有の処理は各コンポーネントに分離
- 単一責任の原則に従い、各コンポーネントが1つのフローのみを担当
