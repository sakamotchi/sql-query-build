# 共通コンポーネント詳細設計

## 1. ProviderCard.vue

### 概要
プロバイダー情報を視覚的に表示する共通コンポーネント。
現在のプロバイダーと移行先プロバイダーの両方で使用される。

### ファイル
`app/components/security/provider-change/ProviderCard.vue`

### Props

```typescript
interface Props {
  provider: SecurityProvider  // 'simple' | 'master-password' | 'keychain'
  variant: 'current' | 'target'  // 現在 or 移行先
}
```

### State

```typescript
// プロバイダー情報の定義
const providerInfo = computed<Record<SecurityProvider, {
  name: string
  description: string
  securityLevel: number
  icon: string
}>>(() => ({
  simple: {
    name: 'Simple',
    description: '固定キーで暗号化。パスワード入力不要。',
    securityLevel: 1,
    icon: 'i-heroicons-key'
  },
  'master-password': {
    name: 'マスターパスワード',
    description: 'ユーザー設定のパスワードで暗号化。起動時に入力が必要。',
    securityLevel: 2,
    icon: 'i-heroicons-lock-closed'
  },
  keychain: {
    name: 'OSキーチェーン',
    description: 'OSのセキュアストレージを使用。OS認証が必要な場合あり。',
    securityLevel: 3,
    icon: 'i-heroicons-shield-check'
  }
}))

// 現在のプロバイダー情報
const info = computed(() => providerInfo.value[props.provider])

// ヘッダー情報
const headerInfo = computed(() => {
  if (props.variant === 'current') {
    return {
      label: '現在',
      icon: null,
      color: 'text-gray-500'
    }
  }
  return {
    label: '新規',
    icon: 'i-heroicons-arrow-right',
    color: 'text-primary-600'
  }
})
```

### Template

```vue
<template>
  <UCard>
    <template #header>
      <div class="flex items-center gap-2">
        <UIcon
          v-if="headerInfo.icon"
          :name="headerInfo.icon"
          class="w-4 h-4 text-primary-500"
        />
        <span class="text-sm font-medium" :class="headerInfo.color">
          {{ headerInfo.label }}
        </span>
      </div>
    </template>

    <div class="space-y-3">
      <!-- プロバイダー名とアイコン -->
      <div class="flex items-center gap-2">
        <UIcon :name="info.icon" class="w-5 h-5 text-gray-700 dark:text-gray-300" />
        <p class="font-semibold text-base">{{ info.name }}</p>
      </div>

      <!-- 説明 -->
      <p class="text-xs text-gray-600 dark:text-gray-400">
        {{ info.description }}
      </p>

      <!-- セキュリティレベル -->
      <div class="flex items-center gap-2">
        <span class="text-xs text-gray-500">セキュリティレベル:</span>
        <div class="flex gap-1">
          <div
            v-for="i in 3"
            :key="i"
            class="w-3 h-3 rounded-full transition-colors"
            :class="
              i <= info.securityLevel
                ? 'bg-primary-500'
                : 'bg-gray-200 dark:bg-gray-700'
            "
          />
        </div>
      </div>
    </div>
  </UCard>
</template>
```

### スタイリング

#### 現在のプロバイダー (`variant="current"`)
- ヘッダー: グレーテキスト「現在」
- アイコン: なし
- 通常のカードスタイル

#### 移行先プロバイダー (`variant="target"`)
- ヘッダー: プライマリカラー「新規」+ 右矢印アイコン
- 視覚的に強調されたスタイル

### 使用例

```vue
<template>
  <div class="grid grid-cols-2 gap-4">
    <!-- 現在のプロバイダー -->
    <ProviderCard provider="simple" variant="current" />

    <!-- 移行先プロバイダー -->
    <ProviderCard provider="master-password" variant="target" />
  </div>
</template>
```

---

## 2. useProviderSwitch.ts (Composable)

### 概要
プロバイダー切り替えのバックエンド通信ロジックを一元管理するComposable。

### ファイル
`app/composables/useProviderSwitch.ts`

### インターフェース (初期実装)

```typescript
// Simpleからの切り替えパラメータ
interface SwitchFromSimpleParams {
  targetProvider: 'master-password'  // 初期実装では 'master-password' のみ
  newPassword: string  // 必須
  newPasswordConfirm: string
}

// Master Passwordからの切り替えパラメータ
interface SwitchFromMasterPasswordParams {
  targetProvider: 'simple'  // 初期実装では 'simple' のみ
  currentPassword: string
}
```

### 実装

```typescript
import { useTauri } from '~/composables/useTauri'
import { useSecurityStore } from '~/stores/security'
import type { SecurityProvider } from '~/types'

export function useProviderSwitch() {
  const { invokeCommand, isAvailable } = useTauri()
  const securityStore = useSecurityStore()

  /**
   * バックエンドプロバイダー名に変換
   * 'master-password' → 'master_password'
   */
  function toBackendProvider(provider: SecurityProvider): string {
    return provider === 'master-password' ? 'master_password' : provider
  }

  /**
   * SimpleからMaster Passwordへの切り替え (初期実装)
   * 将来的にKeychainもサポート予定
   */
  async function switchFromSimple(params: SwitchFromSimpleParams): Promise<void> {
    if (!isAvailable.value) {
      throw new Error('Tauri環境が利用できません')
    }

    // パラメータバリデーション
    if (!params.newPassword || params.newPassword.length < 8) {
      throw new Error('パスワードは8文字以上で設定してください')
    }
    if (params.newPassword !== params.newPasswordConfirm) {
      throw new Error('パスワードが一致しません')
    }

    const backendParams = {
      targetProvider: 'master_password',  // 初期実装では固定
      currentPassword: null,  // Simpleは認証不要
      newPassword: params.newPassword,
      newPasswordConfirm: params.newPasswordConfirm
    }

    console.log('[useProviderSwitch] switchFromSimple: Simple → Master Password')

    await invokeCommand('switch_security_provider', backendParams)

    // 設定を再読み込み
    await securityStore.loadSettings()
  }

  /**
   * Master PasswordからSimpleへの切り替え (初期実装)
   * 将来的にKeychainもサポート予定
   */
  async function switchFromMasterPassword(
    params: SwitchFromMasterPasswordParams
  ): Promise<void> {
    if (!isAvailable.value) {
      throw new Error('Tauri環境が利用できません')
    }

    // パラメータバリデーション
    if (!params.currentPassword) {
      throw new Error('現在のパスワードを入力してください')
    }

    const backendParams = {
      targetProvider: 'simple',  // 初期実装では固定
      currentPassword: params.currentPassword,
      newPassword: null,  // Simpleはパスワード設定不要
      newPasswordConfirm: null
    }

    console.log('[useProviderSwitch] switchFromMasterPassword: Master Password → Simple')

    await invokeCommand('switch_security_provider', backendParams)

    // 設定を再読み込み
    await securityStore.loadSettings()
  }

  return {
    switchFromSimple,
    switchFromMasterPassword
  }
}
```

### 特徴

#### 1. 型安全性 (初期実装)
- 各関数で適切な型パラメータを定義
- `switchFromSimple` は `master-password` のみ受け付け
- `switchFromMasterPassword` は `simple` のみ受け付け
- 将来的にKeychainサポート時に型を拡張

#### 2. バリデーション
- フロントエンド側で事前バリデーション実施
- Master Password設定時のパスワード長チェック
- パスワード一致チェック

#### 3. エラーハンドリング
- Tauri環境チェック
- 明確なエラーメッセージ

#### 4. ログ出力
- デバッグ用のログ出力
- パスワードは出力しない(セキュリティ)

#### 5. 設定の自動再読み込み
- 切り替え成功後、自動的に `securityStore.loadSettings()` 実行
- UIに最新の設定を反映

### テストケース (初期実装)

#### switchFromSimple
1. **Simple → Master Password (正常系)**
   - 8文字以上のパスワード、一致 → 成功

2. **Simple → Master Password (異常系)**
   - パスワード8文字未満 → エラー
   - パスワード不一致 → エラー

3. **Tauri未利用環境**
   - エラー発生

#### switchFromMasterPassword
1. **Master Password → Simple (正常系)**
   - 現在のパスワード入力 → 成功

2. **Master Password → Simple (異常系)**
   - パスワード未入力 → エラー

3. **Tauri未利用環境**
   - エラー発生

### 将来の拡張 (Keychain対応時)

Keychain対応時は以下の変更が必要:

1. **インターフェースの拡張**
   ```typescript
   interface SwitchFromSimpleParams {
     targetProvider: 'master-password' | 'keychain'
     newPassword?: string  // Master Passwordの場合のみ必須
     newPasswordConfirm?: string
   }

   interface SwitchFromMasterPasswordParams {
     targetProvider: 'simple' | 'keychain'
     currentPassword: string
   }
   ```

2. **バリデーションの条件分岐**
   ```typescript
   if (params.targetProvider === 'master-password') {
     // パスワードバリデーション
   }
   ```

3. **backendParamsの動的生成**
   ```typescript
   const backendParams = {
     targetProvider: toBackendProvider(params.targetProvider),
     currentPassword: params.currentPassword || null,
     newPassword: params.newPassword || null,
     newPasswordConfirm: params.newPasswordConfirm || null
   }
   ```

---

## 共通コンポーネントのディレクトリ構成

```
app/
├── components/
│   └── security/
│       └── provider-change/
│           ├── ProviderCard.vue           # プロバイダー情報表示
│           ├── FromSimpleDialog.vue       # Simpleからの移行ダイアログ
│           └── FromMasterPasswordDialog.vue  # Master Passwordからの移行ダイアログ
└── composables/
    └── useProviderSwitch.ts               # プロバイダー切り替えロジック
```

## 再利用性とメンテナンス性

### ProviderCard.vue
- **再利用性:** 高い(全ダイアログで使用可能)
- **メンテナンス:** プロバイダー情報の変更は1箇所で完結
- **拡張性:** 新しいプロバイダー追加時、`providerInfo`に追加するだけ

### useProviderSwitch.ts
- **再利用性:** 高い(両ダイアログで使用)
- **メンテナンス:** バックエンド通信ロジックの変更は1箇所で完結
- **テスタビリティ:** Composableなので単体テストが容易
- **拡張性:** 新しいプロバイダー追加時、新しい関数を追加
