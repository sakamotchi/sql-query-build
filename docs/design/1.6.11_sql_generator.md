# タスク1.6.8: SQL生成エンジン実装 設計書

## 概要

**タスクID**: 1.6.8
**タスク名**: SQL生成エンジン（SELECT/WHERE）実装
**工数**: 2日
**依存関係**: 1.6.7 (クエリオブジェクトモデル定義)
**完了条件**: SQLが正しく生成される
**UIフレームワーク**: Nuxt UI v4（Tailwind CSS 4ベース）

---

## 目的

クエリオブジェクトモデル（JSON）からSQL文を生成するエンジンをRustで実装する。フェーズ1ではSELECT句とWHERE句の生成に対応し、フェーズ2でJOIN、GROUP BY、ORDER BY等を追加する。

生成されたSQLはフロントエンドでNuxt UI v4のコンポーネントを使用してプレビュー表示されます。

---

## アーキテクチャ

### 全体構成

```
┌─────────────────────────────────────────────────────────────┐
│                    Frontend (Vue.js)                        │
│  QueryBuilderStore → convertToQueryModel() → QueryModel     │
└──────────────────────────┬──────────────────────────────────┘
                           │ Tauri IPC (invoke)
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                    Backend (Rust)                           │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                 SQL Generator                        │   │
│  │  ┌───────────────┐  ┌───────────────┐              │   │
│  │  │ SqlBuilder    │  │ Dialect       │              │   │
│  │  │ (共通処理)     │  │ (DB別処理)    │              │   │
│  │  └───────────────┘  └───────────────┘              │   │
│  │         │                   │                       │   │
│  │         ▼                   ▼                       │   │
│  │  ┌─────────────────────────────────────────────┐   │   │
│  │  │ PostgresDialect | MysqlDialect | SqliteDialect │   │
│  │  └─────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────┘   │
│                           │                                 │
│                           ▼                                 │
│                    Generated SQL String                     │
└─────────────────────────────────────────────────────────────┘
```

---

## Rust実装

### ファイル構成

```
src-tauri/src/
├── sql_generator/
│   ├── mod.rs              # モジュール定義
│   ├── builder.rs          # SQLビルダー（共通処理）
│   ├── dialect.rs          # 方言トレイト
│   ├── dialects/
│   │   ├── mod.rs
│   │   ├── postgresql.rs   # PostgreSQL方言
│   │   ├── mysql.rs        # MySQL方言
│   │   └── sqlite.rs       # SQLite方言
│   ├── clause/
│   │   ├── mod.rs
│   │   ├── select.rs       # SELECT句生成
│   │   ├── from.rs         # FROM句生成
│   │   ├── join.rs         # JOIN句生成
│   │   ├── where_clause.rs # WHERE句生成
│   │   ├── group_by.rs     # GROUP BY句生成
│   │   ├── order_by.rs     # ORDER BY句生成
│   │   └── limit.rs        # LIMIT句生成
│   └── utils.rs            # ユーティリティ
├── models/
│   └── query.rs            # クエリモデル（1.6.7で定義）
└── commands/
    └── query.rs            # Tauriコマンド
```

---

### sql_generator/mod.rs

```rust
pub mod builder;
pub mod dialect;
pub mod dialects;
pub mod clause;
pub mod utils;

pub use builder::SqlBuilder;
pub use dialect::Dialect;
```

---

### sql_generator/dialect.rs

```rust
use crate::models::query::*;

/// SQL方言トレイト
pub trait Dialect: Send + Sync {
    /// 識別子をクォート
    fn quote_identifier(&self, identifier: &str) -> String;

    /// 文字列リテラルをエスケープ
    fn escape_string(&self, value: &str) -> String;

    /// LIMITオフセット構文
    fn limit_offset(&self, limit: u64, offset: Option<u64>) -> String;

    /// LIKE演算子のエスケープ文字
    fn like_escape_char(&self) -> char {
        '\\'
    }

    /// 大文字小文字を区別しないLIKE
    fn ilike_operator(&self) -> &str {
        "ILIKE"
    }

    /// NULLS FIRST/LAST のサポート
    fn supports_nulls_order(&self) -> bool {
        true
    }

    /// データベース種別名
    fn dialect_name(&self) -> &str;
}
```

---

### sql_generator/dialects/postgresql.rs

```rust
use super::super::dialect::Dialect;

pub struct PostgresDialect;

impl Dialect for PostgresDialect {
    fn quote_identifier(&self, identifier: &str) -> String {
        format!("\"{}\"", identifier.replace('"', "\"\""))
    }

    fn escape_string(&self, value: &str) -> String {
        format!("'{}'", value.replace('\'', "''"))
    }

    fn limit_offset(&self, limit: u64, offset: Option<u64>) -> String {
        match offset {
            Some(off) => format!("LIMIT {} OFFSET {}", limit, off),
            None => format!("LIMIT {}", limit),
        }
    }

    fn ilike_operator(&self) -> &str {
        "ILIKE"
    }

    fn supports_nulls_order(&self) -> bool {
        true
    }

    fn dialect_name(&self) -> &str {
        "postgresql"
    }
}
```

---

### sql_generator/dialects/mysql.rs

```rust
use super::super::dialect::Dialect;

pub struct MysqlDialect;

impl Dialect for MysqlDialect {
    fn quote_identifier(&self, identifier: &str) -> String {
        format!("`{}`", identifier.replace('`', "``"))
    }

    fn escape_string(&self, value: &str) -> String {
        format!("'{}'", value.replace('\'', "\\'"))
    }

    fn limit_offset(&self, limit: u64, offset: Option<u64>) -> String {
        match offset {
            Some(off) => format!("LIMIT {}, {}", off, limit),
            None => format!("LIMIT {}", limit),
        }
    }

    fn ilike_operator(&self) -> &str {
        "LIKE" // MySQLのLIKEはデフォルトで大文字小文字を区別しない
    }

    fn supports_nulls_order(&self) -> bool {
        false // MySQL 8.0未満は非サポート
    }

    fn dialect_name(&self) -> &str {
        "mysql"
    }
}
```

---

### sql_generator/dialects/sqlite.rs

```rust
use super::super::dialect::Dialect;

pub struct SqliteDialect;

impl Dialect for SqliteDialect {
    fn quote_identifier(&self, identifier: &str) -> String {
        format!("\"{}\"", identifier.replace('"', "\"\""))
    }

    fn escape_string(&self, value: &str) -> String {
        format!("'{}'", value.replace('\'', "''"))
    }

    fn limit_offset(&self, limit: u64, offset: Option<u64>) -> String {
        match offset {
            Some(off) => format!("LIMIT {} OFFSET {}", limit, off),
            None => format!("LIMIT {}", limit),
        }
    }

    fn ilike_operator(&self) -> &str {
        "LIKE" // SQLiteのLIKEは大文字小文字を区別しない
    }

    fn supports_nulls_order(&self) -> bool {
        false
    }

    fn dialect_name(&self) -> &str {
        "sqlite"
    }
}
```

---

### sql_generator/builder.rs

```rust
use crate::models::query::*;
use super::dialect::Dialect;
use super::clause::*;

/// SQLビルダー
pub struct SqlBuilder<'a> {
    dialect: &'a dyn Dialect,
    pretty: bool,
    indent: usize,
}

impl<'a> SqlBuilder<'a> {
    /// 新しいビルダーを作成
    pub fn new(dialect: &'a dyn Dialect) -> Self {
        Self {
            dialect,
            pretty: true,
            indent: 2,
        }
    }

    /// 整形出力を無効化
    pub fn compact(mut self) -> Self {
        self.pretty = false;
        self
    }

    /// クエリモデルからSQLを生成
    pub fn build(&self, query: &QueryModel) -> Result<String, String> {
        let mut parts: Vec<String> = Vec::new();

        // SELECT句
        parts.push(self.build_select(&query.select)?);

        // FROM句
        parts.push(self.build_from(&query.from)?);

        // JOIN句
        for join in &query.joins {
            parts.push(self.build_join(join)?);
        }

        // WHERE句
        if let Some(ref where_clause) = query.where_clause {
            parts.push(self.build_where(where_clause)?);
        }

        // GROUP BY句
        if let Some(ref group_by) = query.group_by {
            parts.push(self.build_group_by(group_by)?);
        }

        // HAVING句
        if let Some(ref having) = query.having {
            parts.push(self.build_having(having)?);
        }

        // ORDER BY句
        if let Some(ref order_by) = query.order_by {
            parts.push(self.build_order_by(order_by)?);
        }

        // LIMIT句
        if let Some(ref limit) = query.limit {
            parts.push(self.build_limit(limit)?);
        }

        // 結合
        let separator = if self.pretty { "\n" } else { " " };
        Ok(parts.join(separator))
    }

    /// SELECT句を生成
    fn build_select(&self, select: &SelectClause) -> Result<String, String> {
        let mut sql = String::from("SELECT");

        if select.distinct {
            sql.push_str(" DISTINCT");
        }

        let columns: Vec<String> = select
            .columns
            .iter()
            .map(|col| self.build_select_column(col))
            .collect::<Result<Vec<_>, _>>()?;

        if columns.is_empty() {
            return Err("No columns selected".to_string());
        }

        let separator = if self.pretty { ",\n  " } else { ", " };
        let prefix = if self.pretty { "\n  " } else { " " };

        sql.push_str(&format!("{}{}", prefix, columns.join(separator)));

        Ok(sql)
    }

    /// SELECT列を生成
    fn build_select_column(&self, column: &SelectColumn) -> Result<String, String> {
        let col_sql = match column {
            SelectColumn::Column {
                table_alias,
                column_name,
                alias,
            } => {
                let col = format!(
                    "{}.{}",
                    self.dialect.quote_identifier(table_alias),
                    self.dialect.quote_identifier(column_name)
                );
                if let Some(a) = alias {
                    format!("{} AS {}", col, self.dialect.quote_identifier(a))
                } else {
                    col
                }
            }
            SelectColumn::All { table_alias } => {
                format!("{}.*", self.dialect.quote_identifier(table_alias))
            }
            SelectColumn::Aggregate { aggregate, alias } => {
                let agg = self.build_aggregate(aggregate)?;
                if let Some(a) = alias {
                    format!("{} AS {}", agg, self.dialect.quote_identifier(a))
                } else {
                    agg
                }
            }
            SelectColumn::Expression { expression, alias } => {
                if let Some(a) = alias {
                    format!("({}) AS {}", expression, self.dialect.quote_identifier(a))
                } else {
                    format!("({})", expression)
                }
            }
        };

        Ok(col_sql)
    }

    /// 集計関数を生成
    fn build_aggregate(&self, agg: &AggregateFunction) -> Result<String, String> {
        let func = match agg.function.as_str() {
            "COUNT_DISTINCT" => "COUNT(DISTINCT",
            f => f,
        };

        let col = match &agg.column {
            AggregateColumn::All => "*".to_string(),
            AggregateColumn::Column { table_alias, column_name } => {
                format!(
                    "{}.{}",
                    self.dialect.quote_identifier(table_alias),
                    self.dialect.quote_identifier(column_name)
                )
            }
        };

        if agg.function == "COUNT_DISTINCT" {
            Ok(format!("{} {})", func, col))
        } else {
            Ok(format!("{}({})", func, col))
        }
    }

    /// FROM句を生成
    fn build_from(&self, from: &FromClause) -> Result<String, String> {
        let table = &from.table;
        let prefix = if self.pretty { "" } else { "" };

        Ok(format!(
            "{}FROM {}.{} {}",
            prefix,
            self.dialect.quote_identifier(&table.schema),
            self.dialect.quote_identifier(&table.name),
            self.dialect.quote_identifier(&table.alias)
        ))
    }

    /// JOIN句を生成
    fn build_join(&self, join: &JoinClause) -> Result<String, String> {
        let join_type = match join.join_type.as_str() {
            "INNER" => "INNER JOIN",
            "LEFT" => "LEFT JOIN",
            "RIGHT" => "RIGHT JOIN",
            "FULL" => "FULL OUTER JOIN",
            "CROSS" => "CROSS JOIN",
            _ => return Err(format!("Unknown join type: {}", join.join_type)),
        };

        let table = &join.table;
        let table_sql = format!(
            "{}.{} {}",
            self.dialect.quote_identifier(&table.schema),
            self.dialect.quote_identifier(&table.name),
            self.dialect.quote_identifier(&table.alias)
        );

        if join.conditions.is_empty() {
            return Ok(format!("{} {}", join_type, table_sql));
        }

        let conditions: Vec<String> = join
            .conditions
            .iter()
            .map(|cond| {
                format!(
                    "{}.{} {} {}.{}",
                    self.dialect.quote_identifier(&cond.left.table_alias),
                    self.dialect.quote_identifier(&cond.left.column_name),
                    cond.operator,
                    self.dialect.quote_identifier(&cond.right.table_alias),
                    self.dialect.quote_identifier(&cond.right.column_name)
                )
            })
            .collect();

        let logic = &join.condition_logic;
        let on_clause = conditions.join(&format!(" {} ", logic));

        Ok(format!("{} {} ON {}", join_type, table_sql, on_clause))
    }

    /// WHERE句を生成
    fn build_where(&self, where_clause: &WhereClause) -> Result<String, String> {
        let conditions = self.build_where_conditions(&where_clause.conditions, &where_clause.logic)?;
        Ok(format!("WHERE {}", conditions))
    }

    /// WHERE条件を再帰的に生成
    fn build_where_conditions(
        &self,
        conditions: &[WhereConditionItem],
        logic: &str,
    ) -> Result<String, String> {
        let parts: Vec<String> = conditions
            .iter()
            .map(|item| self.build_where_condition_item(item))
            .collect::<Result<Vec<_>, _>>()?;

        if parts.is_empty() {
            return Err("No WHERE conditions".to_string());
        }

        let separator = format!(" {} ", logic);
        Ok(parts.join(&separator))
    }

    /// WHERE条件アイテムを生成
    fn build_where_condition_item(&self, item: &WhereConditionItem) -> Result<String, String> {
        match item {
            WhereConditionItem::Condition(cond) => self.build_condition(cond),
            WhereConditionItem::Group(group) => {
                let inner = self.build_where_conditions(&group.conditions, &group.logic)?;
                Ok(format!("({})", inner))
            }
        }
    }

    /// 単一条件を生成
    fn build_condition(&self, cond: &WhereCondition) -> Result<String, String> {
        let column = format!(
            "{}.{}",
            self.dialect.quote_identifier(&cond.column.table_alias),
            self.dialect.quote_identifier(&cond.column.column_name)
        );

        let value_sql = self.build_where_value(&cond.value, &cond.operator)?;

        Ok(format!("{} {} {}", column, cond.operator, value_sql))
    }

    /// WHERE値を生成
    fn build_where_value(&self, value: &WhereValue, operator: &str) -> Result<String, String> {
        match value {
            WhereValue::Literal { value } => {
                match value {
                    LiteralValue::Null => Ok("NULL".to_string()),
                    LiteralValue::String(s) => Ok(self.dialect.escape_string(s)),
                    LiteralValue::Number(n) => Ok(n.to_string()),
                    LiteralValue::Boolean(b) => Ok(if *b { "TRUE" } else { "FALSE" }.to_string()),
                }
            }
            WhereValue::List { values } => {
                let items: Vec<String> = values
                    .iter()
                    .map(|v| match v {
                        LiteralValue::String(s) => self.dialect.escape_string(s),
                        LiteralValue::Number(n) => n.to_string(),
                        _ => v.to_string(),
                    })
                    .collect();
                Ok(format!("({})", items.join(", ")))
            }
            WhereValue::Range { from, to } => {
                let from_sql = match from {
                    LiteralValue::String(s) => self.dialect.escape_string(s),
                    LiteralValue::Number(n) => n.to_string(),
                    _ => from.to_string(),
                };
                let to_sql = match to {
                    LiteralValue::String(s) => self.dialect.escape_string(s),
                    LiteralValue::Number(n) => n.to_string(),
                    _ => to.to_string(),
                };
                Ok(format!("{} AND {}", from_sql, to_sql))
            }
            WhereValue::Column { table_alias, column_name } => {
                Ok(format!(
                    "{}.{}",
                    self.dialect.quote_identifier(table_alias),
                    self.dialect.quote_identifier(column_name)
                ))
            }
        }
    }

    /// GROUP BY句を生成
    fn build_group_by(&self, group_by: &GroupByClause) -> Result<String, String> {
        let columns: Vec<String> = group_by
            .columns
            .iter()
            .map(|col| {
                format!(
                    "{}.{}",
                    self.dialect.quote_identifier(&col.table_alias),
                    self.dialect.quote_identifier(&col.column_name)
                )
            })
            .collect();

        Ok(format!("GROUP BY {}", columns.join(", ")))
    }

    /// HAVING句を生成
    fn build_having(&self, having: &HavingClause) -> Result<String, String> {
        let conditions: Vec<String> = having
            .conditions
            .iter()
            .map(|cond| {
                let agg = self.build_aggregate(&cond.aggregate)?;
                let value = match &cond.value {
                    LiteralValue::String(s) => self.dialect.escape_string(s),
                    LiteralValue::Number(n) => n.to_string(),
                    _ => cond.value.to_string(),
                };
                Ok(format!("{} {} {}", agg, cond.operator, value))
            })
            .collect::<Result<Vec<_>, String>>()?;

        let logic = &having.logic;
        Ok(format!("HAVING {}", conditions.join(&format!(" {} ", logic))))
    }

    /// ORDER BY句を生成
    fn build_order_by(&self, order_by: &OrderByClause) -> Result<String, String> {
        let items: Vec<String> = order_by
            .items
            .iter()
            .map(|item| {
                let col = format!(
                    "{}.{}",
                    self.dialect.quote_identifier(&item.table_alias),
                    self.dialect.quote_identifier(&item.column_name)
                );
                let direction = &item.direction;
                let nulls = if self.dialect.supports_nulls_order() {
                    match &item.nulls {
                        Some(n) => format!(" NULLS {}", n),
                        None => String::new(),
                    }
                } else {
                    String::new()
                };
                format!("{} {}{}", col, direction, nulls)
            })
            .collect();

        Ok(format!("ORDER BY {}", items.join(", ")))
    }

    /// LIMIT句を生成
    fn build_limit(&self, limit: &LimitClause) -> Result<String, String> {
        Ok(self.dialect.limit_offset(limit.limit, limit.offset))
    }
}
```

---

### Tauriコマンド

```rust
// src-tauri/src/commands/query.rs

use tauri::{command, State};
use crate::models::query::QueryModel;
use crate::sql_generator::{SqlBuilder, Dialect};
use crate::sql_generator::dialects::{PostgresDialect, MysqlDialect, SqliteDialect};
use crate::services::connection_service::ConnectionService;

/// SQLを生成
#[command]
pub async fn generate_sql(
    query: QueryModel,
    connection_service: State<'_, ConnectionService>,
) -> Result<String, String> {
    // 接続情報から方言を取得
    let connection = connection_service
        .get_connection(&query.connection_id)
        .await?
        .ok_or_else(|| format!("Connection not found: {}", query.connection_id))?;

    let dialect: Box<dyn Dialect> = match connection.db_type.as_str() {
        "postgresql" => Box::new(PostgresDialect),
        "mysql" => Box::new(MysqlDialect),
        "sqlite" => Box::new(SqliteDialect),
        _ => return Err(format!("Unsupported database type: {}", connection.db_type)),
    };

    let builder = SqlBuilder::new(dialect.as_ref());
    builder.build(&query)
}

/// SQLを生成（フォーマット指定）
#[command]
pub async fn generate_sql_formatted(
    query: QueryModel,
    pretty: bool,
    connection_service: State<'_, ConnectionService>,
) -> Result<String, String> {
    let connection = connection_service
        .get_connection(&query.connection_id)
        .await?
        .ok_or_else(|| format!("Connection not found: {}", query.connection_id))?;

    let dialect: Box<dyn Dialect> = match connection.db_type.as_str() {
        "postgresql" => Box::new(PostgresDialect),
        "mysql" => Box::new(MysqlDialect),
        "sqlite" => Box::new(SqliteDialect),
        _ => return Err(format!("Unsupported database type: {}", connection.db_type)),
    };

    let mut builder = SqlBuilder::new(dialect.as_ref());
    if !pretty {
        builder = builder.compact();
    }

    builder.build(&query)
}
```

---

## フロントエンド連携

### src/api/query.ts

```typescript
import { invoke } from '@tauri-apps/api/core';
import type { QueryModel } from '@/types/query';

export const queryApi = {
  /**
   * SQLを生成
   */
  async generateSql(query: QueryModel): Promise<string> {
    return invoke('generate_sql', { query });
  },

  /**
   * SQLを生成（フォーマット指定）
   */
  async generateSqlFormatted(query: QueryModel, pretty: boolean): Promise<string> {
    return invoke('generate_sql_formatted', { query, pretty });
  },
};
```

---

### ストアでのSQL生成

```typescript
// src/stores/query-builder.ts

import { defineStore } from 'pinia';
import { queryApi } from '@/api/query';
import { convertToQueryModel } from '@/utils/query-converter';

export const useQueryBuilderStore = defineStore('query-builder', {
  state: () => ({
    // ... 既存の状態
    generatedSql: '',
    sqlGenerationError: null as string | null,
    isGeneratingSql: false,
  }),

  actions: {
    /**
     * SQLを再生成
     */
    async regenerateSql() {
      if (!this.canExecuteQuery) {
        this.generatedSql = '';
        return;
      }

      this.isGeneratingSql = true;
      this.sqlGenerationError = null;

      try {
        const queryModel = convertToQueryModel(this.$state, this.connectionId);
        this.generatedSql = await queryApi.generateSql(queryModel);
      } catch (error) {
        this.sqlGenerationError = error instanceof Error ? error.message : 'Unknown error';
        this.generatedSql = '';
      } finally {
        this.isGeneratingSql = false;
      }
    },
  },
});
```

---

## 生成例

### 基本SELECT

入力:
```json
{
  "select": {
    "distinct": false,
    "columns": [
      { "type": "column", "tableAlias": "u", "columnName": "id" },
      { "type": "column", "tableAlias": "u", "columnName": "name" }
    ]
  },
  "from": {
    "table": { "schema": "public", "name": "users", "alias": "u" }
  }
}
```

出力 (PostgreSQL):
```sql
SELECT
  "u"."id",
  "u"."name"
FROM "public"."users" "u"
```

---

### WHERE条件付き

入力:
```json
{
  "select": { ... },
  "from": { ... },
  "where": {
    "logic": "AND",
    "conditions": [
      {
        "type": "condition",
        "column": { "tableAlias": "u", "columnName": "status" },
        "operator": "=",
        "value": { "type": "literal", "value": "active" }
      },
      {
        "type": "condition",
        "column": { "tableAlias": "u", "columnName": "age" },
        "operator": ">=",
        "value": { "type": "literal", "value": 18 }
      }
    ]
  }
}
```

出力:
```sql
SELECT
  "u"."id",
  "u"."name"
FROM "public"."users" "u"
WHERE "u"."status" = 'active' AND "u"."age" >= 18
```

---

### ネストされたWHERE条件

入力:
```json
{
  "where": {
    "logic": "AND",
    "conditions": [
      {
        "type": "condition",
        "column": { "tableAlias": "u", "columnName": "status" },
        "operator": "=",
        "value": { "type": "literal", "value": "active" }
      },
      {
        "type": "group",
        "logic": "OR",
        "conditions": [
          {
            "type": "condition",
            "column": { "tableAlias": "u", "columnName": "role" },
            "operator": "=",
            "value": { "type": "literal", "value": "admin" }
          },
          {
            "type": "condition",
            "column": { "tableAlias": "u", "columnName": "role" },
            "operator": "=",
            "value": { "type": "literal", "value": "manager" }
          }
        ]
      }
    ]
  }
}
```

出力:
```sql
WHERE "u"."status" = 'active' AND ("u"."role" = 'admin' OR "u"."role" = 'manager')
```

---

## エラーハンドリング

### エラー種別

| エラー | メッセージ例 | 対処 |
|--------|-------------|------|
| カラム未選択 | "No columns selected" | カラムを選択するよう促す |
| テーブル未選択 | "No table selected" | テーブルを選択するよう促す |
| 無効な演算子 | "Unknown operator: XYZ" | 内部エラーとしてログ |
| 不正な値 | "Invalid value for operator" | ユーザーに再入力を促す |

---

## セキュリティ考慮事項

### SQLインジェクション対策

1. **識別子のクォート**: 全ての識別子（テーブル名、カラム名）は方言に応じてクォート
2. **文字列エスケープ**: 全ての文字列リテラルはエスケープ処理
3. **値のバリデーション**: 数値は数値型として処理、文字列は必ずエスケープ

```rust
// 安全な識別子クォート
fn quote_identifier(&self, identifier: &str) -> String {
    // ダブルクォートをエスケープ
    format!("\"{}\"", identifier.replace('"', "\"\""))
}

// 安全な文字列エスケープ
fn escape_string(&self, value: &str) -> String {
    // シングルクォートをエスケープ
    format!("'{}'", value.replace('\'', "''"))
}
```

---

## テスト設計

### ユニットテスト

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_select() {
        let dialect = PostgresDialect;
        let builder = SqlBuilder::new(&dialect);

        let query = QueryModel {
            // ... テストデータ
        };

        let sql = builder.build(&query).unwrap();
        assert!(sql.contains("SELECT"));
        assert!(sql.contains("FROM"));
    }

    #[test]
    fn test_where_clause() {
        // WHERE句のテスト
    }

    #[test]
    fn test_nested_conditions() {
        // ネスト条件のテスト
    }

    #[test]
    fn test_sql_injection_prevention() {
        // SQLインジェクション対策のテスト
        let dialect = PostgresDialect;
        let builder = SqlBuilder::new(&dialect);

        // 悪意のある入力をエスケープできることを確認
        let escaped = dialect.escape_string("'; DROP TABLE users; --");
        assert!(!escaped.contains(';'));
    }
}
```

### 統合テスト

```
シナリオ1: 基本的なSQL生成
1. テーブルを選択
2. カラムを選択
3. SQLプレビューに正しいSQLが表示されることを確認

シナリオ2: WHERE条件付きSQL
1. テーブルとカラムを選択
2. WHERE条件を追加
3. SQLにWHERE句が含まれることを確認

シナリオ3: 複雑な条件
1. 複数の条件とグループを追加
2. 括弧が正しく生成されることを確認
```

---

## 実装チェックリスト

- [ ] `src-tauri/src/sql_generator/mod.rs` の作成
- [ ] `src-tauri/src/sql_generator/dialect.rs` の作成
- [ ] `src-tauri/src/sql_generator/dialects/postgresql.rs` の作成
- [ ] `src-tauri/src/sql_generator/dialects/mysql.rs` の作成
- [ ] `src-tauri/src/sql_generator/dialects/sqlite.rs` の作成
- [ ] `src-tauri/src/sql_generator/builder.rs` の作成
- [ ] SELECT句生成の実装
- [ ] FROM句生成の実装
- [ ] WHERE句生成の実装（ネスト対応）
- [ ] `src-tauri/src/commands/query.rs` の作成
- [ ] `src/api/query.ts` の作成
- [ ] ストアでのSQL自動生成
- [ ] SQLインジェクション対策の検証
- [ ] ユニットテストの作成
- [ ] 統合テストの作成

---

## 参考資料

- [Nuxt UI v4 Documentation](https://ui.nuxt.com/)
- [Tailwind CSS v4](https://tailwindcss.com/)
- [SQL Standard](https://www.iso.org/standard/63555.html)
- [PostgreSQL SQL Syntax](https://www.postgresql.org/docs/current/sql-syntax.html)
- [MySQL SQL Syntax](https://dev.mysql.com/doc/refman/8.0/en/sql-syntax.html)
- [SQLite SQL Syntax](https://www.sqlite.org/lang.html)
