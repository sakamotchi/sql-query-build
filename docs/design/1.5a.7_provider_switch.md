# 1.5a.7 プロバイダー切り替え・再暗号化機能

## 概要

| 項目 | 内容 |
|------|------|
| タスクID | 1.5a.7 |
| タスク名 | プロバイダー切り替え・再暗号化機能 |
| 担当 | BE |
| 工数 | 1.5日 |
| 依存関係 | 1.5a.2-1.5a.4 |
| 完了条件 | プロバイダー変更時に再暗号化 |

## 目的

セキュリティプロバイダーを変更する際に、既存の認証情報を新しいプロバイダーのキーで安全に再暗号化する。

## 処理フロー

```
┌─────────────────────────────────────────────────────────────────┐
│                  プロバイダー変更フロー                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 現在のプロバイダーで認証                                     │
│     └─ MasterPassword: パスワード入力                           │
│     └─ Keychain: OS認証                                         │
│     └─ Simple: 自動                                              │
│                     ↓                                            │
│  2. 現在のキーで全認証情報を復号化                               │
│                     ↓                                            │
│  3. 新しいプロバイダーを初期化                                   │
│     └─ MasterPassword: 新パスワード設定                         │
│     └─ Keychain: キー生成                                        │
│     └─ Simple: 固定キー生成                                      │
│                     ↓                                            │
│  4. 新しいキーで全認証情報を再暗号化                             │
│                     ↓                                            │
│  5. 設定を保存                                                   │
│                     ↓                                            │
│  6. 古いプロバイダーをクリーンアップ                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 設計詳細

### ProviderSwitcher実装

```rust
use std::sync::Arc;

use crate::crypto::security_provider::{
    SecurityProvider, SecurityProviderManager, SecurityProviderType,
    InitializeParams, UnlockParams, SecurityProviderError, SecurityProviderResult,
};
use crate::crypto::security_provider::credential::{CredentialStorage, CredentialError};
use crate::crypto::security_provider::config::{SecurityConfigStorage, SecurityConfig};

/// プロバイダー切り替え結果
#[derive(Debug, Clone)]
pub struct SwitchResult {
    /// 成功したかどうか
    pub success: bool,
    /// 再暗号化した認証情報の数
    pub re_encrypted_count: usize,
    /// エラーメッセージ（失敗時）
    pub error: Option<String>,
}

/// プロバイダー切り替えパラメータ
#[derive(Debug, Clone)]
pub struct SwitchParams {
    /// 変更先のプロバイダー
    pub target_provider: SecurityProviderType,

    /// 現在のプロバイダーの認証パラメータ
    pub current_auth: UnlockParams,

    /// 新しいプロバイダーの初期化パラメータ
    pub new_init: InitializeParams,
}

/// プロバイダー切り替えサービス
pub struct ProviderSwitcher {
    /// プロバイダーマネージャー
    provider_manager: Arc<SecurityProviderManager>,

    /// 認証情報ストレージ
    credential_storage: Arc<CredentialStorage>,

    /// 設定ストレージ
    config_storage: Arc<SecurityConfigStorage>,
}

impl ProviderSwitcher {
    pub fn new(
        provider_manager: Arc<SecurityProviderManager>,
        credential_storage: Arc<CredentialStorage>,
        config_storage: Arc<SecurityConfigStorage>,
    ) -> Self {
        Self {
            provider_manager,
            credential_storage,
            config_storage,
        }
    }

    /// プロバイダーを切り替え
    pub async fn switch(&self, params: SwitchParams) -> Result<SwitchResult, SwitchError> {
        // 1. 現在のプロバイダーで認証
        self.provider_manager.unlock(params.current_auth.clone()).await
            .map_err(|e| SwitchError::AuthenticationFailed(e.to_string()))?;

        // 2. 現在のキーを取得
        let old_key = self.provider_manager.get_encryption_key().await
            .map_err(|e| SwitchError::KeyRetrievalFailed(e.to_string()))?;

        // 3. 全認証情報を復号化（メモリ上に保持）
        let credentials = self.load_all_decrypted_credentials(&old_key).await?;

        // 4. 新しいプロバイダーに切り替え
        self.provider_manager.change_provider(params.target_provider).await
            .map_err(|e| SwitchError::ProviderChangeFailed(e.to_string()))?;

        // 5. 新しいプロバイダーを初期化
        self.provider_manager.initialize(params.new_init).await
            .map_err(|e| SwitchError::InitializationFailed(e.to_string()))?;

        // 6. 新しいキーを取得
        let new_key = self.provider_manager.get_encryption_key().await
            .map_err(|e| SwitchError::KeyRetrievalFailed(e.to_string()))?;

        // 7. 認証情報を再暗号化
        let re_encrypted_count = self.re_encrypt_credentials(&credentials, &new_key).await?;

        // 8. 設定を保存
        self.config_storage.change_provider(params.target_provider).await
            .map_err(|e| SwitchError::ConfigSaveFailed(e.to_string()))?;

        Ok(SwitchResult {
            success: true,
            re_encrypted_count,
            error: None,
        })
    }

    /// 全認証情報を復号化して読み込み
    async fn load_all_decrypted_credentials(
        &self,
        key: &[u8],
    ) -> Result<Vec<DecryptedCredential>, SwitchError> {
        // CredentialStorageから全てのエントリを取得
        // 各エントリを復号化
        // メモリ上のVecに保持
        todo!("Implementation")
    }

    /// 認証情報を再暗号化
    async fn re_encrypt_credentials(
        &self,
        credentials: &[DecryptedCredential],
        new_key: &[u8],
    ) -> Result<usize, SwitchError> {
        let mut count = 0;
        for cred in credentials {
            self.credential_storage.save(
                &cred.connection_id,
                cred.password.as_deref(),
                cred.ssh_passphrase.as_deref(),
                cred.ssl_password.as_deref(),
            ).await.map_err(|e| SwitchError::ReEncryptionFailed(e.to_string()))?;
            count += 1;
        }
        Ok(count)
    }
}

/// 復号化された認証情報（一時的にメモリ上に保持）
struct DecryptedCredential {
    connection_id: String,
    password: Option<String>,
    ssh_passphrase: Option<String>,
    ssl_password: Option<String>,
}

impl Drop for DecryptedCredential {
    fn drop(&mut self) {
        // メモリ上のパスワードをクリア
        if let Some(ref mut pwd) = self.password {
            pwd.zeroize();
        }
        if let Some(ref mut phrase) = self.ssh_passphrase {
            phrase.zeroize();
        }
        if let Some(ref mut pwd) = self.ssl_password {
            pwd.zeroize();
        }
    }
}
```

### エラー型

```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum SwitchError {
    #[error("Authentication failed: {0}")]
    AuthenticationFailed(String),

    #[error("Key retrieval failed: {0}")]
    KeyRetrievalFailed(String),

    #[error("Provider change failed: {0}")]
    ProviderChangeFailed(String),

    #[error("Initialization failed: {0}")]
    InitializationFailed(String),

    #[error("Re-encryption failed: {0}")]
    ReEncryptionFailed(String),

    #[error("Config save failed: {0}")]
    ConfigSaveFailed(String),

    #[error("Rollback failed: {0}")]
    RollbackFailed(String),
}
```

### ロールバック機能

```rust
impl ProviderSwitcher {
    /// 切り替え失敗時のロールバック
    async fn rollback(
        &self,
        original_provider: SecurityProviderType,
        original_key: &[u8],
        credentials: &[DecryptedCredential],
    ) -> Result<(), SwitchError> {
        // 元のプロバイダーに戻す
        self.provider_manager.change_provider(original_provider).await
            .map_err(|e| SwitchError::RollbackFailed(e.to_string()))?;

        // 元のキーで認証情報を再暗号化
        self.re_encrypt_credentials(credentials, original_key).await
            .map_err(|e| SwitchError::RollbackFailed(e.to_string()))?;

        // 設定を復元
        self.config_storage.change_provider(original_provider).await
            .map_err(|e| SwitchError::RollbackFailed(e.to_string()))?;

        Ok(())
    }
}
```

### Tauriコマンド

```rust
/// プロバイダーを切り替え
#[tauri::command]
pub async fn switch_security_provider(
    switcher: State<'_, Arc<ProviderSwitcher>>,
    target_provider: SecurityProviderType,
    current_password: Option<String>,
    new_password: Option<String>,
    new_password_confirm: Option<String>,
) -> Result<SwitchResult, String> {
    let current_auth = match switcher.provider_manager.current_provider_type().await {
        SecurityProviderType::Simple => UnlockParams::Simple,
        SecurityProviderType::MasterPassword => UnlockParams::MasterPassword {
            password: current_password.unwrap_or_default(),
        },
        SecurityProviderType::Keychain => UnlockParams::Keychain,
    };

    let new_init = match target_provider {
        SecurityProviderType::Simple => InitializeParams::Simple,
        SecurityProviderType::MasterPassword => InitializeParams::MasterPassword {
            password: new_password.unwrap_or_default(),
            password_confirm: new_password_confirm.unwrap_or_default(),
        },
        SecurityProviderType::Keychain => InitializeParams::Keychain,
    };

    switcher.switch(SwitchParams {
        target_provider,
        current_auth,
        new_init,
    }).await.map_err(|e| e.to_string())
}
```

## テスト

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_switch_simple_to_master_password() {
        let switcher = create_test_switcher().await;

        // Simpleプロバイダーで初期化
        // 認証情報を保存
        // MasterPasswordに切り替え
        // 認証情報が正しく再暗号化されていることを確認
    }

    #[tokio::test]
    async fn test_switch_master_password_to_keychain() {
        // MasterPasswordからKeychainへの切り替えテスト
    }

    #[tokio::test]
    async fn test_switch_rollback_on_failure() {
        // 切り替え失敗時のロールバックテスト
    }
}
```

## 実装チェックリスト

- [ ] `SwitchParams` 構造体実装
- [ ] `SwitchResult` 構造体実装
- [ ] `SwitchError` エラー型実装
- [ ] `ProviderSwitcher` 構造体実装
- [ ] `DecryptedCredential` 構造体実装（zeroize対応）
- [ ] ロールバック機能実装
- [ ] Tauriコマンド実装
- [ ] ユニットテスト作成
- [ ] 統合テスト作成

---

**作成日**: 2025-11-24
**作成者**: Claude Code
